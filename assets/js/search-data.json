{"0": {
    "doc": "Access Control",
    "title": "Access Control",
    "content": "❗️Access control is experimental. Please share your feedback. Access policies may be used to control when actions can be invoked by agents. All actions may declare an access policy like the following example: . @action(access_policy=ACCESS_PERMITTED) def my_action(self): ... An access policy can currently be one of three values: . | ACCESS_PERMITTED - (Default) Permits any agent to use that action at any time. | ACCESS_DENIED - Prevents access to that action. | ACCESS_REQUESTED - Prompts the receiving agent for permission when access is attempted. Access will await approval or denial. | . If ACCESS_REQUESTED is used, the receiving agent will be prompted to approve the action via the request_permission() callback method. If any actions declare a policy of ACCESS_REQUESTED, you must implement the request_permission() method with the following signature in order to receive permission requests. def request_permission(self, proposed_message: dict) -&gt; bool: ... Your implementation should inspect proposed_message and return a boolean indicating whether or not to permit the action. You can use this approach to protect against dangerous actions being taken. For example if you allow terminal access, you may want to review commands before they are invoked. ",
    "url": "/articles/access_control",
    
    "relUrl": "/articles/access_control"
  },"1": {
    "doc": "Defining Action Metadata",
    "title": "Defining Action Metadata",
    "content": "The @action decorator takes the following keyword arguments: . | name: The name of the action. Defaults to the method name | help: The description of the action. Defaults to an autogenerated object | access_policy: The access policy of the action. Defaults to ACCESS_PERMITTED | . ",
    "url": "/articles/action_metadata",
    
    "relUrl": "/articles/action_metadata"
  },"2": {
    "doc": "Defining Action Metadata",
    "title": "Defining Help",
    "content": "Below is an example of the help information generated by default from the @action decorator. It uses the docstring of the method, and its signature to generate the default help information. { \"shell_command\": { \"description\": \"Execute a shell command\", \"args\": { \"command\": { \"type\": \"string\" \"description\": \"The command to execute\" } }, \"returns\": { \"type\": \"string\" \"description\": \"The output of the command\" } }, ... } . The following example shows how the same help information above can be defined using a docstring that follows the Google style guide: . @action def shell_command(self, command: str) -&gt; str: \"\"\" Execute a shell command Args: command (str): The command to execute Returns: str: The output of the command \"\"\" . The action name is determined by the method name. Types are determined by looking at the docstring and the signature, with the signature type hint taking precedence. Action and argument descriptions are parsed from the docstring. ",
    "url": "/articles/action_metadata#defining-help",
    
    "relUrl": "/articles/action_metadata#defining-help"
  },"3": {
    "doc": "Defining Action Metadata",
    "title": "Overriding Help Information",
    "content": "The default help data structure described above can be overridden by supplying a custom help object to the @action decorator. @action( help={ \"You\": \"can define\", \"any\": { \"structure\": [\"you\", \"want\", \"here.\"] } } ) def say(self, content: str) -&gt; None: . When a custom help object is provided, it overrides the generated object entirely. You can use this to experiment with different help information schemas. ",
    "url": "/articles/action_metadata#overriding-help-information",
    
    "relUrl": "/articles/action_metadata#overriding-help-information"
  },"4": {
    "doc": "Agent Callbacks",
    "title": "Agent Callbacks",
    "content": "The following list describes all available agent callbacks, with a link to their API documentation. Please see the API docs for more detailed descriptions of these callbacks. after_add . Called after an agent is added to a space, but before it begins processing messages. before_remove . Called before an agent is removed from a space and will no longer process more messages. handle_action_value . If an action method returns a value, this method will be called with the value. handle_action_error . Receives any error messages from an action invoked by the agent. before_action . Called before an action is attempted. after_action . Called after an action is attempted. request_permission . Called when an agent attempts to perform an action that requires permission. ",
    "url": "/articles/agent_callbacks",
    
    "relUrl": "/articles/agent_callbacks"
  },"5": {
    "doc": "Messaging Schema",
    "title": "Messaging Schema",
    "content": "All messages are validated upon sending and must conform to the message schema. The full message schema is summarized by this example: . { \"meta\": { \"an\": \"optional\", \"object\": { \"for\": \"metadata\", } }, \"from\": \"the sender's id\", \"to\": \"the receiver's id\", \"action\": { \"name\": \"the_action_name\", \"args\": { \"the\": \"args\", } } } . Note that when sending, you may not need to supply this entire structure. The meta field is entirely optional. Additionally, the from field is automatically populated for you in the send() and request() methods. An example of calling Agent.send() with only the minimum fields would look like: . self.send({ \"to\": \"some_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } }) . See agency/schema.py for the pydantic model definition used for validation. ",
    "url": "/articles/messaging_schema",
    
    "relUrl": "/articles/messaging_schema"
  },"6": {
    "doc": "Messaging Schema",
    "title": "The meta Field",
    "content": "The meta field may be used to store arbitrary key-value metadata about the message. It is entirely optional. Possible uses of the meta field include: . | Storing “thoughts” associated with an action. This is a common pattern used with LLM agents. For example, an LLM agent may send the following message: { \"meta\": { \"thoughts\": \"I should say hello to everyone\", }, \"to\": \"my_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } } . | Storing timestamps associated with an action. For example: { \"meta\": { \"timestamp\": 12345, }, ... } . | . These are just a couple ideas to illustrate the use of the meta field. Using the meta.id Field . The meta.id field is used by the original_message() method during the handle_action_value() and handle_action_error() callbacks to return the original message that the value or error corresponds to. If you make use of the handle_action_value and handle_action_error callbacks, you should populate the meta.id field to allow this correlation. ",
    "url": "/articles/messaging_schema#the-meta-field",
    
    "relUrl": "/articles/messaging_schema#the-meta-field"
  },"7": {
    "doc": "Messaging Schema",
    "title": "Broadcast vs Point-to-Point",
    "content": "All messages require the to field to be specified. The to field should be the id of an agent in the space (point-to-point) or the special id * to broadcast the message to all agents in the space. By default, agents receive their own broadcasts, but you may change this behavior with the receive_own_broadcasts argument when creating the agent. For example: . my_agent = MyAgent(\"MyAgent\", receive_own_broadcasts=False) . ",
    "url": "/articles/messaging_schema#broadcast-vs-point-to-point",
    
    "relUrl": "/articles/messaging_schema#broadcast-vs-point-to-point"
  },"8": {
    "doc": "Messaging Schema",
    "title": "Non-Existent Agents or Actions",
    "content": "If you send a message to a non-existent agent, it will silently fail. If you send a message to an existent agent, but specify a non-existent action, you will receive an error message in response. Broadcasts which specify a non-existent action are silently ignored. ",
    "url": "/articles/messaging_schema#non-existent-agents-or-actions",
    
    "relUrl": "/articles/messaging_schema#non-existent-agents-or-actions"
  },"9": {
    "doc": "Synchronous Requests",
    "title": "Synchronous Requests",
    "content": "The Agent.request() method is a synchronous version of the send() method that allows you to call an action and receive its return value or exception synchronously. If the action responds with an error, an ActionError will be raised containing the error message. Here’s an example of how you might use request(): . try: return_value = self.request({ \"to\": \"ExampleAgent\", \"action\": { \"name\": \"example_action\", \"args\": { \"content\": \"hello\" } } }, timeout=5) except ActionError as e: print(e.message) . Note that request() may not be called during the after_add() and before_remove() callbacks, but may be used within actions or other callbacks. Also notice the timeout value. The default is 3 seconds. Make sure to increase this appropriately for longer running actions. ",
    "url": "/articles/synchronous_requests",
    
    "relUrl": "/articles/synchronous_requests"
  },"10": {
    "doc": "Using AMQPSpace",
    "title": "Using AMQPSpace",
    "content": "To use AMQP for networked communication, you can use the AMQPSpace class. To run across multiple hosts, you would separate your agents into multiple applications. Each application would be configured to use the same AMQP server. For example, the following would separate the Host agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a host agent to the space space.add(Host, \"Host\") # keep alive while True: time.sleep(1) . And the following would separate the ChattyAI agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a simple HF based chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") # keep alive while True: time.sleep(1) . Then you can run both applications at the same time, and the agents will be able to connect and communicate with each other over AMQP. This approach allows you to scale your agents beyond a single host. See the example application for a full working example. ",
    "url": "/articles/using_amqpspace",
    
    "relUrl": "/articles/using_amqpspace"
  },"11": {
    "doc": "Using AMQPSpace",
    "title": "Configuring AMQP Connectivity",
    "content": "By default, the AMQPSpace class will read the following environment variables and will otherwise use default settings. AMQP_HOST AMQP_PORT AMQP_USERNAME AMQP_PASSWORD AMQP_VHOST . You may also customize the options if you provide your own AMQPOptions object when instantiating an AMQPSpace. For example: . space = AMQPSpace( amqp_options=AMQPOptions( hostname=\"localhost\", port=5672, username=\"guest\", password=\"guest\", virtual_host=\"/\", use_ssl=True, heartbeat=60)) . ",
    "url": "/articles/using_amqpspace#configuring-amqp-connectivity",
    
    "relUrl": "/articles/using_amqpspace#configuring-amqp-connectivity"
  },"12": {
    "doc": "Demo Application Walkthrough",
    "title": "Demo Application Walkthrough",
    "content": "The following walkthrough will guide you through the basic concepts of Agency’s API, and how to use it to build a simple agent system, using the main demo application as an example. In this walkthrough, we’ll be using the MultiprocessSpace class for connecting agents. Usage is exactly the same as with any other space type, such as ThreadSpace or AMQPSpace. The Space type determines both the concurrency and communication implementation used for the space. ",
    "url": "/articles/walkthrough",
    
    "relUrl": "/articles/walkthrough"
  },"13": {
    "doc": "Demo Application Walkthrough",
    "title": "Creating a Space and adding Agents",
    "content": "The following snippet, adapted from the demo application, shows how to instantiate a space and add several agents to it. The application includes OpenAIFunctionAgent which uses the OpenAI API, a local LLM chat agent named ChattyAI, operating system access via the Host agent, and a Gradio based chat application which adds its user to the space as an agent as well. # Create the space instance space = MultiprocessSpace() # Add a Host agent to the space, exposing access to the host system space.add(Host, \"Host\") # Add a local chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") # Add an OpenAI function API agent to the space space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the OpenAI chat API user_id=\"User\") # GradioApp adds its user as an agent named \"User\" to the space GradioApp(space).demo().launch() . Notice that each agent is given a unique id. An agent’s id is used to identify the agent within the space. Other agents may send messages to Chatty or Host by using their id’s, as we’ll see later. ",
    "url": "/articles/walkthrough#creating-a-space-and-adding-agents",
    
    "relUrl": "/articles/walkthrough#creating-a-space-and-adding-agents"
  },"14": {
    "doc": "Demo Application Walkthrough",
    "title": "Defining an Agent and its Actions",
    "content": "To create an Agent type, simply extend the Agent class. We’ll use the ChattyAI agent as an example. class ChattyAI(Agent): ... Then to define actions, you define instance methods and use the @action decorator. For example the following defines an action called say that takes a single string argument content. @action def say(self, content: str): \"\"\"Use this action to say something to Chatty\"\"\" ... By defining an action, we allow other agents in a common space to discover and invoke the action on the agent. This is an example of how you can allow agents to send chat messages to one another. Other agents may invoke this action by sending a message to Chatty as we’ll see below. ",
    "url": "/articles/walkthrough#defining-an-agent-and-its-actions",
    
    "relUrl": "/articles/walkthrough#defining-an-agent-and-its-actions"
  },"15": {
    "doc": "Demo Application Walkthrough",
    "title": "Invoking Actions",
    "content": "When agents are added to a space, they may send messages to other agents to invoke their actions. An example of invoking an action can be seen here, taken from the ChattyAI.say() implementation... self.send({ \"to\": self.current_message()['from'], # reply to the sender \"action\": { \"name\": \"say\", \"args\": { \"content\": response_content, } } }) . This demonstrates the basic idea of how to send a message to invoke an action on another agent. When an agent receives a message, it invokes the actions method, passing action.args as keyword arguments. So here, Chatty is invoking the say action on the sender of the original message, passing the response as the content argument. This way, the original sender and Chatty can have a conversation. Note the use of the current_message() method. That method may be used during an action to inspect the entire message which invoked the current action. ",
    "url": "/articles/walkthrough#invoking-actions",
    
    "relUrl": "/articles/walkthrough#invoking-actions"
  },"16": {
    "doc": "Demo Application Walkthrough",
    "title": "The Gradio UI",
    "content": "The Gradio UI is a Chatbot based application used for development and demonstration. It is defined in examples/demo/apps/gradio_app.py and simply needs to be imported and used like so: . from examples.demo.apps.gradio_app import GradioApp ... demo = GradioApp(space).demo() demo.launch() . The Gradio application automatically adds its user to the space as an agent, allowing you (as that agent) to chat with the other agents. The application is designed to convert plain text input into a say action which is broadcast to the other agents in the space. For example, simply writing: . Hello, world! . will invoke the say action on all other agents in the space, passing the content argument as Hello, world!. Any agents which implement a say action will receive and process this message. Gradio App - Command Syntax . The Gradio application also supports a command syntax for more control over invoking actions on other agents. For example, to send a point-to-point message to a specific agent, or to call actions other than say, you can use the following format: . /agent_id.action_name arg1:\"value 1\" arg2:\"value 2\" . A broadcast to all agents in the space is also supported using the * wildcard. For example, the following will broadcast the say action to all other agents, similar to how it would work without the slash syntax: . /*.say content:\"Hello, world!\" . ",
    "url": "/articles/walkthrough#the-gradio-ui",
    
    "relUrl": "/articles/walkthrough#the-gradio-ui"
  },"17": {
    "doc": "Demo Application Walkthrough",
    "title": "Discovering Actions",
    "content": "At this point, we can demonstrate how action discovery works from the perspective of a human user of the web application. Each agent in the space has a help action, which returns a dictionary of their available actions. To discover available actions across all agents, simply type: . /*.help . Each agent will respond with a dictionary of their available actions. To request help on a specific agent, you can use the following syntax: . /Host.help . To request help on a specific action, you can specify the action name: . /Host.help action_name:\"say\" . ",
    "url": "/articles/walkthrough#discovering-actions",
    
    "relUrl": "/articles/walkthrough#discovering-actions"
  },"18": {
    "doc": "Demo Application Walkthrough",
    "title": "Adding an Intelligent Agent",
    "content": "Now we can add an intelligent agent into the space and allow them to discover and invoke actions. To add the OpenAIFunctionAgent class to the environment: . space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the chat API user_id=\"User\") . If you inspect the implementation, you’ll see that this agent uses the after_add callback to request help information from the other agents in the space, and later uses that information to provide a list of functions to the OpenAI function calling API. ",
    "url": "/articles/walkthrough#adding-an-intelligent-agent",
    
    "relUrl": "/articles/walkthrough#adding-an-intelligent-agent"
  },"19": {
    "doc": "Demo Application Walkthrough",
    "title": "Wrapping up",
    "content": "This concludes the demo walkthrough. To try the demo, please jump to the examples/demo directory. ",
    "url": "/articles/walkthrough#wrapping-up",
    
    "relUrl": "/articles/walkthrough#wrapping-up"
  },"20": {
    "doc": "agency",
    "title": "\nagency    ",
    "content": "View Source 1import multiprocessing 2 3multiprocessing.set_start_method(&#39;spawn&#39;, force=True) . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"21": {
    "doc": "agency",
    "title": "Submodules",
    "content": ". | agent | logger | schema | space | spaces | . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"22": {
    "doc": "agency",
    "title": "agency",
    "content": " ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"23": {
    "doc": "agency.agent",
    "title": "\nagency.agent    ",
    "content": "View Source 1import inspect 2import re 3import threading 4import time 5import uuid 6from typing import Dict, List, Protocol 7 8from docstring_parser import DocstringStyle, parse 9 10from agency.logger import log 11from agency.schema import Message 12 13 14def _python_to_json_type_name(python_type_name: str) -&gt; str: 15 return { 16 &#39;str&#39;: &#39;string&#39;, 17 &#39;int&#39;: &#39;number&#39;, 18 &#39;float&#39;: &#39;number&#39;, 19 &#39;bool&#39;: &#39;boolean&#39;, 20 &#39;list&#39;: &#39;array&#39;, 21 &#39;dict&#39;: &#39;object&#39; 22 }[python_type_name] 23 24 25def _generate_help(method: callable) -&gt; dict: 26 &quot;&quot;&quot; 27 Generates a help object from a method&#39;s docstring and signature 28 29 Args: 30 method: the method 31 32 Returns: 33 A help object of the form: 34 35 { 36 &quot;description&quot;: &lt;description&gt;, 37 &quot;args&quot;: { 38 &quot;arg_name&quot;: { 39 &quot;type&quot;: &lt;type&gt;, 40 &quot;description&quot;: &lt;description&gt; 41 }, 42 } 43 &quot;returns&quot;: { 44 &quot;type&quot;: &lt;type&gt;, 45 &quot;description&quot;: &lt;description&gt; 46 } 47 } 48 &quot;&quot;&quot; 49 signature = inspect.signature(method) 50 parsed_docstring = parse(method.__doc__, DocstringStyle.GOOGLE) 51 52 help_object = {} 53 54 # description 55 if parsed_docstring.short_description is not None: 56 description = parsed_docstring.short_description 57 if parsed_docstring.long_description is not None: 58 description += &quot; &quot; + parsed_docstring.long_description 59 help_object[&quot;description&quot;] = re.sub(r&quot;\\s+&quot;, &quot; &quot;, description).strip() 60 61 # args 62 help_object[&quot;args&quot;] = {} 63 docstring_args = {arg.arg_name: arg for arg in parsed_docstring.params} 64 arg_names = list(signature.parameters.keys())[1:] # skip &#39;self&#39; argument 65 for arg_name in arg_names: 66 arg_object = {} 67 68 # type 69 sig_annotation = signature.parameters[arg_name].annotation 70 if sig_annotation is not None and sig_annotation.__name__ != &quot;_empty&quot;: 71 arg_object[&quot;type&quot;] = _python_to_json_type_name( 72 signature.parameters[arg_name].annotation.__name__) 73 elif arg_name in docstring_args and docstring_args[arg_name].type_name is not None: 74 arg_object[&quot;type&quot;] = _python_to_json_type_name( 75 docstring_args[arg_name].type_name) 76 77 # description 78 if arg_name in docstring_args and docstring_args[arg_name].description is not None: 79 arg_object[&quot;description&quot;] = docstring_args[arg_name].description.strip() 80 81 help_object[&quot;args&quot;][arg_name] = arg_object 82 83 # returns 84 if parsed_docstring.returns is not None: 85 help_object[&quot;returns&quot;] = {} 86 87 # type 88 if signature.return_annotation is not None: 89 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 90 signature.return_annotation.__name__) 91 elif parsed_docstring.returns.type_name is not None: 92 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 93 parsed_docstring.returns.type_name) 94 95 # description 96 if parsed_docstring.returns.description is not None: 97 help_object[&quot;returns&quot;][&quot;description&quot;] = parsed_docstring.returns.description.strip() 98 99 return help_object 100 101 102# Special action name for responses 103_RESPONSE_ACTION_NAME = &quot;[response]&quot; 104 105 106# Access policies 107ACCESS_PERMITTED = &quot;ACCESS_PERMITTED&quot; 108ACCESS_DENIED = &quot;ACCESS_DENIED&quot; 109ACCESS_REQUESTED = &quot;ACCESS_REQUESTED&quot; 110 111 112def action(*args, **kwargs): 113 &quot;&quot;&quot; 114 Declares instance methods as actions making them accessible to other agents. 115 116 Keyword arguments: 117 name: The name of the action. Defaults to the name of the method. 118 help: The help object. Defaults to a generated object. 119 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 120 &quot;&quot;&quot; 121 def decorator(method): 122 action_name = kwargs.get(&quot;name&quot;, method.__name__) 123 if action_name == _RESPONSE_ACTION_NAME: 124 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 125 method.action_properties = { 126 &quot;name&quot;: method.__name__, 127 &quot;help&quot;: _generate_help(method), 128 &quot;access_policy&quot;: ACCESS_PERMITTED, 129 **kwargs} 130 return method 131 132 if len(args) == 1 and callable(args[0]) and not kwargs: 133 return decorator(args[0]) # The decorator was used without parentheses 134 else: 135 return decorator # The decorator was used with parentheses 136 137 138class _QueueProtocol(Protocol): 139 &quot;&quot;&quot;A protocol for providing an outbound queue for an Agent&quot;&quot;&quot; 140 141 def put(self, message: Message): 142 &quot;&quot;&quot; 143 Put a message onto the queue for sending 144 145 Args: 146 message: The message 147 &quot;&quot;&quot; 148 149 def get(self) -&gt; Message: 150 &quot;&quot;&quot; 151 Get the next message from the queue 152 153 Returns: 154 The next message 155 156 Raises: 157 queue.Empty: If there are no messages 158 &quot;&quot;&quot; 159 160 161class ActionError(Exception): 162 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; 163 164 165class Agent(): 166 &quot;&quot;&quot; 167 An Actor that may represent an AI agent, computing system, or human user 168 &quot;&quot;&quot; 169 170 def __init__(self, 171 id: str, 172 outbound_queue: _QueueProtocol, 173 receive_own_broadcasts: bool = True): 174 &quot;&quot;&quot; 175 Initializes an Agent. 176 177 This constructor is not meant to be called directly. It is invoked by 178 the Space class when adding an agent. 179 180 Subclasses should call super().__init__() in their constructor. 181 182 Args: 183 id: The id of the agent 184 outbound_queue: The outgoing queue for sending messages 185 receive_own_broadcasts: 186 Whether the agent will receive its own broadcasts. Defaults to 187 True 188 &quot;&quot;&quot; 189 if len(id) &lt; 1 or len(id) &gt; 255: 190 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 191 if re.match(r&quot;^amq\\.&quot;, id): 192 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 193 if id == &quot;*&quot;: 194 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 195 if outbound_queue is None: 196 raise ValueError(&quot;outbound_queue must be provided&quot;) 197 self._id: str = id 198 self._outbound_queue: _QueueProtocol = outbound_queue 199 self._receive_own_broadcasts: bool = receive_own_broadcasts 200 self._is_processing: bool = False # set by the Space 201 self._message_log: List[Message] = [] 202 self._message_log_lock = threading.Lock() 203 self._pending_responses: Dict[str, Message] = {} 204 self._pending_responses_lock = threading.Lock() 205 self.__thread_local_current_message = threading.local() 206 self.__thread_local_current_message.value: Message = None 207 208 def id(self) -&gt; str: 209 return self._id 210 211 def send(self, message: dict): 212 &quot;&quot;&quot; 213 Sends (out) a message from this agent. 214 215 Args: 216 message: The message 217 &quot;&quot;&quot; 218 log(&quot;info&quot;, f&quot;{self.id()} sending message&quot;, message) 219 message[&quot;from&quot;] = self.id() 220 with self._message_log_lock: 221 self._message_log.append(message) 222 self._outbound_queue.put(message) 223 224 def request(self, message: dict, timeout: float = 3) -&gt; object: 225 &quot;&quot;&quot; 226 Synchronously sends a message then waits for and returns the return 227 value of the invoked action. 228 229 This method allows you to call an action synchronously like a function 230 and receive its return value in python. If the action raises an 231 exception an ActionError will be raised containing the error message. 232 233 Args: 234 message: The message to send 235 timeout: 236 The timeout in seconds to wait for the returned value. 237 Defaults to 3 seconds. 238 239 Returns: 240 object: The return value of the action. 241 242 Raises: 243 TimeoutError: If the timeout is reached 244 ActionError: If the action raised an exception 245 &quot;&quot;&quot; 246 if not self._is_processing: 247 raise RuntimeError( 248 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 249 250 # Set the message id 251 # Having a meta.request_id identifies it as a request 252 request_id = f&quot;request--{uuid.uuid4()}&quot; 253 message[&quot;meta&quot;] = message.get(&quot;meta&quot;, {}) 254 message[&quot;meta&quot;][&quot;request_id&quot;] = request_id 255 256 # Send and mark the request as pending 257 self.send(message) 258 pending = object() 259 with self._pending_responses_lock: 260 self._pending_responses[request_id] = pending 261 262 # Wait for response 263 start_time = time.time() 264 while self._pending_responses[request_id] == pending: 265 time.sleep(0.001) 266 if time.time() - start_time &gt; timeout: 267 raise TimeoutError 268 269 # Raise error or return value from response 270 with self._pending_responses_lock: 271 response_message = self._pending_responses.pop(request_id) 272 if &quot;error&quot; in response_message[&quot;action&quot;][&quot;args&quot;]: 273 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 274 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 275 276 def _receive(self, message: dict): 277 &quot;&quot;&quot; 278 Receives and handles an incoming message. 279 280 Args: 281 message: The incoming message 282 &quot;&quot;&quot; 283 # Ignore own broadcasts if _receive_own_broadcasts is false 284 if not self._receive_own_broadcasts \\ 285 and message[&#39;from&#39;] == self.id() \\ 286 and message[&#39;to&#39;] == &#39;*&#39;: 287 return 288 289 log(&quot;debug&quot;, f&quot;{self.id()} received message&quot;, message) 290 291 # Record the received message before handling 292 with self._message_log_lock: 293 self._message_log.append(message) 294 295 # Handle incoming responses 296 response_id = message.get(&quot;meta&quot;, {}).get(&quot;response_id&quot;) 297 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 298 if response_id in self._pending_responses.keys(): 299 # This was a response to a request() 300 self._pending_responses[response_id] = message 301 # From here the request() method will pick up the response in 302 # the existing thread 303 else: 304 # This was a response to a send() 305 if &quot;value&quot; in message[&quot;action&quot;][&quot;args&quot;]: 306 handler_callback = self.handle_action_value 307 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 308 elif &quot;error&quot; in message[&quot;action&quot;][&quot;args&quot;]: 309 handler_callback = self.handle_action_error 310 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 311 else: 312 raise RuntimeError(&quot;Unknown action response&quot;) 313 314 # Spawn a thread to handle the response 315 def __process_response(arg, current_message): 316 log(&quot;debug&quot;, f&quot;{self.id()} processing response&quot;, message) 317 self.__thread_local_current_message.value = current_message 318 handler_callback(arg) 319 320 threading.Thread( 321 target=__process_response, 322 args=(arg, message, ), 323 daemon=True, 324 ).start() 325 326 # Handle all other messages 327 else: 328 # Spawn a thread to process the message. This means that messages 329 # are processed concurrently, but may be processed out of order. 330 threading.Thread( 331 target=self.__process, args=(message,), daemon=True).start() 332 333 def __process(self, message: dict): 334 &quot;&quot;&quot; 335 Top level method within the action processing thread. 336 &quot;&quot;&quot; 337 log(&quot;debug&quot;, f&quot;{self.id()} processing message&quot;, message) 338 self.__thread_local_current_message.value = message 339 request_id = message.get(&quot;meta&quot;, {}).get(&quot;request_id&quot;) 340 response_id = request_id or message.get(&quot;meta&quot;, {}).get(&quot;id&quot;) 341 try: 342 # Commit the action 343 return_value = self.__commit(message) 344 345 # If the action returned a value or this was a request (which 346 # expects a value), return it 347 if request_id or return_value is not None: 348 self.send({ 349 &quot;meta&quot;: { 350 &quot;response_id&quot;: response_id 351 }, 352 &quot;to&quot;: message[&#39;from&#39;], 353 &quot;action&quot;: { 354 &quot;name&quot;: _RESPONSE_ACTION_NAME, 355 &quot;args&quot;: { 356 &quot;value&quot;: return_value, 357 } 358 } 359 }) 360 except Exception as e: 361 # Handle errors (including PermissionError) that occur while 362 # committing an action by reporting back to the sender. 363 log(&quot;debug&quot;, 364 f&quot;{self.id()} exception while committing action {message[&#39;action&#39;][&#39;name&#39;]}&quot;, e) 365 request_id = message.get(&quot;meta&quot;, {}).get(&quot;request_id&quot;) 366 self.send({ 367 &quot;meta&quot;: { 368 &quot;response_id&quot;: response_id 369 }, 370 &quot;to&quot;: message[&#39;from&#39;], 371 &quot;from&quot;: self.id(), 372 &quot;action&quot;: { 373 &quot;name&quot;: _RESPONSE_ACTION_NAME, 374 &quot;args&quot;: { 375 &quot;error&quot;: f&quot;{e.__class__.__name__}: {e}&quot; 376 } 377 } 378 }) 379 380 def __commit(self, message: dict): 381 &quot;&quot;&quot; 382 Invokes the action method 383 384 Args: 385 message: The incoming message specifying the action 386 387 Raises: 388 AttributeError: If the action method is not found 389 PermissionError: If the action is not permitted 390 &quot;&quot;&quot; 391 try: 392 # Check if the action method exists 393 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 394 except KeyError: 395 # the action was not found 396 if message[&#39;to&#39;] == &#39;*&#39;: 397 return # broadcasts will not raise an error in this situation 398 else: 399 raise AttributeError( 400 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 401 402 # Check if the action is permitted 403 if not self.__permitted(message): 404 raise PermissionError( 405 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 406 407 self.before_action(message) 408 409 return_value = None 410 error = None 411 try: 412 # Invoke the action method 413 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 414 except Exception as e: 415 error = e 416 raise 417 finally: 418 self.after_action(message, return_value, error) 419 return return_value 420 421 def __permitted(self, message: dict) -&gt; bool: 422 &quot;&quot;&quot; 423 Checks whether the message&#39;s action is allowed 424 &quot;&quot;&quot; 425 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 426 policy = action_method.action_properties[&quot;access_policy&quot;] 427 if policy == ACCESS_PERMITTED: 428 return True 429 elif policy == ACCESS_DENIED: 430 return False 431 elif policy == ACCESS_REQUESTED: 432 return self.request_permission(message) 433 else: 434 raise Exception( 435 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 436 437 def __action_methods(self) -&gt; dict: 438 instance_methods = inspect.getmembers(self, inspect.ismethod) 439 action_methods = { 440 method_name: method 441 for method_name, method in instance_methods 442 if hasattr(method, &quot;action_properties&quot;) 443 } 444 return action_methods 445 446 def __action_method(self, action_name: str): 447 &quot;&quot;&quot; 448 Returns the method for the given action name. 449 &quot;&quot;&quot; 450 action_methods = self.__action_methods() 451 return action_methods[action_name] 452 453 def current_message(self) -&gt; Message: 454 &quot;&quot;&quot; 455 Returns the full message which invoked the current action. 456 457 This method may be called within an action to retrieve the current 458 message, for example to determine the sender or inspect other details. 459 460 Returns: 461 The current message 462 &quot;&quot;&quot; 463 return self.__thread_local_current_message.value 464 465 def original_message(self) -&gt; Message: 466 &quot;&quot;&quot; 467 Returns the original message that the current message is responding to. 468 469 This method may be called during the handle_action_value() and 470 handle_action_error() callbacks to inspect the original message. 471 472 The original message must define the meta.id field for this method to 473 return it. Otherwise, this method will return None. 474 475 Returns: 476 The original message or None 477 &quot;&quot;&quot; 478 current_message = self.__thread_local_current_message.value 479 original_message_id = current_message.get(&quot;meta&quot;, {}).get(&quot;id&quot;) 480 if original_message_id: 481 original_message = None 482 for message in self._message_log: 483 if message[&quot;meta&quot;][&quot;id&quot;] == original_message_id: 484 original_message = message 485 break 486 return original_message 487 488 @action 489 def help(self, action_name: str = None) -&gt; dict: 490 &quot;&quot;&quot; 491 Returns a list of actions on this agent. 492 493 If action_name is passed, returns a list with only that action. 494 If no action_name is passed, returns all actions. 495 496 Args: 497 action_name: (Optional) The name of an action to request help for 498 499 Returns: 500 A dictionary of actions 501 &quot;&quot;&quot; 502 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME] 503 help_list = { 504 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 505 for method in self.__action_methods().values() 506 if action_name is None 507 and method.action_properties[&quot;name&quot;] not in special_actions 508 or method.action_properties[&quot;name&quot;] == action_name 509 } 510 return help_list 511 512 def handle_action_value(self, value): 513 &quot;&quot;&quot; 514 Receives a return value from a previous action. 515 516 This method receives return values from actions invoked by the send() 517 method. It is not called when using the request() method, which returns 518 the value directly. 519 520 To inspect the full response message, use current_message(). 521 522 To inspect the original message, use original_message(). Note that the 523 original message must define the meta.id field or original_message() 524 will return None. 525 526 Args: 527 value: 528 The return value 529 &quot;&quot;&quot; 530 log(&quot;warning&quot;, 531 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 532 533 def handle_action_error(self, error: ActionError): 534 &quot;&quot;&quot; 535 Receives an error from a previous action. 536 537 This method receives errors from actions invoked by the send() method. 538 It is not called when using the request() method, which raises an error 539 directly. 540 541 To inspect the full response message, use current_message(). 542 543 To inspect the original message, use original_message(). Note that the 544 original message must define the meta.id field or original_message() 545 will return None. 546 547 Args: 548 error: The error 549 &quot;&quot;&quot; 550 log(&quot;warning&quot;, 551 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 552 553 def after_add(self): 554 &quot;&quot;&quot; 555 Called after the agent is added to a space, but before it begins 556 processing incoming messages. 557 558 The agent may send messages during this callback using the send() 559 method, but may not use the request() method since it relies on 560 processing incoming messages. 561 &quot;&quot;&quot; 562 563 def before_remove(self): 564 &quot;&quot;&quot; 565 Called before the agent is removed from a space, after it has finished 566 processing incoming messages. 567 568 The agent may send final messages during this callback using the send() 569 method, but may not use the request() method since it relies on 570 processing incoming messages. 571 &quot;&quot;&quot; 572 573 def before_action(self, message: dict): 574 &quot;&quot;&quot; 575 Called before every action. 576 577 This method will only be called if the action exists and is permitted. 578 579 Args: 580 message: The received message that contains the action 581 &quot;&quot;&quot; 582 583 def after_action(self, message: dict, return_value: str, error: str): 584 &quot;&quot;&quot; 585 Called after every action, regardless of whether an error occurred. 586 587 Args: 588 message: The message which invoked the action 589 return_value: The return value from the action 590 error: The error from the action if any 591 &quot;&quot;&quot; 592 593 def request_permission(self, proposed_message: dict) -&gt; bool: 594 &quot;&quot;&quot; 595 Receives a proposed action message and presents it to the agent for 596 review. 597 598 Args: 599 proposed_message: The proposed action message 600 601 Returns: 602 True if access should be permitted 603 &quot;&quot;&quot; 604 raise NotImplementedError( 605 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . ACCESS_PERMITTED = &#39;ACCESS_PERMITTED&#39; ACCESS_DENIED = &#39;ACCESS_DENIED&#39; ACCESS_REQUESTED = &#39;ACCESS_REQUESTED&#39; def action(*args, **kwargs): View Source 113def action(*args, **kwargs): 114 &quot;&quot;&quot; 115 Declares instance methods as actions making them accessible to other agents. 116 117 Keyword arguments: 118 name: The name of the action. Defaults to the name of the method. 119 help: The help object. Defaults to a generated object. 120 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 121 &quot;&quot;&quot; 122 def decorator(method): 123 action_name = kwargs.get(&quot;name&quot;, method.__name__) 124 if action_name == _RESPONSE_ACTION_NAME: 125 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 126 method.action_properties = { 127 &quot;name&quot;: method.__name__, 128 &quot;help&quot;: _generate_help(method), 129 &quot;access_policy&quot;: ACCESS_PERMITTED, 130 **kwargs} 131 return method 132 133 if len(args) == 1 and callable(args[0]) and not kwargs: 134 return decorator(args[0]) # The decorator was used without parentheses 135 else: 136 return decorator # The decorator was used with parentheses . Declares instance methods as actions making them accessible to other agents. Keyword arguments: . name: The name of the action. Defaults to the name of the method. help: The help object. Defaults to a generated object. access_policy: The access policy. Defaults to ACCESS_PERMITTED. class ActionError(builtins.Exception): View Source 162class ActionError(Exception): 163 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; . Raised from the request() method if the action responds with an error . Inherited Members . builtins.Exception Exception builtins.BaseException with_traceback args class Agent: View Source 166class Agent(): 167 &quot;&quot;&quot; 168 An Actor that may represent an AI agent, computing system, or human user 169 &quot;&quot;&quot; 170 171 def __init__(self, 172 id: str, 173 outbound_queue: _QueueProtocol, 174 receive_own_broadcasts: bool = True): 175 &quot;&quot;&quot; 176 Initializes an Agent. 177 178 This constructor is not meant to be called directly. It is invoked by 179 the Space class when adding an agent. 180 181 Subclasses should call super().__init__() in their constructor. 182 183 Args: 184 id: The id of the agent 185 outbound_queue: The outgoing queue for sending messages 186 receive_own_broadcasts: 187 Whether the agent will receive its own broadcasts. Defaults to 188 True 189 &quot;&quot;&quot; 190 if len(id) &lt; 1 or len(id) &gt; 255: 191 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 192 if re.match(r&quot;^amq\\.&quot;, id): 193 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 194 if id == &quot;*&quot;: 195 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 196 if outbound_queue is None: 197 raise ValueError(&quot;outbound_queue must be provided&quot;) 198 self._id: str = id 199 self._outbound_queue: _QueueProtocol = outbound_queue 200 self._receive_own_broadcasts: bool = receive_own_broadcasts 201 self._is_processing: bool = False # set by the Space 202 self._message_log: List[Message] = [] 203 self._message_log_lock = threading.Lock() 204 self._pending_responses: Dict[str, Message] = {} 205 self._pending_responses_lock = threading.Lock() 206 self.__thread_local_current_message = threading.local() 207 self.__thread_local_current_message.value: Message = None 208 209 def id(self) -&gt; str: 210 return self._id 211 212 def send(self, message: dict): 213 &quot;&quot;&quot; 214 Sends (out) a message from this agent. 215 216 Args: 217 message: The message 218 &quot;&quot;&quot; 219 log(&quot;info&quot;, f&quot;{self.id()} sending message&quot;, message) 220 message[&quot;from&quot;] = self.id() 221 with self._message_log_lock: 222 self._message_log.append(message) 223 self._outbound_queue.put(message) 224 225 def request(self, message: dict, timeout: float = 3) -&gt; object: 226 &quot;&quot;&quot; 227 Synchronously sends a message then waits for and returns the return 228 value of the invoked action. 229 230 This method allows you to call an action synchronously like a function 231 and receive its return value in python. If the action raises an 232 exception an ActionError will be raised containing the error message. 233 234 Args: 235 message: The message to send 236 timeout: 237 The timeout in seconds to wait for the returned value. 238 Defaults to 3 seconds. 239 240 Returns: 241 object: The return value of the action. 242 243 Raises: 244 TimeoutError: If the timeout is reached 245 ActionError: If the action raised an exception 246 &quot;&quot;&quot; 247 if not self._is_processing: 248 raise RuntimeError( 249 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 250 251 # Set the message id 252 # Having a meta.request_id identifies it as a request 253 request_id = f&quot;request--{uuid.uuid4()}&quot; 254 message[&quot;meta&quot;] = message.get(&quot;meta&quot;, {}) 255 message[&quot;meta&quot;][&quot;request_id&quot;] = request_id 256 257 # Send and mark the request as pending 258 self.send(message) 259 pending = object() 260 with self._pending_responses_lock: 261 self._pending_responses[request_id] = pending 262 263 # Wait for response 264 start_time = time.time() 265 while self._pending_responses[request_id] == pending: 266 time.sleep(0.001) 267 if time.time() - start_time &gt; timeout: 268 raise TimeoutError 269 270 # Raise error or return value from response 271 with self._pending_responses_lock: 272 response_message = self._pending_responses.pop(request_id) 273 if &quot;error&quot; in response_message[&quot;action&quot;][&quot;args&quot;]: 274 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 275 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 276 277 def _receive(self, message: dict): 278 &quot;&quot;&quot; 279 Receives and handles an incoming message. 280 281 Args: 282 message: The incoming message 283 &quot;&quot;&quot; 284 # Ignore own broadcasts if _receive_own_broadcasts is false 285 if not self._receive_own_broadcasts \\ 286 and message[&#39;from&#39;] == self.id() \\ 287 and message[&#39;to&#39;] == &#39;*&#39;: 288 return 289 290 log(&quot;debug&quot;, f&quot;{self.id()} received message&quot;, message) 291 292 # Record the received message before handling 293 with self._message_log_lock: 294 self._message_log.append(message) 295 296 # Handle incoming responses 297 response_id = message.get(&quot;meta&quot;, {}).get(&quot;response_id&quot;) 298 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 299 if response_id in self._pending_responses.keys(): 300 # This was a response to a request() 301 self._pending_responses[response_id] = message 302 # From here the request() method will pick up the response in 303 # the existing thread 304 else: 305 # This was a response to a send() 306 if &quot;value&quot; in message[&quot;action&quot;][&quot;args&quot;]: 307 handler_callback = self.handle_action_value 308 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 309 elif &quot;error&quot; in message[&quot;action&quot;][&quot;args&quot;]: 310 handler_callback = self.handle_action_error 311 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 312 else: 313 raise RuntimeError(&quot;Unknown action response&quot;) 314 315 # Spawn a thread to handle the response 316 def __process_response(arg, current_message): 317 log(&quot;debug&quot;, f&quot;{self.id()} processing response&quot;, message) 318 self.__thread_local_current_message.value = current_message 319 handler_callback(arg) 320 321 threading.Thread( 322 target=__process_response, 323 args=(arg, message, ), 324 daemon=True, 325 ).start() 326 327 # Handle all other messages 328 else: 329 # Spawn a thread to process the message. This means that messages 330 # are processed concurrently, but may be processed out of order. 331 threading.Thread( 332 target=self.__process, args=(message,), daemon=True).start() 333 334 def __process(self, message: dict): 335 &quot;&quot;&quot; 336 Top level method within the action processing thread. 337 &quot;&quot;&quot; 338 log(&quot;debug&quot;, f&quot;{self.id()} processing message&quot;, message) 339 self.__thread_local_current_message.value = message 340 request_id = message.get(&quot;meta&quot;, {}).get(&quot;request_id&quot;) 341 response_id = request_id or message.get(&quot;meta&quot;, {}).get(&quot;id&quot;) 342 try: 343 # Commit the action 344 return_value = self.__commit(message) 345 346 # If the action returned a value or this was a request (which 347 # expects a value), return it 348 if request_id or return_value is not None: 349 self.send({ 350 &quot;meta&quot;: { 351 &quot;response_id&quot;: response_id 352 }, 353 &quot;to&quot;: message[&#39;from&#39;], 354 &quot;action&quot;: { 355 &quot;name&quot;: _RESPONSE_ACTION_NAME, 356 &quot;args&quot;: { 357 &quot;value&quot;: return_value, 358 } 359 } 360 }) 361 except Exception as e: 362 # Handle errors (including PermissionError) that occur while 363 # committing an action by reporting back to the sender. 364 log(&quot;debug&quot;, 365 f&quot;{self.id()} exception while committing action {message[&#39;action&#39;][&#39;name&#39;]}&quot;, e) 366 request_id = message.get(&quot;meta&quot;, {}).get(&quot;request_id&quot;) 367 self.send({ 368 &quot;meta&quot;: { 369 &quot;response_id&quot;: response_id 370 }, 371 &quot;to&quot;: message[&#39;from&#39;], 372 &quot;from&quot;: self.id(), 373 &quot;action&quot;: { 374 &quot;name&quot;: _RESPONSE_ACTION_NAME, 375 &quot;args&quot;: { 376 &quot;error&quot;: f&quot;{e.__class__.__name__}: {e}&quot; 377 } 378 } 379 }) 380 381 def __commit(self, message: dict): 382 &quot;&quot;&quot; 383 Invokes the action method 384 385 Args: 386 message: The incoming message specifying the action 387 388 Raises: 389 AttributeError: If the action method is not found 390 PermissionError: If the action is not permitted 391 &quot;&quot;&quot; 392 try: 393 # Check if the action method exists 394 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 395 except KeyError: 396 # the action was not found 397 if message[&#39;to&#39;] == &#39;*&#39;: 398 return # broadcasts will not raise an error in this situation 399 else: 400 raise AttributeError( 401 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 402 403 # Check if the action is permitted 404 if not self.__permitted(message): 405 raise PermissionError( 406 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 407 408 self.before_action(message) 409 410 return_value = None 411 error = None 412 try: 413 # Invoke the action method 414 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 415 except Exception as e: 416 error = e 417 raise 418 finally: 419 self.after_action(message, return_value, error) 420 return return_value 421 422 def __permitted(self, message: dict) -&gt; bool: 423 &quot;&quot;&quot; 424 Checks whether the message&#39;s action is allowed 425 &quot;&quot;&quot; 426 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 427 policy = action_method.action_properties[&quot;access_policy&quot;] 428 if policy == ACCESS_PERMITTED: 429 return True 430 elif policy == ACCESS_DENIED: 431 return False 432 elif policy == ACCESS_REQUESTED: 433 return self.request_permission(message) 434 else: 435 raise Exception( 436 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 437 438 def __action_methods(self) -&gt; dict: 439 instance_methods = inspect.getmembers(self, inspect.ismethod) 440 action_methods = { 441 method_name: method 442 for method_name, method in instance_methods 443 if hasattr(method, &quot;action_properties&quot;) 444 } 445 return action_methods 446 447 def __action_method(self, action_name: str): 448 &quot;&quot;&quot; 449 Returns the method for the given action name. 450 &quot;&quot;&quot; 451 action_methods = self.__action_methods() 452 return action_methods[action_name] 453 454 def current_message(self) -&gt; Message: 455 &quot;&quot;&quot; 456 Returns the full message which invoked the current action. 457 458 This method may be called within an action to retrieve the current 459 message, for example to determine the sender or inspect other details. 460 461 Returns: 462 The current message 463 &quot;&quot;&quot; 464 return self.__thread_local_current_message.value 465 466 def original_message(self) -&gt; Message: 467 &quot;&quot;&quot; 468 Returns the original message that the current message is responding to. 469 470 This method may be called during the handle_action_value() and 471 handle_action_error() callbacks to inspect the original message. 472 473 The original message must define the meta.id field for this method to 474 return it. Otherwise, this method will return None. 475 476 Returns: 477 The original message or None 478 &quot;&quot;&quot; 479 current_message = self.__thread_local_current_message.value 480 original_message_id = current_message.get(&quot;meta&quot;, {}).get(&quot;id&quot;) 481 if original_message_id: 482 original_message = None 483 for message in self._message_log: 484 if message[&quot;meta&quot;][&quot;id&quot;] == original_message_id: 485 original_message = message 486 break 487 return original_message 488 489 @action 490 def help(self, action_name: str = None) -&gt; dict: 491 &quot;&quot;&quot; 492 Returns a list of actions on this agent. 493 494 If action_name is passed, returns a list with only that action. 495 If no action_name is passed, returns all actions. 496 497 Args: 498 action_name: (Optional) The name of an action to request help for 499 500 Returns: 501 A dictionary of actions 502 &quot;&quot;&quot; 503 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME] 504 help_list = { 505 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 506 for method in self.__action_methods().values() 507 if action_name is None 508 and method.action_properties[&quot;name&quot;] not in special_actions 509 or method.action_properties[&quot;name&quot;] == action_name 510 } 511 return help_list 512 513 def handle_action_value(self, value): 514 &quot;&quot;&quot; 515 Receives a return value from a previous action. 516 517 This method receives return values from actions invoked by the send() 518 method. It is not called when using the request() method, which returns 519 the value directly. 520 521 To inspect the full response message, use current_message(). 522 523 To inspect the original message, use original_message(). Note that the 524 original message must define the meta.id field or original_message() 525 will return None. 526 527 Args: 528 value: 529 The return value 530 &quot;&quot;&quot; 531 log(&quot;warning&quot;, 532 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 533 534 def handle_action_error(self, error: ActionError): 535 &quot;&quot;&quot; 536 Receives an error from a previous action. 537 538 This method receives errors from actions invoked by the send() method. 539 It is not called when using the request() method, which raises an error 540 directly. 541 542 To inspect the full response message, use current_message(). 543 544 To inspect the original message, use original_message(). Note that the 545 original message must define the meta.id field or original_message() 546 will return None. 547 548 Args: 549 error: The error 550 &quot;&quot;&quot; 551 log(&quot;warning&quot;, 552 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 553 554 def after_add(self): 555 &quot;&quot;&quot; 556 Called after the agent is added to a space, but before it begins 557 processing incoming messages. 558 559 The agent may send messages during this callback using the send() 560 method, but may not use the request() method since it relies on 561 processing incoming messages. 562 &quot;&quot;&quot; 563 564 def before_remove(self): 565 &quot;&quot;&quot; 566 Called before the agent is removed from a space, after it has finished 567 processing incoming messages. 568 569 The agent may send final messages during this callback using the send() 570 method, but may not use the request() method since it relies on 571 processing incoming messages. 572 &quot;&quot;&quot; 573 574 def before_action(self, message: dict): 575 &quot;&quot;&quot; 576 Called before every action. 577 578 This method will only be called if the action exists and is permitted. 579 580 Args: 581 message: The received message that contains the action 582 &quot;&quot;&quot; 583 584 def after_action(self, message: dict, return_value: str, error: str): 585 &quot;&quot;&quot; 586 Called after every action, regardless of whether an error occurred. 587 588 Args: 589 message: The message which invoked the action 590 return_value: The return value from the action 591 error: The error from the action if any 592 &quot;&quot;&quot; 593 594 def request_permission(self, proposed_message: dict) -&gt; bool: 595 &quot;&quot;&quot; 596 Receives a proposed action message and presents it to the agent for 597 review. 598 599 Args: 600 proposed_message: The proposed action message 601 602 Returns: 603 True if access should be permitted 604 &quot;&quot;&quot; 605 raise NotImplementedError( 606 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . An Actor that may represent an AI agent, computing system, or human user . Agent( id: str, outbound_queue: agency.agent._QueueProtocol, receive_own_broadcasts: bool = True) View Source 171 def __init__(self, 172 id: str, 173 outbound_queue: _QueueProtocol, 174 receive_own_broadcasts: bool = True): 175 &quot;&quot;&quot; 176 Initializes an Agent. 177 178 This constructor is not meant to be called directly. It is invoked by 179 the Space class when adding an agent. 180 181 Subclasses should call super().__init__() in their constructor. 182 183 Args: 184 id: The id of the agent 185 outbound_queue: The outgoing queue for sending messages 186 receive_own_broadcasts: 187 Whether the agent will receive its own broadcasts. Defaults to 188 True 189 &quot;&quot;&quot; 190 if len(id) &lt; 1 or len(id) &gt; 255: 191 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 192 if re.match(r&quot;^amq\\.&quot;, id): 193 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 194 if id == &quot;*&quot;: 195 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 196 if outbound_queue is None: 197 raise ValueError(&quot;outbound_queue must be provided&quot;) 198 self._id: str = id 199 self._outbound_queue: _QueueProtocol = outbound_queue 200 self._receive_own_broadcasts: bool = receive_own_broadcasts 201 self._is_processing: bool = False # set by the Space 202 self._message_log: List[Message] = [] 203 self._message_log_lock = threading.Lock() 204 self._pending_responses: Dict[str, Message] = {} 205 self._pending_responses_lock = threading.Lock() 206 self.__thread_local_current_message = threading.local() 207 self.__thread_local_current_message.value: Message = None . Initializes an Agent. This constructor is not meant to be called directly. It is invoked by the Space class when adding an agent. Subclasses should call super().__init__() in their constructor. Arguments: . | id: The id of the agent | outbound_queue: The outgoing queue for sending messages | receive_own_broadcasts: Whether the agent will receive its own broadcasts. Defaults to True | . def id(self) -> str: View Source 209 def id(self) -&gt; str: 210 return self._id . def send(self, message: dict): View Source 212 def send(self, message: dict): 213 &quot;&quot;&quot; 214 Sends (out) a message from this agent. 215 216 Args: 217 message: The message 218 &quot;&quot;&quot; 219 log(&quot;info&quot;, f&quot;{self.id()} sending message&quot;, message) 220 message[&quot;from&quot;] = self.id() 221 with self._message_log_lock: 222 self._message_log.append(message) 223 self._outbound_queue.put(message) . Sends (out) a message from this agent. Arguments: . | message: The message | . def request(self, message: dict, timeout: float = 3) -> object: View Source 225 def request(self, message: dict, timeout: float = 3) -&gt; object: 226 &quot;&quot;&quot; 227 Synchronously sends a message then waits for and returns the return 228 value of the invoked action. 229 230 This method allows you to call an action synchronously like a function 231 and receive its return value in python. If the action raises an 232 exception an ActionError will be raised containing the error message. 233 234 Args: 235 message: The message to send 236 timeout: 237 The timeout in seconds to wait for the returned value. 238 Defaults to 3 seconds. 239 240 Returns: 241 object: The return value of the action. 242 243 Raises: 244 TimeoutError: If the timeout is reached 245 ActionError: If the action raised an exception 246 &quot;&quot;&quot; 247 if not self._is_processing: 248 raise RuntimeError( 249 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 250 251 # Set the message id 252 # Having a meta.request_id identifies it as a request 253 request_id = f&quot;request--{uuid.uuid4()}&quot; 254 message[&quot;meta&quot;] = message.get(&quot;meta&quot;, {}) 255 message[&quot;meta&quot;][&quot;request_id&quot;] = request_id 256 257 # Send and mark the request as pending 258 self.send(message) 259 pending = object() 260 with self._pending_responses_lock: 261 self._pending_responses[request_id] = pending 262 263 # Wait for response 264 start_time = time.time() 265 while self._pending_responses[request_id] == pending: 266 time.sleep(0.001) 267 if time.time() - start_time &gt; timeout: 268 raise TimeoutError 269 270 # Raise error or return value from response 271 with self._pending_responses_lock: 272 response_message = self._pending_responses.pop(request_id) 273 if &quot;error&quot; in response_message[&quot;action&quot;][&quot;args&quot;]: 274 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 275 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] . Synchronously sends a message then waits for and returns the return value of the invoked action. This method allows you to call an action synchronously like a function and receive its return value in python. If the action raises an exception an ActionError will be raised containing the error message. Arguments: . | message: The message to send | timeout: The timeout in seconds to wait for the returned value. Defaults to 3 seconds. | . Returns: . object: The return value of the action. Raises: . | TimeoutError: If the timeout is reached | ActionError: If the action raised an exception | . def current_message(self) -> agency.schema.Message: View Source 454 def current_message(self) -&gt; Message: 455 &quot;&quot;&quot; 456 Returns the full message which invoked the current action. 457 458 This method may be called within an action to retrieve the current 459 message, for example to determine the sender or inspect other details. 460 461 Returns: 462 The current message 463 &quot;&quot;&quot; 464 return self.__thread_local_current_message.value . Returns the full message which invoked the current action. This method may be called within an action to retrieve the current message, for example to determine the sender or inspect other details. Returns: . The current message . def original_message(self) -> agency.schema.Message: View Source 466 def original_message(self) -&gt; Message: 467 &quot;&quot;&quot; 468 Returns the original message that the current message is responding to. 469 470 This method may be called during the handle_action_value() and 471 handle_action_error() callbacks to inspect the original message. 472 473 The original message must define the meta.id field for this method to 474 return it. Otherwise, this method will return None. 475 476 Returns: 477 The original message or None 478 &quot;&quot;&quot; 479 current_message = self.__thread_local_current_message.value 480 original_message_id = current_message.get(&quot;meta&quot;, {}).get(&quot;id&quot;) 481 if original_message_id: 482 original_message = None 483 for message in self._message_log: 484 if message[&quot;meta&quot;][&quot;id&quot;] == original_message_id: 485 original_message = message 486 break 487 return original_message . Returns the original message that the current message is responding to. This method may be called during the handle_action_value() and handle_action_error() callbacks to inspect the original message. The original message must define the meta.id field for this method to return it. Otherwise, this method will return None. Returns: . The original message or None . @action def help(self, action_name: str = None) -> dict: View Source 489 @action 490 def help(self, action_name: str = None) -&gt; dict: 491 &quot;&quot;&quot; 492 Returns a list of actions on this agent. 493 494 If action_name is passed, returns a list with only that action. 495 If no action_name is passed, returns all actions. 496 497 Args: 498 action_name: (Optional) The name of an action to request help for 499 500 Returns: 501 A dictionary of actions 502 &quot;&quot;&quot; 503 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME] 504 help_list = { 505 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 506 for method in self.__action_methods().values() 507 if action_name is None 508 and method.action_properties[&quot;name&quot;] not in special_actions 509 or method.action_properties[&quot;name&quot;] == action_name 510 } 511 return help_list . Returns a list of actions on this agent. If action_name is passed, returns a list with only that action. If no action_name is passed, returns all actions. Arguments: . | action_name: (Optional) The name of an action to request help for | . Returns: . A dictionary of actions . def handle_action_value(self, value): View Source 513 def handle_action_value(self, value): 514 &quot;&quot;&quot; 515 Receives a return value from a previous action. 516 517 This method receives return values from actions invoked by the send() 518 method. It is not called when using the request() method, which returns 519 the value directly. 520 521 To inspect the full response message, use current_message(). 522 523 To inspect the original message, use original_message(). Note that the 524 original message must define the meta.id field or original_message() 525 will return None. 526 527 Args: 528 value: 529 The return value 530 &quot;&quot;&quot; 531 log(&quot;warning&quot;, 532 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) . Receives a return value from a previous action. This method receives return values from actions invoked by the send() method. It is not called when using the request() method, which returns the value directly. To inspect the full response message, use current_message(). To inspect the original message, use original_message(). Note that the original message must define the meta.id field or original_message() will return None. Arguments: . | value: The return value | . def handle_action_error(self, error: agency.agent.ActionError): View Source 534 def handle_action_error(self, error: ActionError): 535 &quot;&quot;&quot; 536 Receives an error from a previous action. 537 538 This method receives errors from actions invoked by the send() method. 539 It is not called when using the request() method, which raises an error 540 directly. 541 542 To inspect the full response message, use current_message(). 543 544 To inspect the original message, use original_message(). Note that the 545 original message must define the meta.id field or original_message() 546 will return None. 547 548 Args: 549 error: The error 550 &quot;&quot;&quot; 551 log(&quot;warning&quot;, 552 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) . Receives an error from a previous action. This method receives errors from actions invoked by the send() method. It is not called when using the request() method, which raises an error directly. To inspect the full response message, use current_message(). To inspect the original message, use original_message(). Note that the original message must define the meta.id field or original_message() will return None. Arguments: . | error: The error | . def after_add(self): View Source 554 def after_add(self): 555 &quot;&quot;&quot; 556 Called after the agent is added to a space, but before it begins 557 processing incoming messages. 558 559 The agent may send messages during this callback using the send() 560 method, but may not use the request() method since it relies on 561 processing incoming messages. 562 &quot;&quot;&quot; . Called after the agent is added to a space, but before it begins processing incoming messages. The agent may send messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_remove(self): View Source 564 def before_remove(self): 565 &quot;&quot;&quot; 566 Called before the agent is removed from a space, after it has finished 567 processing incoming messages. 568 569 The agent may send final messages during this callback using the send() 570 method, but may not use the request() method since it relies on 571 processing incoming messages. 572 &quot;&quot;&quot; . Called before the agent is removed from a space, after it has finished processing incoming messages. The agent may send final messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_action(self, message: dict): View Source 574 def before_action(self, message: dict): 575 &quot;&quot;&quot; 576 Called before every action. 577 578 This method will only be called if the action exists and is permitted. 579 580 Args: 581 message: The received message that contains the action 582 &quot;&quot;&quot; . Called before every action. This method will only be called if the action exists and is permitted. Arguments: . | message: The received message that contains the action | . def after_action(self, message: dict, return_value: str, error: str): View Source 584 def after_action(self, message: dict, return_value: str, error: str): 585 &quot;&quot;&quot; 586 Called after every action, regardless of whether an error occurred. 587 588 Args: 589 message: The message which invoked the action 590 return_value: The return value from the action 591 error: The error from the action if any 592 &quot;&quot;&quot; . Called after every action, regardless of whether an error occurred. Arguments: . | message: The message which invoked the action | return_value: The return value from the action | error: The error from the action if any | . def request_permission(self, proposed_message: dict) -> bool: View Source 594 def request_permission(self, proposed_message: dict) -&gt; bool: 595 &quot;&quot;&quot; 596 Receives a proposed action message and presents it to the agent for 597 review. 598 599 Args: 600 proposed_message: The proposed action message 601 602 Returns: 603 True if access should be permitted 604 &quot;&quot;&quot; 605 raise NotImplementedError( 606 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . Receives a proposed action message and presents it to the agent for review. Arguments: . | proposed_message: The proposed action message | . Returns: . True if access should be permitted . ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"24": {
    "doc": "agency.agent",
    "title": "agency.agent",
    "content": " ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"25": {
    "doc": "agency.logger",
    "title": "\nagency.logger    ",
    "content": "View Source 1import json 2import logging 3import os 4import traceback 5 6 7_LOGLEVELS = { 8 &#39;CRITICAL&#39;: 50, 9 &#39;ERROR&#39;: 40, 10 &#39;WARNING&#39;: 30, 11 &#39;INFO&#39;: 20, 12 &#39;DEBUG&#39;: 10, 13 &#39;NOTSET&#39;: 0 14} 15 16_env_loglevel = os.environ.get(&#39;LOGLEVEL&#39;, &#39;WARNING&#39;).upper() 17_LOGLEVEL = _LOGLEVELS[_env_loglevel] 18_LOGFORMAT = &#39;%(asctime)s - %(levelname)s - %(message)s&#39; 19 20# Initialize the logger 21_logger = logging.getLogger(&quot;agency&quot;) 22_logger.setLevel(_LOGLEVEL) 23_handler = logging.StreamHandler() 24_handler.setLevel(_LOGLEVEL) 25_formatter = logging.Formatter(_LOGFORMAT) 26_handler.setFormatter(_formatter) 27_logger.addHandler(_handler) 28 29 30class _CustomEncoder(json.JSONEncoder): 31 def default(self, obj): 32 try: 33 return super().default(obj) 34 except TypeError: 35 return str(obj) 36 37 38def log(level: str, message: str, object: object = None): 39 &quot;&quot;&quot; 40 Logs a message at the specified level 41 42 If the object argument is provided, it will be pretty printed after the 43 message. 44 45 Args: 46 level: The log level 47 message: The message 48 object: An optional object to pretty print 49 &quot;&quot;&quot; 50 pretty_object: str = None 51 if object != None: 52 try: 53 if isinstance(object, Exception): 54 # Print the traceback on exceptions 55 pretty_object = &quot;&quot;.join(traceback.format_exception( 56 etype=type(object), value=object, tb=object.__traceback__)) 57 else: 58 # Try to json dumps it 59 pretty_object = json.dumps( 60 object, indent=2, cls=_CustomEncoder) 61 except: 62 pass 63 64 if pretty_object != None: 65 message = f&quot;{message}\\n{pretty_object}&quot; 66 67 numeric_level = _LOGLEVELS.get(level.upper()) 68 if numeric_level is not None: 69 _logger.log(numeric_level, message) 70 else: 71 raise ValueError(f&quot;Invalid log level: {level}&quot;) . def log(level: str, message: str, object: object = None): View Source 39def log(level: str, message: str, object: object = None): 40 &quot;&quot;&quot; 41 Logs a message at the specified level 42 43 If the object argument is provided, it will be pretty printed after the 44 message. 45 46 Args: 47 level: The log level 48 message: The message 49 object: An optional object to pretty print 50 &quot;&quot;&quot; 51 pretty_object: str = None 52 if object != None: 53 try: 54 if isinstance(object, Exception): 55 # Print the traceback on exceptions 56 pretty_object = &quot;&quot;.join(traceback.format_exception( 57 etype=type(object), value=object, tb=object.__traceback__)) 58 else: 59 # Try to json dumps it 60 pretty_object = json.dumps( 61 object, indent=2, cls=_CustomEncoder) 62 except: 63 pass 64 65 if pretty_object != None: 66 message = f&quot;{message}\\n{pretty_object}&quot; 67 68 numeric_level = _LOGLEVELS.get(level.upper()) 69 if numeric_level is not None: 70 _logger.log(numeric_level, message) 71 else: 72 raise ValueError(f&quot;Invalid log level: {level}&quot;) . Logs a message at the specified level . If the object argument is provided, it will be pretty printed after the message. Arguments: . | level: The log level | message: The message | object: An optional object to pretty print | . ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"26": {
    "doc": "agency.logger",
    "title": "agency.logger",
    "content": " ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"27": {
    "doc": "agency.schema",
    "title": "\nagency.schema    ",
    "content": "View Source 1from pydantic import BaseModel, Field 2from typing import Dict, Optional 3 4 5class Action(BaseModel): 6 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 7 8 class Config: 9 extra = &quot;forbid&quot; 10 validate_assignment = True 11 12 name: str = Field( 13 ..., 14 description=&quot;The name of the action.&quot; 15 ) 16 17 args: Optional[Dict] = Field( 18 None, 19 description=&quot;The arguments for the action.&quot; 20 ) 21 22 23class Message(BaseModel): 24 &quot;&quot;&quot;Schema for a message&quot;&quot;&quot; 25 26 class Config: 27 extra = &quot;forbid&quot; 28 validate_assignment = True 29 30 meta: Optional[Dict] = Field( 31 None, 32 description=&quot;An optional dictionary field for storing metadata about the message.&quot; 33 ) 34 35 to: str = Field( 36 ..., 37 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 38 ) 39 40 from_: str = Field( 41 ..., 42 alias=&#39;from&#39;, 43 description=&quot;The id of the sender.&quot; 44 ) 45 46 action: Action 47 48 49def validate_message(message: Message) -&gt; Message: 50 &quot;&quot;&quot; 51 Validate and return a message 52 53 Args: 54 message: The message 55 56 Returns: 57 The validated message 58 59 Raises: 60 ValueError: If the message is invalid 61 &quot;&quot;&quot; 62 try: 63 return Message(**message).dict(by_alias=True, exclude_unset=True) 64 except TypeError as e: 65 raise ValueError(str(e)) . class Action(pydantic.main.BaseModel): View Source 6class Action(BaseModel): 7 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 8 9 class Config: 10 extra = &quot;forbid&quot; 11 validate_assignment = True 12 13 name: str = Field( 14 ..., 15 description=&quot;The name of the action.&quot; 16 ) 17 18 args: Optional[Dict] = Field( 19 None, 20 description=&quot;The arguments for the action.&quot; 21 ) . Schema for an action . name: str args: Optional[Dict] Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Action.Config: View Source 9 class Config: 10 extra = &quot;forbid&quot; 11 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True class Message(pydantic.main.BaseModel): View Source 24class Message(BaseModel): 25 &quot;&quot;&quot;Schema for a message&quot;&quot;&quot; 26 27 class Config: 28 extra = &quot;forbid&quot; 29 validate_assignment = True 30 31 meta: Optional[Dict] = Field( 32 None, 33 description=&quot;An optional dictionary field for storing metadata about the message.&quot; 34 ) 35 36 to: str = Field( 37 ..., 38 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 39 ) 40 41 from_: str = Field( 42 ..., 43 alias=&#39;from&#39;, 44 description=&quot;The id of the sender.&quot; 45 ) 46 47 action: Action . Schema for a message . meta: Optional[Dict] to: str from_: str action: agency.schema.Action Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Message.Config: View Source 27 class Config: 28 extra = &quot;forbid&quot; 29 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True def validate_message(message: agency.schema.Message) -> agency.schema.Message: View Source 50def validate_message(message: Message) -&gt; Message: 51 &quot;&quot;&quot; 52 Validate and return a message 53 54 Args: 55 message: The message 56 57 Returns: 58 The validated message 59 60 Raises: 61 ValueError: If the message is invalid 62 &quot;&quot;&quot; 63 try: 64 return Message(**message).dict(by_alias=True, exclude_unset=True) 65 except TypeError as e: 66 raise ValueError(str(e)) . Validate and return a message . Arguments: . | message: The message | . Returns: . The validated message . Raises: . | ValueError: If the message is invalid | . ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"28": {
    "doc": "agency.schema",
    "title": "agency.schema",
    "content": " ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"29": {
    "doc": "agency.space",
    "title": "\nagency.space    ",
    "content": "View Source 1from abc import ABC, ABCMeta, abstractmethod 2from typing import Type 3from agency.agent import Agent 4 5 6class Space(ABC, metaclass=ABCMeta): 7 &quot;&quot;&quot; 8 Space implementations are responsible for 9 - Managing the lifecycle of agent instances 10 - Ensuring communication between agents 11 &quot;&quot;&quot; 12 13 @abstractmethod 14 def add(self, agent_type: Type[Agent], agent_id: str, **kwargs): 15 &quot;&quot;&quot; 16 Adds an agent to the space allowing it to communicate. 17 18 Keyword arguments are passed to the agent&#39;s constructor. 19 20 Args: 21 agent_type: The type of agent to add 22 agent_id: The id of the agent to add 23 24 Raises: 25 ValueError: If the agent ID is already in use 26 &quot;&quot;&quot; 27 28 @abstractmethod 29 def remove(self, agent_id: str): 30 &quot;&quot;&quot; 31 Removes an agent from the space by id. 32 33 This method cannot remove an agent instance added from a different space 34 instance. In other words, a space instance cannot remove an agent that 35 it did not add. 36 37 Args: 38 agent_id: The id of the agent to remove 39 40 Raises: 41 ValueError: If the agent is not present in the space 42 &quot;&quot;&quot; 43 44 @abstractmethod 45 def remove_all(self): 46 &quot;&quot;&quot; 47 Removes all agents added through this space instance. 48 &quot;&quot;&quot; . class Space(abc.ABC): View Source 7class Space(ABC, metaclass=ABCMeta): 8 &quot;&quot;&quot; 9 Space implementations are responsible for 10 - Managing the lifecycle of agent instances 11 - Ensuring communication between agents 12 &quot;&quot;&quot; 13 14 @abstractmethod 15 def add(self, agent_type: Type[Agent], agent_id: str, **kwargs): 16 &quot;&quot;&quot; 17 Adds an agent to the space allowing it to communicate. 18 19 Keyword arguments are passed to the agent&#39;s constructor. 20 21 Args: 22 agent_type: The type of agent to add 23 agent_id: The id of the agent to add 24 25 Raises: 26 ValueError: If the agent ID is already in use 27 &quot;&quot;&quot; 28 29 @abstractmethod 30 def remove(self, agent_id: str): 31 &quot;&quot;&quot; 32 Removes an agent from the space by id. 33 34 This method cannot remove an agent instance added from a different space 35 instance. In other words, a space instance cannot remove an agent that 36 it did not add. 37 38 Args: 39 agent_id: The id of the agent to remove 40 41 Raises: 42 ValueError: If the agent is not present in the space 43 &quot;&quot;&quot; 44 45 @abstractmethod 46 def remove_all(self): 47 &quot;&quot;&quot; 48 Removes all agents added through this space instance. 49 &quot;&quot;&quot; . Space implementations are responsible for . | Managing the lifecycle of agent instances | Ensuring communication between agents | . @abstractmethod def add(self, agent_type: Type[agency.agent.Agent], agent_id: str, **kwargs): View Source 14 @abstractmethod 15 def add(self, agent_type: Type[Agent], agent_id: str, **kwargs): 16 &quot;&quot;&quot; 17 Adds an agent to the space allowing it to communicate. 18 19 Keyword arguments are passed to the agent&#39;s constructor. 20 21 Args: 22 agent_type: The type of agent to add 23 agent_id: The id of the agent to add 24 25 Raises: 26 ValueError: If the agent ID is already in use 27 &quot;&quot;&quot; . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . @abstractmethod def remove(self, agent_id: str): View Source 29 @abstractmethod 30 def remove(self, agent_id: str): 31 &quot;&quot;&quot; 32 Removes an agent from the space by id. 33 34 This method cannot remove an agent instance added from a different space 35 instance. In other words, a space instance cannot remove an agent that 36 it did not add. 37 38 Args: 39 agent_id: The id of the agent to remove 40 41 Raises: 42 ValueError: If the agent is not present in the space 43 &quot;&quot;&quot; . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . @abstractmethod def remove_all(self): View Source 45 @abstractmethod 46 def remove_all(self): 47 &quot;&quot;&quot; 48 Removes all agents added through this space instance. 49 &quot;&quot;&quot; . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"30": {
    "doc": "agency.space",
    "title": "agency.space",
    "content": " ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"31": {
    "doc": "agency.spaces",
    "title": "\nagency.spaces    ",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"32": {
    "doc": "agency.spaces",
    "title": "Submodules",
    "content": ". | amqp_space | multiprocess_space | thread_space | . ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"33": {
    "doc": "agency.spaces",
    "title": "agency.spaces",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"34": {
    "doc": "agency.spaces.amqp_space",
    "title": "\nagency.spaces.amqp_space    ",
    "content": "View Source 1import json 2import multiprocessing 3import os 4import queue 5import socket 6import threading 7import time 8from dataclasses import dataclass 9from multiprocessing import Event, Process 10import traceback 11from typing import Dict, Type 12 13import amqp 14from kombu import Connection, Queue 15 16from agency.agent import Agent 17from agency.logger import log 18from agency.schema import Message, validate_message 19from agency.space import Space 20 21 22class _AgentAMQPProcess(): 23 def __init__( 24 self, 25 agent_type: Type[Agent], 26 agent_id: str, 27 agent_kwargs: Dict, 28 kombu_connection_options: Dict, 29 exchange_name: str, 30 outbound_queue: multiprocessing.Queue, 31 ): 32 self.agent_type: Type[Agent] = agent_type 33 self.agent_id: str = agent_id 34 self.agent_kwargs: Dict = agent_kwargs 35 self.kombu_connection_options: Dict = kombu_connection_options 36 self.exchange_name: str = exchange_name 37 self.outbound_queue: multiprocessing.Queue = outbound_queue 38 39 def start(self): 40 self.__started = Event() 41 self.__stopping = Event() 42 error_queue = multiprocessing.Queue() 43 self.__process = Process( 44 target=self._process, 45 args=( 46 self.agent_type, 47 self.agent_id, 48 self.agent_kwargs, 49 self.kombu_connection_options, 50 self.exchange_name, 51 self.outbound_queue, 52 self.__started, 53 self.__stopping, 54 error_queue, 55 ) 56 ) 57 self.__process.start() 58 59 if not self.__started.wait(timeout=10): 60 self.stop() 61 try: 62 error = error_queue.get(block=False) 63 raise error 64 except queue.Empty: 65 raise Exception(&quot;Process could not be started.&quot;) 66 67 def stop(self): 68 self.__stopping.set() 69 if self.__process.is_alive(): 70 self.__process.join(timeout=10) 71 if self.__process.is_alive(): 72 raise Exception(&quot;Process could not be stopped.&quot;) 73 74 def _process(self, 75 agent_type, 76 agent_id, 77 agent_kwargs, 78 kombu_connection_options, 79 exchange_name, 80 outbound_queue, 81 started, 82 stopping, 83 error_queue): 84 85 try: 86 # Create a connection 87 connection = Connection(**kombu_connection_options) 88 connection.connect() 89 if not connection.connected: 90 raise ConnectionError(&quot;Unable to connect to AMQP server&quot;) 91 92 # Create a queue for direct messages 93 direct_queue = Queue( 94 f&quot;{agent_id}-direct&quot;, 95 exchange=exchange_name, 96 routing_key=agent_id, 97 exclusive=True, 98 ) 99 direct_queue(connection.channel()).declare() 100 101 # Create a separate broadcast queue 102 broadcast_queue = Queue( 103 f&quot;{agent_id}-broadcast&quot;, 104 exchange=exchange_name, 105 routing_key=AMQPSpace._BROADCAST_KEY, 106 exclusive=True, 107 ) 108 broadcast_queue(connection.channel()).declare() 109 110 # Define callback for incoming messages 111 def _on_message(body, message): 112 message.ack() 113 message_data = json.loads(body) 114 if message_data[&#39;to&#39;] == &#39;*&#39; or message_data[&#39;to&#39;] == agent.id(): 115 agent._receive(message_data) 116 117 # Consume from direct and broadcast queues 118 consumer = connection.Consumer( 119 [direct_queue, broadcast_queue], 120 callbacks=[_on_message], 121 ) 122 123 # Start the consumer 124 consumer.consume() 125 126 # Create agent 127 agent: Agent = agent_type( 128 agent_id, 129 outbound_queue=outbound_queue, 130 **agent_kwargs, 131 ) 132 133 # Start loop 134 agent.after_add() 135 log(&quot;info&quot;, f&quot;{agent.id()} added to space&quot;) 136 agent._is_processing = True 137 started.set() 138 while not stopping.is_set(): 139 time.sleep(0.001) 140 connection.heartbeat_check() # sends heartbeat if necessary 141 try: 142 connection.drain_events(timeout=0.001) 143 except socket.timeout: 144 pass 145 except amqp.exceptions.ResourceLocked: 146 error_queue.put( 147 ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;)) 148 except KeyboardInterrupt: 149 pass 150 except Exception as e: 151 log(&quot;error&quot;, f&quot;{agent_id} process failed with exception&quot;, traceback.format_exc()) 152 error_queue.put(e) 153 finally: 154 agent._is_processing = False 155 agent.before_remove() 156 connection.release() 157 log(&quot;info&quot;, f&quot;{agent.id()} removed from space&quot;) 158 159 160@dataclass 161class AMQPOptions: 162 &quot;&quot;&quot; 163 A class that defines AMQP connection options 164 &quot;&quot;&quot; 165 hostname: str = &#39;localhost&#39; 166 port: int = &#39;5672&#39; 167 username: str = &#39;guest&#39; 168 password: str = &#39;guest&#39; 169 virtual_host: str = &#39;/&#39; 170 use_ssl: bool = False 171 heartbeat: float = 60 172 173 174class AMQPSpace(Space): 175 &quot;&quot;&quot; 176 A Space that uses AMQP for message delivery. 177 178 This Space type is useful for distributing agents across multiple hosts. 179 180 AMQPSpace uses multiprocessing for parallelism when multiple agents are 181 added to the same instance. 182 &quot;&quot;&quot; 183 184 _BROADCAST_KEY = &quot;__broadcast__&quot; 185 186 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 187 if amqp_options is None: 188 amqp_options = self.__default_amqp_options() 189 self.__kombu_connection_options = { 190 &#39;hostname&#39;: amqp_options.hostname, 191 &#39;port&#39;: amqp_options.port, 192 &#39;userid&#39;: amqp_options.username, 193 &#39;password&#39;: amqp_options.password, 194 &#39;virtual_host&#39;: amqp_options.virtual_host, 195 &#39;ssl&#39;: amqp_options.use_ssl, 196 &#39;heartbeat&#39;: amqp_options.heartbeat, 197 } 198 self.__exchange_name: str = exchange_name 199 self.__agent_processes: Dict[str, _AgentAMQPProcess] = {} 200 router_thread = threading.Thread( 201 target=self.__router_thread, daemon=True) 202 router_thread.start() 203 204 def __router_thread(self): 205 &quot;&quot;&quot;Processes and routes outbound messages for all agents&quot;&quot;&quot; 206 while True: 207 time.sleep(0.001) 208 for agent_process in list(self.__agent_processes.values()): 209 outbound_queue = agent_process.outbound_queue 210 try: 211 # process one message per agent per loop 212 message = outbound_queue.get(block=False) 213 self._route(message) 214 except queue.Empty: 215 pass 216 217 def _route(self, message: Message): 218 message = validate_message(message) 219 220 if message[&#39;to&#39;] == &#39;*&#39;: 221 # broadcast 222 routing_key = self._BROADCAST_KEY 223 else: 224 # point to point 225 routing_key = message[&#39;to&#39;] 226 227 with Connection(**self.__kombu_connection_options) as connection: 228 with connection.Producer(serializer=&quot;json&quot;) as producer: 229 producer.publish( 230 json.dumps(message), 231 exchange=self.__exchange_name, 232 routing_key=routing_key) 233 234 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 235 try: 236 self.__agent_processes[agent_id] = _AgentAMQPProcess( 237 agent_type=agent_type, 238 agent_id=agent_id, 239 agent_kwargs=agent_kwargs, 240 kombu_connection_options=self.__kombu_connection_options, 241 exchange_name=self.__exchange_name, 242 outbound_queue=multiprocessing.Queue(), 243 ) 244 self.__agent_processes[agent_id].start() 245 246 except: 247 # clean up if an error occurs 248 self.remove(agent_id) 249 raise 250 251 def remove(self, agent_id: str): 252 agent_process = self.__agent_processes[agent_id] 253 agent_process.stop() 254 del self.__agent_processes[agent_id] 255 256 def remove_all(self): 257 agent_ids = list(self.__agent_processes.keys()) 258 for agent_id in agent_ids: 259 self.remove(agent_id) 260 261 def __default_amqp_options(self) -&gt; AMQPOptions: 262 &quot;&quot;&quot; 263 Returns a default AMQPOptions object configurable from environment 264 variables. 265 &quot;&quot;&quot; 266 return AMQPOptions( 267 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 268 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 269 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 270 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 271 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 272 use_ssl=False, 273 heartbeat=60, 274 ) . @dataclass class AMQPOptions: View Source 161@dataclass 162class AMQPOptions: 163 &quot;&quot;&quot; 164 A class that defines AMQP connection options 165 &quot;&quot;&quot; 166 hostname: str = &#39;localhost&#39; 167 port: int = &#39;5672&#39; 168 username: str = &#39;guest&#39; 169 password: str = &#39;guest&#39; 170 virtual_host: str = &#39;/&#39; 171 use_ssl: bool = False 172 heartbeat: float = 60 . A class that defines AMQP connection options . AMQPOptions( hostname: str = &#39;localhost&#39;, port: int = &#39;5672&#39;, username: str = &#39;guest&#39;, password: str = &#39;guest&#39;, virtual_host: str = &#39;/&#39;, use_ssl: bool = False, heartbeat: float = 60) hostname: str = &#39;localhost&#39; port: int = &#39;5672&#39; username: str = &#39;guest&#39; password: str = &#39;guest&#39; virtual_host: str = &#39;/&#39; use_ssl: bool = False heartbeat: float = 60 class AMQPSpace(agency.space.Space): View Source 175class AMQPSpace(Space): 176 &quot;&quot;&quot; 177 A Space that uses AMQP for message delivery. 178 179 This Space type is useful for distributing agents across multiple hosts. 180 181 AMQPSpace uses multiprocessing for parallelism when multiple agents are 182 added to the same instance. 183 &quot;&quot;&quot; 184 185 _BROADCAST_KEY = &quot;__broadcast__&quot; 186 187 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 188 if amqp_options is None: 189 amqp_options = self.__default_amqp_options() 190 self.__kombu_connection_options = { 191 &#39;hostname&#39;: amqp_options.hostname, 192 &#39;port&#39;: amqp_options.port, 193 &#39;userid&#39;: amqp_options.username, 194 &#39;password&#39;: amqp_options.password, 195 &#39;virtual_host&#39;: amqp_options.virtual_host, 196 &#39;ssl&#39;: amqp_options.use_ssl, 197 &#39;heartbeat&#39;: amqp_options.heartbeat, 198 } 199 self.__exchange_name: str = exchange_name 200 self.__agent_processes: Dict[str, _AgentAMQPProcess] = {} 201 router_thread = threading.Thread( 202 target=self.__router_thread, daemon=True) 203 router_thread.start() 204 205 def __router_thread(self): 206 &quot;&quot;&quot;Processes and routes outbound messages for all agents&quot;&quot;&quot; 207 while True: 208 time.sleep(0.001) 209 for agent_process in list(self.__agent_processes.values()): 210 outbound_queue = agent_process.outbound_queue 211 try: 212 # process one message per agent per loop 213 message = outbound_queue.get(block=False) 214 self._route(message) 215 except queue.Empty: 216 pass 217 218 def _route(self, message: Message): 219 message = validate_message(message) 220 221 if message[&#39;to&#39;] == &#39;*&#39;: 222 # broadcast 223 routing_key = self._BROADCAST_KEY 224 else: 225 # point to point 226 routing_key = message[&#39;to&#39;] 227 228 with Connection(**self.__kombu_connection_options) as connection: 229 with connection.Producer(serializer=&quot;json&quot;) as producer: 230 producer.publish( 231 json.dumps(message), 232 exchange=self.__exchange_name, 233 routing_key=routing_key) 234 235 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 236 try: 237 self.__agent_processes[agent_id] = _AgentAMQPProcess( 238 agent_type=agent_type, 239 agent_id=agent_id, 240 agent_kwargs=agent_kwargs, 241 kombu_connection_options=self.__kombu_connection_options, 242 exchange_name=self.__exchange_name, 243 outbound_queue=multiprocessing.Queue(), 244 ) 245 self.__agent_processes[agent_id].start() 246 247 except: 248 # clean up if an error occurs 249 self.remove(agent_id) 250 raise 251 252 def remove(self, agent_id: str): 253 agent_process = self.__agent_processes[agent_id] 254 agent_process.stop() 255 del self.__agent_processes[agent_id] 256 257 def remove_all(self): 258 agent_ids = list(self.__agent_processes.keys()) 259 for agent_id in agent_ids: 260 self.remove(agent_id) 261 262 def __default_amqp_options(self) -&gt; AMQPOptions: 263 &quot;&quot;&quot; 264 Returns a default AMQPOptions object configurable from environment 265 variables. 266 &quot;&quot;&quot; 267 return AMQPOptions( 268 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 269 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 270 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 271 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 272 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 273 use_ssl=False, 274 heartbeat=60, 275 ) . A Space that uses AMQP for message delivery. This Space type is useful for distributing agents across multiple hosts. AMQPSpace uses multiprocessing for parallelism when multiple agents are added to the same instance. AMQPSpace( amqp_options: agency.spaces.amqp_space.AMQPOptions = None, exchange_name: str = &#39;agency&#39;) View Source 187 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 188 if amqp_options is None: 189 amqp_options = self.__default_amqp_options() 190 self.__kombu_connection_options = { 191 &#39;hostname&#39;: amqp_options.hostname, 192 &#39;port&#39;: amqp_options.port, 193 &#39;userid&#39;: amqp_options.username, 194 &#39;password&#39;: amqp_options.password, 195 &#39;virtual_host&#39;: amqp_options.virtual_host, 196 &#39;ssl&#39;: amqp_options.use_ssl, 197 &#39;heartbeat&#39;: amqp_options.heartbeat, 198 } 199 self.__exchange_name: str = exchange_name 200 self.__agent_processes: Dict[str, _AgentAMQPProcess] = {} 201 router_thread = threading.Thread( 202 target=self.__router_thread, daemon=True) 203 router_thread.start() . def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, **agent_kwargs) -> agency.agent.Agent: View Source 235 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 236 try: 237 self.__agent_processes[agent_id] = _AgentAMQPProcess( 238 agent_type=agent_type, 239 agent_id=agent_id, 240 agent_kwargs=agent_kwargs, 241 kombu_connection_options=self.__kombu_connection_options, 242 exchange_name=self.__exchange_name, 243 outbound_queue=multiprocessing.Queue(), 244 ) 245 self.__agent_processes[agent_id].start() 246 247 except: 248 # clean up if an error occurs 249 self.remove(agent_id) 250 raise . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 252 def remove(self, agent_id: str): 253 agent_process = self.__agent_processes[agent_id] 254 agent_process.stop() 255 del self.__agent_processes[agent_id] . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def remove_all(self): View Source 257 def remove_all(self): 258 agent_ids = list(self.__agent_processes.keys()) 259 for agent_id in agent_ids: 260 self.remove(agent_id) . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"35": {
    "doc": "agency.spaces.amqp_space",
    "title": "agency.spaces.amqp_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"36": {
    "doc": "agency.spaces.multiprocess_space",
    "title": "\nagency.spaces.multiprocess_space    ",
    "content": "View Source 1import multiprocessing 2import queue 3import threading 4import time 5import traceback 6from multiprocessing import Event, Process 7from typing import Dict, Type 8 9from agency.agent import Agent, _QueueProtocol 10from agency.logger import log 11from agency.schema import Message, validate_message 12from agency.space import Space 13 14 15class _AgentProcess(): 16 def __init__( 17 self, 18 agent_type: Type[Agent], 19 agent_id: str, 20 agent_kwargs: Dict, 21 inbound_queue: _QueueProtocol, 22 outbound_queue: _QueueProtocol): 23 self.agent_type: Type[Agent] = agent_type 24 self.agent_id: str = agent_id 25 self.agent_kwargs: Dict = agent_kwargs 26 self.inbound_queue: _QueueProtocol = inbound_queue 27 self.outbound_queue: _QueueProtocol = outbound_queue 28 29 def start(self): 30 self.started = Event() 31 self.stopping = Event() 32 error_queue = multiprocessing.Queue() 33 self.process = Process( 34 target=self._process, 35 args=( 36 self.agent_type, 37 self.agent_id, 38 self.agent_kwargs, 39 self.inbound_queue, 40 self.outbound_queue, 41 self.started, 42 self.stopping, 43 error_queue, 44 ) 45 ) 46 self.process.start() 47 48 if not self.started.wait(timeout=10): 49 # it couldn&#39;t start, force stop the process and raise an exception 50 self.stop() 51 try: 52 error = error_queue.get(block=False) 53 raise error 54 except queue.Empty: 55 raise Exception(&quot;Process could not be started.&quot;) 56 57 def stop(self): 58 self.stopping.set() 59 if self.process.is_alive(): 60 self.process.join(timeout=10) 61 if self.process.is_alive(): 62 raise Exception(&quot;Process could not be stopped.&quot;) 63 64 def _process(self, 65 agent_type, 66 agent_id, 67 agent_kwargs, 68 inbound_queue, 69 outbound_queue, 70 started, 71 stopping, 72 error_queue): 73 try: 74 agent: Agent = agent_type( 75 agent_id, 76 outbound_queue=outbound_queue, 77 **agent_kwargs, 78 ) 79 agent.after_add() 80 log(&quot;info&quot;, f&quot;{agent.id()} added to space&quot;) 81 agent._is_processing = True 82 started.set() 83 while not stopping.is_set(): 84 time.sleep(0.001) 85 try: 86 message = inbound_queue.get(block=False) 87 agent._receive(message) 88 except queue.Empty: 89 pass 90 except KeyboardInterrupt: 91 pass 92 except Exception as e: 93 log(&quot;error&quot;, f&quot;{agent.id()} process failed with exception&quot;, traceback.format_exc()) 94 error_queue.put(e) 95 finally: 96 agent._is_processing = False 97 agent.before_remove() 98 log(&quot;info&quot;, f&quot;{agent.id()} removed from space&quot;) 99 100 101class MultiprocessSpace(Space): 102 &quot;&quot;&quot; 103 A Space implementation that uses the multiprocessing module. 104 105 This Space type is recommended in most cases over ThreadSpace for single 106 host systems since it offers better parallelism. 107 &quot;&quot;&quot; 108 109 def __init__(self): 110 self.__agent_processes: Dict[str, _AgentProcess] = {} 111 router_thread = threading.Thread( 112 target=self.__router_thread, daemon=True) 113 router_thread.start() 114 115 def __router_thread(self): 116 &quot;&quot;&quot; 117 Processes and routes outbound messages for all agents 118 &quot;&quot;&quot; 119 while True: 120 time.sleep(0.001) 121 for agent_process in list(self.__agent_processes.values()): 122 outbound_queue = agent_process.outbound_queue 123 try: 124 # process one message per agent per loop 125 message = outbound_queue.get(block=False) 126 self._route(message) 127 except queue.Empty: 128 pass 129 130 def _route(self, message: Message): 131 message = validate_message(message) 132 recipient_processes = [ 133 agent_process 134 for agent_process in list(self.__agent_processes.values()) 135 if message[&quot;to&quot;] == agent_process.agent_id or message[&quot;to&quot;] == &quot;*&quot; 136 ] 137 for recipient_process in recipient_processes: 138 recipient_process.inbound_queue.put(message) 139 140 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 141 if agent_id in self.__agent_processes.keys(): 142 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 143 144 try: 145 self.__agent_processes[agent_id] = _AgentProcess( 146 agent_type=agent_type, 147 agent_id=agent_id, 148 agent_kwargs=agent_kwargs, 149 inbound_queue=multiprocessing.Queue(), 150 outbound_queue=multiprocessing.Queue(), 151 ) 152 self.__agent_processes[agent_id].start() 153 except: 154 # clean up if an error occurs 155 self.remove(agent_id) 156 raise 157 158 def remove(self, agent_id: str): 159 agent_process = self.__agent_processes[agent_id] 160 agent_process.stop() 161 del self.__agent_processes[agent_id] 162 163 def remove_all(self): 164 agent_ids = list(self.__agent_processes.keys()) 165 for agent_id in agent_ids: 166 self.remove(agent_id) . class MultiprocessSpace(agency.space.Space): View Source 102class MultiprocessSpace(Space): 103 &quot;&quot;&quot; 104 A Space implementation that uses the multiprocessing module. 105 106 This Space type is recommended in most cases over ThreadSpace for single 107 host systems since it offers better parallelism. 108 &quot;&quot;&quot; 109 110 def __init__(self): 111 self.__agent_processes: Dict[str, _AgentProcess] = {} 112 router_thread = threading.Thread( 113 target=self.__router_thread, daemon=True) 114 router_thread.start() 115 116 def __router_thread(self): 117 &quot;&quot;&quot; 118 Processes and routes outbound messages for all agents 119 &quot;&quot;&quot; 120 while True: 121 time.sleep(0.001) 122 for agent_process in list(self.__agent_processes.values()): 123 outbound_queue = agent_process.outbound_queue 124 try: 125 # process one message per agent per loop 126 message = outbound_queue.get(block=False) 127 self._route(message) 128 except queue.Empty: 129 pass 130 131 def _route(self, message: Message): 132 message = validate_message(message) 133 recipient_processes = [ 134 agent_process 135 for agent_process in list(self.__agent_processes.values()) 136 if message[&quot;to&quot;] == agent_process.agent_id or message[&quot;to&quot;] == &quot;*&quot; 137 ] 138 for recipient_process in recipient_processes: 139 recipient_process.inbound_queue.put(message) 140 141 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 142 if agent_id in self.__agent_processes.keys(): 143 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 144 145 try: 146 self.__agent_processes[agent_id] = _AgentProcess( 147 agent_type=agent_type, 148 agent_id=agent_id, 149 agent_kwargs=agent_kwargs, 150 inbound_queue=multiprocessing.Queue(), 151 outbound_queue=multiprocessing.Queue(), 152 ) 153 self.__agent_processes[agent_id].start() 154 except: 155 # clean up if an error occurs 156 self.remove(agent_id) 157 raise 158 159 def remove(self, agent_id: str): 160 agent_process = self.__agent_processes[agent_id] 161 agent_process.stop() 162 del self.__agent_processes[agent_id] 163 164 def remove_all(self): 165 agent_ids = list(self.__agent_processes.keys()) 166 for agent_id in agent_ids: 167 self.remove(agent_id) . A Space implementation that uses the multiprocessing module. This Space type is recommended in most cases over ThreadSpace for single host systems since it offers better parallelism. def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, **agent_kwargs) -> agency.agent.Agent: View Source 141 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 142 if agent_id in self.__agent_processes.keys(): 143 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 144 145 try: 146 self.__agent_processes[agent_id] = _AgentProcess( 147 agent_type=agent_type, 148 agent_id=agent_id, 149 agent_kwargs=agent_kwargs, 150 inbound_queue=multiprocessing.Queue(), 151 outbound_queue=multiprocessing.Queue(), 152 ) 153 self.__agent_processes[agent_id].start() 154 except: 155 # clean up if an error occurs 156 self.remove(agent_id) 157 raise . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 159 def remove(self, agent_id: str): 160 agent_process = self.__agent_processes[agent_id] 161 agent_process.stop() 162 del self.__agent_processes[agent_id] . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def remove_all(self): View Source 164 def remove_all(self): 165 agent_ids = list(self.__agent_processes.keys()) 166 for agent_id in agent_ids: 167 self.remove(agent_id) . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/spaces/multiprocess_space.html",
    
    "relUrl": "/api_docs/agency/spaces/multiprocess_space.html"
  },"37": {
    "doc": "agency.spaces.multiprocess_space",
    "title": "agency.spaces.multiprocess_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/multiprocess_space.html",
    
    "relUrl": "/api_docs/agency/spaces/multiprocess_space.html"
  },"38": {
    "doc": "agency.spaces.thread_space",
    "title": "\nagency.spaces.thread_space    ",
    "content": "View Source 1import queue 2import threading 3import time 4import traceback 5from typing import Dict, Type 6 7from agency.agent import Agent, _QueueProtocol 8from agency.logger import log 9from agency.schema import Message, validate_message 10from agency.space import Space 11 12 13class _AgentThread(): 14 def __init__( 15 self, 16 agent_type: Type[Agent], 17 agent_id: str, 18 agent_kwargs: Dict, 19 inbound_queue: _QueueProtocol, 20 outbound_queue: _QueueProtocol): 21 self.agent_type: Type[Agent] = agent_type 22 self.agent_id: str = agent_id 23 self.agent_kwargs: Dict = agent_kwargs 24 self.inbound_queue: _QueueProtocol = inbound_queue 25 self.outbound_queue: _QueueProtocol = outbound_queue 26 self.__started = threading.Event() 27 self.__stopping = threading.Event() 28 29 def start(self): 30 def _thread(exception_info): 31 try: 32 agent = self.agent_type( 33 self.agent_id, 34 outbound_queue=self.outbound_queue, 35 **self.agent_kwargs, 36 ) 37 agent.after_add() 38 log(&quot;info&quot;, f&quot;{agent.id()} added to space&quot;) 39 agent._is_processing = True 40 self.__started.set() 41 while not self.__stopping.is_set(): 42 time.sleep(0.001) 43 try: 44 message = self.inbound_queue.get(block=False) 45 agent._receive(message) 46 except queue.Empty: 47 pass 48 except KeyboardInterrupt: 49 pass 50 except Exception as e: 51 log(&quot;error&quot;, f&quot;{self.agent_id} thread failed with exception&quot;, traceback.format_exc()) 52 exception_info[&quot;exception&quot;] = e 53 finally: 54 agent._is_processing = False 55 agent.before_remove() 56 log(&quot;info&quot;, f&quot;{agent.id()} removed from space&quot;) 57 58 exception_info = {&quot;exception&quot;: None} 59 self.__thread = threading.Thread( 60 target=_thread, args=(exception_info,), daemon=True) 61 self.__thread.start() 62 63 if not self.__started.wait(timeout=10): 64 # it couldn&#39;t start clean up and raise an exception 65 self.stop() 66 if exception_info[&quot;exception&quot;] is not None: 67 raise exception_info[&quot;exception&quot;] 68 else: 69 raise Exception(&quot;Thread could not be started.&quot;) 70 71 def stop(self): 72 self.__stopping.set() 73 self.__thread.join(timeout=10) 74 if self.__thread.is_alive(): 75 raise Exception(&quot;Thread could not be stopped.&quot;) 76 77 78class ThreadSpace(Space): 79 &quot;&quot;&quot; 80 A Space implementation that uses the threading module. 81 82 This Space type is recommended for testing or simple applications. 83 &quot;&quot;&quot; 84 85 def __init__(self): 86 self.__agent_threads: Dict[str, _AgentThread] = {} 87 router_thread = threading.Thread( 88 target=self.__router_thread, daemon=True) 89 router_thread.start() 90 91 def __router_thread(self): 92 &quot;&quot;&quot; 93 Processes and routes outbound messages for all agents 94 &quot;&quot;&quot; 95 while True: 96 time.sleep(0.001) 97 for agent_thread in list(self.__agent_threads.values()): 98 outbound_queue = agent_thread.outbound_queue 99 try: 100 # process one message per agent per loop 101 message = outbound_queue.get(block=False) 102 self._route(message) 103 except queue.Empty: 104 pass 105 106 def _route(self, message: Message): 107 message = validate_message(message) 108 recipient_threads = [ 109 agent_thread 110 for agent_thread in list(self.__agent_threads.values()) 111 if message[&quot;to&quot;] == agent_thread.agent_id or message[&quot;to&quot;] == &quot;*&quot; 112 ] 113 for recipient_thread in recipient_threads: 114 recipient_thread.inbound_queue.put(message) 115 116 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs): 117 if agent_id in self.__agent_threads.keys(): 118 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 119 120 try: 121 self.__agent_threads[agent_id] = _AgentThread( 122 agent_type=agent_type, 123 agent_id=agent_id, 124 agent_kwargs=agent_kwargs, 125 inbound_queue=queue.Queue(), 126 outbound_queue=queue.Queue(), 127 ) 128 self.__agent_threads[agent_id].start() 129 130 except: 131 # clean up if an error occurs 132 self.remove(agent_id) 133 raise 134 135 def remove(self, agent_id: str): 136 agent_thread = self.__agent_threads[agent_id] 137 agent_thread.stop() 138 del self.__agent_threads[agent_id] 139 140 def remove_all(self): 141 agent_ids = list(self.__agent_threads.keys()) 142 for agent_id in agent_ids: 143 self.remove(agent_id) . class ThreadSpace(agency.space.Space): View Source 79class ThreadSpace(Space): 80 &quot;&quot;&quot; 81 A Space implementation that uses the threading module. 82 83 This Space type is recommended for testing or simple applications. 84 &quot;&quot;&quot; 85 86 def __init__(self): 87 self.__agent_threads: Dict[str, _AgentThread] = {} 88 router_thread = threading.Thread( 89 target=self.__router_thread, daemon=True) 90 router_thread.start() 91 92 def __router_thread(self): 93 &quot;&quot;&quot; 94 Processes and routes outbound messages for all agents 95 &quot;&quot;&quot; 96 while True: 97 time.sleep(0.001) 98 for agent_thread in list(self.__agent_threads.values()): 99 outbound_queue = agent_thread.outbound_queue 100 try: 101 # process one message per agent per loop 102 message = outbound_queue.get(block=False) 103 self._route(message) 104 except queue.Empty: 105 pass 106 107 def _route(self, message: Message): 108 message = validate_message(message) 109 recipient_threads = [ 110 agent_thread 111 for agent_thread in list(self.__agent_threads.values()) 112 if message[&quot;to&quot;] == agent_thread.agent_id or message[&quot;to&quot;] == &quot;*&quot; 113 ] 114 for recipient_thread in recipient_threads: 115 recipient_thread.inbound_queue.put(message) 116 117 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs): 118 if agent_id in self.__agent_threads.keys(): 119 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 120 121 try: 122 self.__agent_threads[agent_id] = _AgentThread( 123 agent_type=agent_type, 124 agent_id=agent_id, 125 agent_kwargs=agent_kwargs, 126 inbound_queue=queue.Queue(), 127 outbound_queue=queue.Queue(), 128 ) 129 self.__agent_threads[agent_id].start() 130 131 except: 132 # clean up if an error occurs 133 self.remove(agent_id) 134 raise 135 136 def remove(self, agent_id: str): 137 agent_thread = self.__agent_threads[agent_id] 138 agent_thread.stop() 139 del self.__agent_threads[agent_id] 140 141 def remove_all(self): 142 agent_ids = list(self.__agent_threads.keys()) 143 for agent_id in agent_ids: 144 self.remove(agent_id) . A Space implementation that uses the threading module. This Space type is recommended for testing or simple applications. def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, **agent_kwargs): View Source 117 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs): 118 if agent_id in self.__agent_threads.keys(): 119 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 120 121 try: 122 self.__agent_threads[agent_id] = _AgentThread( 123 agent_type=agent_type, 124 agent_id=agent_id, 125 agent_kwargs=agent_kwargs, 126 inbound_queue=queue.Queue(), 127 outbound_queue=queue.Queue(), 128 ) 129 self.__agent_threads[agent_id].start() 130 131 except: 132 # clean up if an error occurs 133 self.remove(agent_id) 134 raise . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 136 def remove(self, agent_id: str): 137 agent_thread = self.__agent_threads[agent_id] 138 agent_thread.stop() 139 del self.__agent_threads[agent_id] . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def remove_all(self): View Source 141 def remove_all(self): 142 agent_ids = list(self.__agent_threads.keys()) 143 for agent_id in agent_ids: 144 self.remove(agent_id) . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/spaces/thread_space.html",
    
    "relUrl": "/api_docs/agency/spaces/thread_space.html"
  },"39": {
    "doc": "agency.spaces.thread_space",
    "title": "agency.spaces.thread_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/thread_space.html",
    
    "relUrl": "/api_docs/agency/spaces/thread_space.html"
  }
}
