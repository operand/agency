{"0": {
    "doc": "Agent Implementation",
    "title": "Agent Implementation",
    "content": "To create an agent, extend the Agent class. class MyAgent(Agent): ... ",
    "url": "/articles/agent_implementation",
    
    "relUrl": "/articles/agent_implementation"
  },"1": {
    "doc": "Agent Implementation",
    "title": "Defining Actions",
    "content": "Actions are simply instance methods decorated with @action. The @action decorator takes the following keyword arguments: . | name: The name of the action. Defaults to the method name | help: The description of the action. Defaults to autogenerated object | access_policy: The access policy of the action. Defaults to ACCESS_PERMITTED | . ",
    "url": "/articles/agent_implementation#defining-actions",
    
    "relUrl": "/articles/agent_implementation#defining-actions"
  },"2": {
    "doc": "Agent Implementation",
    "title": "Defining Help",
    "content": "The help attribute may be used for describing the given action to other agents. Below is an example of the help information generated by default from the @action decorator arguments and the method’s signature. { \"shell_command\": { \"description\": \"Execute a shell command\", \"args\": { \"command\": { \"type\": \"string\" \"description\": \"The command to execute\" } }, \"returns\": { \"type\": \"string\" \"description\": \"The output of the command\" } }, ... } . The following example shows how the same help information above can be defined using a docstring that follows the Google style guide: . @action def shell_command(self, command: str) -&gt; str: \"\"\" Execute a shell command Args: command (str): The command to execute Returns: str: The output of the command \"\"\" . The action name is determined by the method name. Types are determined by looking at the docstring and the signature, with the signature type hint taking precedence. Action and argument descriptions are parsed from the docstring. Overriding Help Information . The default help data structure could be customized as well: . @action( help={ \"You\": \"can define\", \"any\": { \"structure\": [\"you\", \"want\", \"here.\"] } } ) def say(self, content: str) -&gt; None: . If a help object is provided to the decorator, it overrides the generated object entirely. You can use this to experiment with different help information schemas. Merging the two objects, for example to only override specific fields, is not (yet) supported. Please open an issue if you’d like to see this feature developed. ",
    "url": "/articles/agent_implementation#defining-help",
    
    "relUrl": "/articles/agent_implementation#defining-help"
  },"3": {
    "doc": "Agent Implementation",
    "title": "Special Actions",
    "content": "There are three special actions present on all agents by default: . Override or extend these actions to customize the behavior of your agent. | help Returns a list of all actions on this agent. This is used by agents for action discovery. You normally do not need to implement this method but you may do so for example, to control which actions are returned to other agents. | response If an action method returns a value, this method will be called with the value. | error Receives any error messages from an action invoked by the agent. | . ",
    "url": "/articles/agent_implementation#special-actions",
    
    "relUrl": "/articles/agent_implementation#special-actions"
  },"4": {
    "doc": "Agent Implementation",
    "title": "Callbacks",
    "content": "The following is the list of agent callbacks you may implement. | before_action Called before an action is attempted. If an exception is raised in before_action, the action method and after_action callbacks will not be executed and the error will be returned to the sender. | after_action Called after an action is attempted. Provides the original message, the return value, and error if applicable. This method is called even if an exception is raised in the action. | after_add Called after an agent is added to a space and may begin sending/receiving messages. Use this method to perform any initial setup necessary upon being added to a space. | before_remove Called before an agent is removed from a space and will no longer send/receive messages. Use this method to perform any cleanup necessary before being removed from a space. | request_permission Called when an agent attempts to perform an action that requires permission. This method should return True or False to indicate whether the action should be allowed. A rejected action will be returned as a permission error to the sender. | . ",
    "url": "/articles/agent_implementation#callbacks",
    
    "relUrl": "/articles/agent_implementation#callbacks"
  },"5": {
    "doc": "Messaging",
    "title": "Messaging",
    "content": " ",
    "url": "/articles/messaging",
    
    "relUrl": "/articles/messaging"
  },"6": {
    "doc": "Messaging",
    "title": "Schema",
    "content": "All messages are validated upon sending and must conform to the message schema. The full message schema is summarized by this example: . { \"id\": \"some optional id\", \"meta\": { \"an\": \"optional\", \"object\": { \"for\": \"metadata\", } }, \"from\": \"the sender's id\", \"to\": \"the receiver's id\", \"action\": { \"name\": \"the_action_name\", \"args\": { \"the\": \"args\", } } } . Note that when sending, you may not need to supply this entire structure. The id and meta fields are optional. Additionally, the from field is automatically populated for you in the send() method. A minimal example of calling Agent.send() with only the required fields would look like: . my_agent.send({ \"to\": \"some_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } }) . See agency/schema.py for the pydantic model definition used for validation. ",
    "url": "/articles/messaging#schema",
    
    "relUrl": "/articles/messaging#schema"
  },"7": {
    "doc": "Messaging",
    "title": "Using the id Field",
    "content": "The message id field may be used to correlate an incoming message with a previously sent message, for example to associate response data with the request. The id field is not populated by default. To use the id field, you must explicitly specify it in the outgoing message object. You can set it to any string identifier you choose. By default, the id field is used by the response and error actions. If a response or error is received, the original_message_id argument will be populated with the id of the original message. For example, say we have an add action which returns the sum of its arguments. @action def add(self, a: int, b: int) -&gt; int: return a + b . Sending the following message: . my_agent.send({ \"id\": \"a custom message id\", \"to\": \"calculator_agent\", \"action\": { \"name\": \"add\", \"args\": { \"a\": 1, \"b\": 2 } } }) . … would result in a subsequent response message like the following: . { \"from\": \"calculator_agent\", \"to\": \"my_agent\", \"action\": { \"name\": \"response\", \"args\": { \"data\": 3, \"original_message_id\": \"a custom message id\" } } } . Notice the original_message_id argument populated with the id of the original message. ",
    "url": "/articles/messaging#using-the-id-field",
    
    "relUrl": "/articles/messaging#using-the-id-field"
  },"8": {
    "doc": "Messaging",
    "title": "Using the meta Field",
    "content": "The meta field may be used to store arbitrary key-value metadata about the message. It is entirely optional. Possible uses of the meta field include: . | Storing “thoughts” associated with an action. This is a common pattern used with LLM agents. For example, an LLM agent may send the following message: { \"meta\": { \"thoughts\": \"I should say hello to everyone\", }, \"to\": \"my_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } } . | Storing timestamps associated with an action. For example: { \"meta\": { \"timestamp\": 12345, }, ... } . | . These are just a couple ideas to illustrate the use of the meta field. ",
    "url": "/articles/messaging#using-the-meta-field",
    
    "relUrl": "/articles/messaging#using-the-meta-field"
  },"9": {
    "doc": "Messaging",
    "title": "Broadcast vs Point-to-Point",
    "content": "All messages require the to field to be specified. The to field should be the id of an agent in the space (point-to-point) or the special id * to broadcast the message to all agents in the space. By default, agents receive their own broadcasts, but you may change this behavior with the receive_own_broadcasts argument when creating the agent. For example: . my_agent = MyAgent(\"MyAgent\", receive_own_broadcasts=False) . ",
    "url": "/articles/messaging#broadcast-vs-point-to-point",
    
    "relUrl": "/articles/messaging#broadcast-vs-point-to-point"
  },"10": {
    "doc": "Messaging",
    "title": "Non-Existent Agents or Actions",
    "content": "If you send a message to a non-existent agent, it will silently fail. If you send a message to an existent agent, but specify a non-existent action, you will receive an error message in response. Broadcasts which specify a non-existent action are silently ignored, so that broadcasts do not result in many error messages. ",
    "url": "/articles/messaging#non-existent-agents-or-actions",
    
    "relUrl": "/articles/messaging#non-existent-agents-or-actions"
  },"11": {
    "doc": "Using AMQPSpace",
    "title": "Using AMQPSpace",
    "content": "To use AMQP for multi-process or networked communication, you can simply swap the AMQPSpace class for the NativeSpace class. Then to take advantage of parallelism, you would also separate your agents into multiple processes configured to use the same AMQP server. For example, the following would separate the Host agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a host agent to the space space.add(Host(\"Host\")) # keep alive while True: time.sleep(1) . And the following would separate the ChattyAI agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a simple HF based chat agent to the space space.add( ChattyAI(\"Chatty\", model=\"EleutherAI/gpt-neo-125m\")) # keep alive while True: time.sleep(1) . Make sure to reuse the same AMQP server and configuration for both applications. Then you can run both applications at the same time, and the agents will be able to connect and communicate with each other over AMQP. This approach allows you to scale your agents across multiple processes or hosts, and avoids the multithreading limitations of python’s GIL. See the example application for a full working example. ",
    "url": "/articles/using_amqpspace",
    
    "relUrl": "/articles/using_amqpspace"
  },"12": {
    "doc": "Using AMQPSpace",
    "title": "Configuring AMQP Connectivity",
    "content": "By default, the AMQPSpace class will read the following environment variables and will otherwise use default settings. AMQP_HOST AMQP_PORT AMQP_USERNAME AMQP_PASSWORD AMQP_VHOST . You may also customize the full list of options if you provide your own AMQPOptions object when instantiating an AMQPSpace. For example: . space = AMQPSpace( amqp_options=AMQPOptions( hostname=\"localhost\", port=5672, username=\"guest\", password=\"guest\", virtual_host=\"/\", use_ssl=True, heartbeat=60)) . ",
    "url": "/articles/using_amqpspace#configuring-amqp-connectivity",
    
    "relUrl": "/articles/using_amqpspace#configuring-amqp-connectivity"
  },"13": {
    "doc": "Example Application Walkthrough",
    "title": "Example Application Walkthrough",
    "content": "The following walkthrough will guide you through the basic concepts of Agency’s API, and how to use it to build your own agent systems. ",
    "url": "/articles/walkthrough",
    
    "relUrl": "/articles/walkthrough"
  },"14": {
    "doc": "Example Application Walkthrough",
    "title": "Creating an Agency Application",
    "content": "The snippet below is an example of a simple Agency application. For this walkthrough, we’ll be using the NativeSpace class for connecting agents. Usage is exactly the same as with the AMQPSpace class, except that a NativeSpace is for agents in the same process, and does not require an AMQP server. The following application includes the OpenAIFunctionAgent class, a transformers based chat agent named ChattyAI, operating system access, and a Gradio based web application hosted at http://localhost:8080, all integrated with the following implementation. # Create a space space = NativeSpace() # Add a simple HF based chat agent to the space space.add( ChattyAI(\"Chatty\", model=\"EleutherAI/gpt-neo-125m\")) # Add a host agent to the space, exposing access to the host system space.add(Host(\"Host\")) # Add an OpenAI agent to the space space.add( OpenAIFunctionAgent(\"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the OpenAI chat API user_id=\"User\")) # Connect the Gradio app user to the space space.add(gradio_user) # Launch Gradio UI demo.launch() . ",
    "url": "/articles/walkthrough#creating-an-agency-application",
    
    "relUrl": "/articles/walkthrough#creating-an-agency-application"
  },"15": {
    "doc": "Example Application Walkthrough",
    "title": "Creating a Space and adding an Agent",
    "content": "space = NativeSpace() space.add(ChattyAI(\"Chatty\", model=\"EleutherAI/gpt-neo-125m\")) . This creates a space and adds a new ChattyAI instance to it, with the id of Chatty. An agent’s id is used to identify the agent within the space. Other agents may send messages to Chatty by using that id, as we’ll see later. id’s are unique. Two agents may not declare the same id within the same space. ",
    "url": "/articles/walkthrough#creating-a-space-and-adding-an-agent",
    
    "relUrl": "/articles/walkthrough#creating-a-space-and-adding-an-agent"
  },"16": {
    "doc": "Example Application Walkthrough",
    "title": "Defining Actions",
    "content": "Looking at ChattyAI’s source code, you’ll see that it is a subclass of Agent, and that it exposes a single action called say. The following is a typical action method signature taken from ChattyAI. @action def say(self, content: str): \"\"\"Use this action to say something to Chatty\"\"\" ... The decorator @action is used to indicate that this is an action that can be invoked by other agents in their space. The method name say is the name of the action by default. The say action takes a single string argument content. This action is intended to allow other agents to chat with Chatty, as expressed in its docstring. When ChattyAI receives a say action, it will generate a response using its underlying language model, and return the result to the sender. ",
    "url": "/articles/walkthrough#defining-actions",
    
    "relUrl": "/articles/walkthrough#defining-actions"
  },"17": {
    "doc": "Example Application Walkthrough",
    "title": "Invoking Actions",
    "content": "An example of invoking an action can be seen here, taken from the same ChattyAI.say() method... self.send({ \"to\": self._current_message['from'], \"action\": { \"name\": \"say\", \"args\": { \"content\": response_content, } } }) . This demonstrates the basic idea of how to invoke an action on another agent. When an agent receives a message, it invokes the action method specified by the action.name field of the message, passing the action.args dictionary to the action method as keyword arguments. So here Chatty is invoking the say action on the sender of the original message, passing the response as the content argument. This way, the original sender and Chatty can have a conversation. Note the use of the _current_message variable. That variable may be inspected during an action to access the entire incoming message which invoked the action. ",
    "url": "/articles/walkthrough#invoking-actions",
    
    "relUrl": "/articles/walkthrough#invoking-actions"
  },"18": {
    "doc": "Example Application Walkthrough",
    "title": "Access Control",
    "content": "Access policies may be used to control when actions can be invoked by agents. All actions may declare an access policy like the following example: . @action(access_policy=ACCESS_PERMITTED) def my_action(self): ... An access policy can currently be one of three values: . | ACCESS_PERMITTED - (Default) Permits any agent to use that action at any time. | ACCESS_DENIED - Prevents access to that action. | ACCESS_REQUESTED - Prompts the receiving agent for permission when access is attempted. Access will await approval or denial. | . If ACCESS_REQUESTED is used, the receiving agent will be prompted to approve the action via the request_permission() callback method. If any actions declare a policy of ACCESS_REQUESTED, you must implement the request_permission() method with the following signature in order to receive permission requests. def request_permission(self, proposed_message: dict) -&gt; bool: ... Your implementation should inspect proposed_message and return a boolean indicating whether or not to permit the action. You can use this approach to protect against dangerous actions being taken. For example if you allow terminal access, you may want to review commands before they are invoked. ",
    "url": "/articles/walkthrough#access-control",
    
    "relUrl": "/articles/walkthrough#access-control"
  },"19": {
    "doc": "Example Application Walkthrough",
    "title": "The Gradio UI",
    "content": "The Gradio UI is a Chatbot based application used for development and demonstration purposes, that allows human users to connect to a space and chat with the connected agents. It is defined in examples/demo/apps/gradio_app.py and simply needs to be imported and used like so: . from apps.gradio_app import demo, gradio_user ... space.add(gradio_user) ... demo.launch() . You can also invoke actions on agents using a custom “slash” syntax. To broadcast a message to all other agents in the space, simply type without a format. The client will automatically convert unformatted text to a say action. For example, simply writing: . Hello, world! . will be broadcast to all agents as a say action. To send a point-to-point message to a specific agent, or to call actions other than say, you can use the following format: . /agent_id.action_name arg1:\"value 1\" arg2:\"value 2\" . ",
    "url": "/articles/walkthrough#the-gradio-ui",
    
    "relUrl": "/articles/walkthrough#the-gradio-ui"
  },"20": {
    "doc": "Example Application Walkthrough",
    "title": "Adding OS Access with the Host Agent",
    "content": "space.add(Host(\"Host\")) . The Host class demonstrates allowing access to the host operating system where the python application is running. It exposes actions such as read_file and shell_command which allow other agents to interact with the host. This class is a good example of one with potentially dangerous actions that must be accessed with care. You’ll notice that all the methods in the Host class have been given the access policy: . @action(access_policy=ACCESS_REQUESTED) ... Thanks to the implementation of request_permission() in the Host class, all actions on the host will require a confirmation from the terminal where the application is being run. Note that this implementation of request_permission() is just one possibility. We could have implemented for example, a phone notification for a human to review from elsewhere. ",
    "url": "/articles/walkthrough#adding-os-access-with-the-host-agent",
    
    "relUrl": "/articles/walkthrough#adding-os-access-with-the-host-agent"
  },"21": {
    "doc": "Example Application Walkthrough",
    "title": "Discovering Actions",
    "content": "At this point, we can demonstrate how action discovery works from the perspective of a human user of the web application. Once added to a space, each agent may broadcast a help message to discover other agents and actions that are available in the space. So a person using the chat UI can discover all available actions by typing: . /*.help . Note the use of *. This is a reserved name for broadcasting messages to all agents in the space. So the above command will broadcast a help action to all other agents, who will individually respond with a dictionary of their available actions. To invoke an action (like help) on a specific agent, you can use the following syntax: . /Host.help action_name:\"say\" . Note the agent name used before the action name. In this case, the help action takes an argument called action_name. So this will send the help action to the Host agent requesting information on the say action. ",
    "url": "/articles/walkthrough#discovering-actions",
    
    "relUrl": "/articles/walkthrough#discovering-actions"
  },"22": {
    "doc": "Example Application Walkthrough",
    "title": "Adding an Intelligent Agent",
    "content": "Lastly we can add an intelligent agent into the space. To add the OpenAIFunctionAgent class to the environment: . space.add( OpenAIFunctionAgent(\"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the chat API user_id=\"User\")) . For more agent examples that you can try, see the examples/demo/agents/ directory. That concludes the example walkthrough. To try the demo application, please jump to the examples/demo/ directory. ",
    "url": "/articles/walkthrough#adding-an-intelligent-agent",
    
    "relUrl": "/articles/walkthrough#adding-an-intelligent-agent"
  }
}
