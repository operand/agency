{"0": {
    "doc": "Agent Callbacks",
    "title": "Agent Callbacks",
    "content": "The following list describes all available agent callbacks, with a link to their API documentation. Please see the API docs for more detailed descriptions of these callbacks. after_add . Called after an agent is added to a space, but before it begins processing messages. before_remove . Called before an agent is removed from a space and will no longer process more messages. handle_action_value . If an action method returns a value, this method will be called with the value. handle_action_error . Receives any error messages from an action invoked by the agent. before_action . Called before an action is attempted. after_action . Called after an action is attempted. request_permission . Called when an agent attempts to perform an action that requires permission. ",
    "url": "/articles/agent_callbacks",
    
    "relUrl": "/articles/agent_callbacks"
  },"1": {
    "doc": "Creating Spaces",
    "title": "Creating Spaces",
    "content": "A Space is where agents may communicate and interact with each other. Agents are instantiated within a space when added. Spaces define the underlying communication transport used for messaging. Agency currently implements two Space types: . | LocalSpace - which connects agents within the same application. | AMQPSpace - which connects agents across a network using an AMQP server. | . ",
    "url": "/articles/creating_spaces",
    
    "relUrl": "/articles/creating_spaces"
  },"2": {
    "doc": "Creating Spaces",
    "title": "Using LocalSpace",
    "content": "LocalSpace is the more basic of the two. It connects agents within the same python application using interprocess communication (IPC). Instantiating a LocalSpace, like other spaces, is as simple as: . space = LocalSpace() space.add(Host, \"Host\") ... The above example would instantiate the Host agent within the LocalSpace instance, allowing any other agents added to the space to communicate with it. ",
    "url": "/articles/creating_spaces#using-localspace",
    
    "relUrl": "/articles/creating_spaces#using-localspace"
  },"3": {
    "doc": "Creating Spaces",
    "title": "Using AMQPSpace",
    "content": "AMQPSpace may be used for building applications that allows agent communication across multiple hosts in a network. To run an AMQPSpace across multiple hosts, you would separate your agents into multiple applications. Each application would be configured to use the same AMQP server. For example, the following would separate the Host agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a host agent to the space space.add(Host, \"Host\") . And the following would separate the ChattyAI agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a simple HF based chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") . Then you can run both applications at the same time, and the agents will be able to connect and communicate with each other over AMQP. This approach allows you to scale your agents beyond a single host. See the example application for a full working example. Configuring AMQP Connectivity . By default, the AMQPSpace class will read the following environment variables and will otherwise use default settings. AMQP_HOST AMQP_PORT AMQP_USERNAME AMQP_PASSWORD AMQP_VHOST . You may also customize the options if you provide your own AMQPOptions object when instantiating an AMQPSpace. For example: . space = AMQPSpace( amqp_options=AMQPOptions( hostname=\"localhost\", port=5672, username=\"guest\", password=\"guest\", virtual_host=\"/\", use_ssl=True, heartbeat=60)) . ",
    "url": "/articles/creating_spaces#using-amqpspace",
    
    "relUrl": "/articles/creating_spaces#using-amqpspace"
  },"4": {
    "doc": "Creating Spaces",
    "title": "Instantiating and Destroying Spaces",
    "content": "Space instances manage a number of resources during their lifetime. To destroy a Space, simply call its destroy method. This will clean up all resources used by the space, along with any agents within the space. Spaces also support the context manager syntax for convenience. For example: . with LocalSpace() as space: space.add(Host, \"Host\") ... This form will automatically clean up Space related resources upon exit of the with block. ",
    "url": "/articles/creating_spaces#instantiating-and-destroying-spaces",
    
    "relUrl": "/articles/creating_spaces#instantiating-and-destroying-spaces"
  },"5": {
    "doc": "Defining Actions",
    "title": "Defining Actions",
    "content": "The @action decorator is used to define actions on instance methods of the Agent class, and takes the following keyword arguments: . | name: The name of the action. Defaults to the method name | help: The description of the action. Defaults to an autogenerated object | access_policy: The access policy of the action. Defaults to ACCESS_PERMITTED | . ",
    "url": "/articles/defining_actions",
    
    "relUrl": "/articles/defining_actions"
  },"6": {
    "doc": "Defining Actions",
    "title": "Defining Action Help Information",
    "content": "Below is an example of the help information automatically generated by default from the @action decorator. It uses the docstring of the method, and its signature to generate the default help information. { \"shell_command\": { \"description\": \"Execute a shell command\", \"args\": { \"command\": { \"type\": \"string\" \"description\": \"The command to execute\" } }, \"returns\": { \"type\": \"string\" \"description\": \"The output of the command\" } }, ... } . This help object is supplied to other agents when requesting help. The following example shows how the help information above can be specified from a docstring that follows the Google style guide: . @action def shell_command(self, command: str) -&gt; str: \"\"\" Execute a shell command Args: command (str): The command to execute Returns: str: The output of the command \"\"\" . When generating help information, the action name is determined by the method name. Types are determined by looking at the docstring and the signature, with the signature type hint taking precedence. Action and argument descriptions are parsed from the docstring. Overriding Help Information . The default help data structure described above can be overridden by supplying a custom help object to the @action decorator. @action( help={ \"You\": \"can define\", \"any\": { \"structure\": [\"you\", \"want\", \"here.\"] } } ) def say(self, content: str): . When a custom help object is provided, it overrides the generated object entirely. You can use this to experiment with different help information schemas. ",
    "url": "/articles/defining_actions#defining-action-help-information",
    
    "relUrl": "/articles/defining_actions#defining-action-help-information"
  },"7": {
    "doc": "Defining Actions",
    "title": "Access Policies",
    "content": "❗️Access control is experimental. Please share your feedback. Access policies may be used to control when actions can be invoked by agents. All actions may declare an access policy like the following example: . @action(access_policy=ACCESS_PERMITTED) def my_action(self): ... An access policy can currently be one of three values: . | ACCESS_PERMITTED - (Default) Permits any agent to use that action at any time. | ACCESS_DENIED - Prevents access to that action. | ACCESS_REQUESTED - Prompts the receiving agent for permission when access is attempted. Access will await approval or denial. | . If ACCESS_REQUESTED is used, the receiving agent will be prompted to approve the action via the request_permission() callback method. If any actions declare a policy of ACCESS_REQUESTED, you must implement the request_permission() method with the following signature in order to receive permission requests. def request_permission(self, proposed_message: dict) -&gt; bool: ... Your implementation should inspect proposed_message and return a boolean indicating whether or not to permit the action. You can use this approach to protect against dangerous actions being taken. For example if you allow terminal access, you may want to review commands before they are invoked. ",
    "url": "/articles/defining_actions#access-policies",
    
    "relUrl": "/articles/defining_actions#access-policies"
  },"8": {
    "doc": "Messaging",
    "title": "Messaging",
    "content": "The following details cover the message schema and other messaging behavior. ",
    "url": "/articles/messaging",
    
    "relUrl": "/articles/messaging"
  },"9": {
    "doc": "Messaging",
    "title": "Message Schema",
    "content": "All messages are validated upon sending and must conform to the message schema. Note that when sending, you normally do not supply the entire structure. The meta.id, meta.parent_id, and from fields are automatically populated for you. The full message schema is summarized by this example: . { \"meta\": { \"id\": \"a string to identify the message\", \"parent_id\": \"meta.id of the parent message, if any\", \"anything\": \"else here\", }, \"from\": \"TheSender\", # The following fields must be specified when sending \"to\": \"TheReceiver\", \"action\": { \"name\": \"the_action_name\", \"args\": { \"the\": \"args\", } } } . An example of calling Agent.send() with only the minimum fields would look like: . self.send({ \"to\": \"some_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } }) . See agency/schema.py for the pydantic model definition used for validation. ",
    "url": "/articles/messaging#message-schema",
    
    "relUrl": "/articles/messaging#message-schema"
  },"10": {
    "doc": "Messaging",
    "title": "The to and from Fields",
    "content": "The to and from fields are used for addressing messages. All messages require the to field to be specified. The to field should be the id of an agent in the space (point-to-point) or the special id * for a broadcast (see below). The from field is automatically populated for you when sending. ",
    "url": "/articles/messaging#the-to-and-from-fields",
    
    "relUrl": "/articles/messaging#the-to-and-from-fields"
  },"11": {
    "doc": "Messaging",
    "title": "The action Field",
    "content": "The action field contains the body of the action invocation. It carries the action name and the arguments to pass as a dictionary object called args. ",
    "url": "/articles/messaging#the-action-field",
    
    "relUrl": "/articles/messaging#the-action-field"
  },"12": {
    "doc": "Messaging",
    "title": "The meta Field",
    "content": "The meta field may be used to store arbitrary key-value metadata about the message. It is optional to define, though the meta.id and meta.parent_id fields will be populated automatically by default. Example uses of the meta field include: . | Storing “thoughts” associated with an action. This is a common pattern used with LLM agents. For example, an LLM agent may send the following message: { \"meta\": { \"thoughts\": \"I should say hello to everyone\", }, \"to\": \"*\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } } . | Storing timestamps associated with an action. For example: { \"meta\": { \"timestamp\": 12345, }, ... } . | . ",
    "url": "/articles/messaging#the-meta-field",
    
    "relUrl": "/articles/messaging#the-meta-field"
  },"13": {
    "doc": "Messaging",
    "title": "Broadcasting Messages",
    "content": "Sending a message to the special id * will broadcast the message to all agents in the space. By default, agents receive their own broadcasts, but you may change this behavior with the receive_own_broadcasts argument when creating the agent. For example: . my_agent = MyAgent(\"MyAgent\", receive_own_broadcasts=False) . ",
    "url": "/articles/messaging#broadcasting-messages",
    
    "relUrl": "/articles/messaging#broadcasting-messages"
  },"14": {
    "doc": "Messaging",
    "title": "Messaging to Non-Existent Agents or Actions",
    "content": "If you send a message to a non-existent agent id, it will silently fail. This is in line with the actor model. If you send a message to an existent agent, but specify a non-existent action, you will receive an error response which you may handle in the handle_action_error callback. If you send a broadcast that specifies a non-existent action on some agents, those agents will silently ignore the error. ",
    "url": "/articles/messaging#messaging-to-non-existent-agents-or-actions",
    
    "relUrl": "/articles/messaging#messaging-to-non-existent-agents-or-actions"
  },"15": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Responses and Synchronous Messaging",
    "content": "Messages sent using Agent.send() are sent asynchronously. This is in line with the expectations in an actor model. Often though, we’d like to send a message to an agent and receive an associated response. Agents have multiple options for doing this. ",
    "url": "/articles/responses",
    
    "relUrl": "/articles/responses"
  },"16": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Replying to Messages",
    "content": "The most basic response can be achieved simply using Agent.send() along with Agent.current_message(). For example: . class MyAgent(Agent): @action def say(self, content: str): ... self.send({ \"to\": self.current_message()[\"from\"], # reply to the sender \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello!\" } } }) . The above will send the say action back to the original sender. ",
    "url": "/articles/responses#replying-to-messages",
    
    "relUrl": "/articles/responses#replying-to-messages"
  },"17": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Using Agent.respond_with for Value Responses",
    "content": "Often it’s useful to send a value back to the sender of a message, similar to a return value from a function. In these cases, Agent.respond_with may be used. Take the following two simple agents as an example. class MyAgent(Agent): @action def ping(self): self.respond_with(\"pong\") class SenderAgent(Agent): ... def handle_action_value(self, value): print(value) . When an instance of SenderAgent sends a ping action to MyAgent, the handle_action_value callback on SenderAgent will be invoked with the value \"pong\". Note that respond_with() may be called multiple times in a single action. Each call will invoke the handle_action_value callback on the sender. ",
    "url": "/articles/responses#using-agentrespond_with-for-value-responses",
    
    "relUrl": "/articles/responses#using-agentrespond_with-for-value-responses"
  },"18": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Using Agent.raise_with for Error Responses",
    "content": "Similar to Agent.respond_with, Agent.raise_with may be used to send an exception back to the sender of a message. For example: . class MyAgent(Agent): @action def ping(self): self.raise_with(Exception(\"oops\")) class SenderAgent(Agent): ... def handle_action_error(self, error: ActionError): print(error.message) . In this example, an instance of SenderAgent sends a ping action to MyAgent. The handle_action_error callback on MyAgent will be invoked with the exception ActionError(\"Exception: oops\"). Similar to respond_with, raise_with may be called multiple times in a single action. Each call will invoke the handle_action_error callback on the sender. Note that when an action raises an exception, raise_with will be automatically invoked for you, sending the exception back to the sender. ",
    "url": "/articles/responses#using-agentraise_with-for-error-responses",
    
    "relUrl": "/articles/responses#using-agentraise_with-for-error-responses"
  },"19": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Using Agent.request() for Synchronous Messaging",
    "content": "The Agent.request() method is a synchronous version of the send() method that allows you to call an action and receive its return value or exception synchronously without using the handle_action_* callbacks. If the action responds with an error, an ActionError will be raised containing the original error message. Here’s an example of how you might use request(): . try: return_value = self.request({ \"to\": \"ExampleAgent\", \"action\": { \"name\": \"example_action\", \"args\": { \"content\": \"hello\" } } }, timeout=5) except ActionError as e: print(e.message) . Note that request() may not be called within the after_add() and before_remove() callbacks, but may be used within actions or other callbacks. Also notice the timeout value. The default is 3 seconds. Make sure to increase this appropriately for longer running requests. ",
    "url": "/articles/responses#using-agentrequest-for-synchronous-messaging",
    
    "relUrl": "/articles/responses#using-agentrequest-for-synchronous-messaging"
  },"20": {
    "doc": "Example Application Walkthrough",
    "title": "Example Application Walkthrough",
    "content": "The following walkthrough will guide you through the basic concepts of Agency’s API, and how to use it to build a simple agent system. In this walkthrough, we’ll be using the LocalSpace class for connecting agents. Usage is exactly the same as with AMQPSpace. The Space type used determines the communication implementation used for the space. ",
    "url": "/articles/walkthrough",
    
    "relUrl": "/articles/walkthrough"
  },"21": {
    "doc": "Example Application Walkthrough",
    "title": "Creating a Space and adding Agents",
    "content": "The following snippet, adapted from the demo application, shows how to instantiate a space and add several agents to it. The application includes OpenAIFunctionAgent which uses the OpenAI API, a local LLM chat agent named ChattyAI, the Host agent which allows access to the host system, and a Gradio based chat application which allows its user to communicate within the space as an agent as well. # Create the space instance space = LocalSpace() # Add a Host agent to the space, exposing access to the host system space.add(Host, \"Host\") # Add a local chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") # Add an OpenAI function API agent to the space space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the OpenAI chat API user_id=\"User\") # Connect the Gradio user to the space gradio_user = space.add_foreground(GradioUser, \"User\") # Launch the gradio UI allowing the user to communicate gradio_user.demo().launch() . Let’s break this example down step by step. ",
    "url": "/articles/walkthrough#creating-a-space-and-adding-agents",
    
    "relUrl": "/articles/walkthrough#creating-a-space-and-adding-agents"
  },"22": {
    "doc": "Example Application Walkthrough",
    "title": "Agent ids",
    "content": "Notice first that each agent is given a string id like \"Host\" or \"Chatty\". An agent’s id is used to uniquely identify the agent within the space. Other agents may send messages to Chatty or Host by using their id’s, as we’ll see later. ",
    "url": "/articles/walkthrough#agent-ids",
    
    "relUrl": "/articles/walkthrough#agent-ids"
  },"23": {
    "doc": "Example Application Walkthrough",
    "title": "Defining an Agent and its Actions",
    "content": "To define an Agent type like ChattyAI, simply extend the Agent class. For example: . class ChattyAI(Agent): ... Actions are publicly available methods that agents expose within a space, and may be invoked by other agents. To define actions, you simply define instance methods on the Agent class, and use the @action decorator. For example the following defines an action called say that takes a single string argument content. @action def say(self, content: str): \"\"\"Use this action to say something to Chatty\"\"\" ... Other agents may invoke this action by sending a message to Chatty as we’ll see below. ",
    "url": "/articles/walkthrough#defining-an-agent-and-its-actions",
    
    "relUrl": "/articles/walkthrough#defining-an-agent-and-its-actions"
  },"24": {
    "doc": "Example Application Walkthrough",
    "title": "Invoking Actions",
    "content": "When agents are added to a space, they may send messages to other agents to invoke their actions. An example of invoking an action can be seen here, taken from the ChattyAI.say() implementation... self.send({ \"to\": self.current_message()['from'], # reply to the sender \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello from Chatty!\", } } }) . This demonstrates the basic idea of how to send a message to invoke an action on another agent. When an agent receives a message, it invokes the actions method, passing action.args as keyword arguments to the method. So here, Chatty is invoking the say action on the sender of the current message that they received. This simple approach allows the original sender and Chatty to have a conversation using only the say action. Note the use of current_message(). That method may be used during an action to inspect the entire message which invoked the current action. ",
    "url": "/articles/walkthrough#invoking-actions",
    
    "relUrl": "/articles/walkthrough#invoking-actions"
  },"25": {
    "doc": "Example Application Walkthrough",
    "title": "Discovering Agents and their Actions",
    "content": "At this point, we can demonstrate how agent and action discovery works from the perspective of an agent. All agents implement a help action, which returns a dictionary of their available actions for other agents to discover. To request help information, an agent may send something like the following: . self.send({ \"to\": \"Chatty\" \"action\": { \"name\": \"help\" } }) . \"Chatty\" will respond by returning a message with a dictionary of available actions. For example, if \"Chatty\" implements a single say action as shown above, it will respond with: . { \"say\": { \"description\": \"Use this action to say something to Chatty\", \"args\": { \"content\": { \"type\": \"string\", \"description\": \"What to say to Chatty\" }, }, } } . This is how agents may discover available actions on other agents. Broadcasting help . But how does an agent know which agents are present in the space? . To discover all agents in the space, an agent can broadcast a message using the special id *. For example: . self.send({ \"to\": \"*\", \"action\": { \"name\": \"help\", } }) . The above will broadcast the help message to all agents in the space, who will individually respond with their available actions. This way, an agent may discover all the agents in the space and their actions. To request help on a specific action, you may supply the action name as an argument: . self.send({ \"to\": \"*\", \"action\": { \"name\": \"help\", \"args\": { \"action_name\": \"say\" } } }) . The above will broadcast the help action, requesting help specifically on the say action. Note that broadcasts may be used for other messages as well. See the messaging article for more details. ",
    "url": "/articles/walkthrough#discovering-agents-and-their-actions",
    
    "relUrl": "/articles/walkthrough#discovering-agents-and-their-actions"
  },"26": {
    "doc": "Example Application Walkthrough",
    "title": "Adding an Intelligent Agent",
    "content": "Now that we understand how agents communicate and discover each other, let’s add an intelligent agent to the space which can use these abilities. To add the OpenAIFunctionAgent to the space: . space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the chat API user_id=\"User\") . If you inspect the implementation of OpenAIFunctionAgent, you’ll see that this agent uses the after_add callback to immediately request help information from the other agents in the space when added. It later uses that information to provide a list of functions to the OpenAI function calling API, allowing the LLM to see agent actions as functions it may invoke. In this way, the OpenAIFunctionAgent can discover other agents in the space and interact with them intelligently as needed. ",
    "url": "/articles/walkthrough#adding-an-intelligent-agent",
    
    "relUrl": "/articles/walkthrough#adding-an-intelligent-agent"
  },"27": {
    "doc": "Example Application Walkthrough",
    "title": "Adding a User Interface",
    "content": "There are two general approaches you might follow to implement a user-facing application which interacts with a space: . | You may represent the user-facing application as an individual agent, having it act as a “liason” between the user and the space. User intentions can be mapped to actions that the “liason” agent can invoke on behalf of the user. In this approach, users would not need to know the details of the underlying communication. | Individual human users may be represented as individual agents in a space. This approach allows your application to provide direct interaction with agents by users and has the benefit of allowing actions to be invoked directly, enabling more powerful interactive possibilities. This is the approach taken in the demo application. For example, the demo UI (currently implemented in Gradio) allows users to directly invoke actions via a “slash” syntax similar to the following: . /Chatty.say content:\"Hello\" . This allows the user to work hand-in-hand with intelligent agents, and is one of the driving visions behind Agency’s design. See the demo application for a full working example of this approach. | . ",
    "url": "/articles/walkthrough#adding-a-user-interface",
    
    "relUrl": "/articles/walkthrough#adding-a-user-interface"
  },"28": {
    "doc": "Example Application Walkthrough",
    "title": "Next Steps",
    "content": "This concludes the example walkthrough. To try out the working demo, please jump to the examples/demo directory. ",
    "url": "/articles/walkthrough#next-steps",
    
    "relUrl": "/articles/walkthrough#next-steps"
  },"29": {
    "doc": "agency",
    "title": "\nagency    ",
    "content": "View Source 1import multiprocessing 2 3multiprocessing.set_start_method(&#39;spawn&#39;, force=True) . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"30": {
    "doc": "agency",
    "title": "Submodules",
    "content": ". | agent | logger | processor | queue | schema | space | spaces | . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"31": {
    "doc": "agency",
    "title": "agency",
    "content": " ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"32": {
    "doc": "agency.agent",
    "title": "\nagency.agent    ",
    "content": "View Source 1import inspect 2import re 3import threading 4import uuid 5from typing import Dict, List, Union 6 7from docstring_parser import DocstringStyle, parse 8 9from agency.logger import log 10from agency.queue import Queue 11from agency.schema import Message 12 13 14def _python_to_json_type_name(python_type_name: str) -&gt; str: 15 return { 16 &#39;str&#39;: &#39;string&#39;, 17 &#39;int&#39;: &#39;number&#39;, 18 &#39;float&#39;: &#39;number&#39;, 19 &#39;bool&#39;: &#39;boolean&#39;, 20 &#39;list&#39;: &#39;array&#39;, 21 &#39;dict&#39;: &#39;object&#39; 22 }[python_type_name] 23 24 25def _generate_help(method: callable) -&gt; dict: 26 &quot;&quot;&quot; 27 Generates a help object from a method&#39;s docstring and signature 28 29 Args: 30 method: the method 31 32 Returns: 33 A help object of the form: 34 35 { 36 &quot;description&quot;: &lt;description&gt;, 37 &quot;args&quot;: { 38 &quot;arg_name&quot;: { 39 &quot;type&quot;: &lt;type&gt;, 40 &quot;description&quot;: &lt;description&gt; 41 }, 42 } 43 &quot;returns&quot;: { 44 &quot;type&quot;: &lt;type&gt;, 45 &quot;description&quot;: &lt;description&gt; 46 } 47 } 48 &quot;&quot;&quot; 49 signature = inspect.signature(method) 50 parsed_docstring = parse(method.__doc__, DocstringStyle.GOOGLE) 51 52 help_object = {} 53 54 # description 55 if parsed_docstring.short_description is not None: 56 description = parsed_docstring.short_description 57 if parsed_docstring.long_description is not None: 58 description += &quot; &quot; + parsed_docstring.long_description 59 help_object[&quot;description&quot;] = re.sub(r&quot;\\s+&quot;, &quot; &quot;, description).strip() 60 61 # args 62 help_object[&quot;args&quot;] = {} 63 docstring_args = {arg.arg_name: arg for arg in parsed_docstring.params} 64 arg_names = list(signature.parameters.keys())[1:] # skip &#39;self&#39; argument 65 for arg_name in arg_names: 66 arg_object = {} 67 68 # type 69 sig_annotation = signature.parameters[arg_name].annotation 70 if sig_annotation is not None and sig_annotation.__name__ != &quot;_empty&quot;: 71 arg_object[&quot;type&quot;] = _python_to_json_type_name( 72 signature.parameters[arg_name].annotation.__name__) 73 elif arg_name in docstring_args and docstring_args[arg_name].type_name is not None: 74 arg_object[&quot;type&quot;] = _python_to_json_type_name( 75 docstring_args[arg_name].type_name) 76 77 # description 78 if arg_name in docstring_args and docstring_args[arg_name].description is not None: 79 arg_object[&quot;description&quot;] = docstring_args[arg_name].description.strip() 80 81 help_object[&quot;args&quot;][arg_name] = arg_object 82 83 # returns 84 if parsed_docstring.returns is not None: 85 help_object[&quot;returns&quot;] = {} 86 87 # type 88 if signature.return_annotation is not None: 89 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 90 signature.return_annotation.__name__) 91 elif parsed_docstring.returns.type_name is not None: 92 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 93 parsed_docstring.returns.type_name) 94 95 # description 96 if parsed_docstring.returns.description is not None: 97 help_object[&quot;returns&quot;][&quot;description&quot;] = parsed_docstring.returns.description.strip() 98 99 return help_object 100 101 102# Special action names 103_RESPONSE_ACTION_NAME = &quot;[response]&quot; 104_ERROR_ACTION_NAME = &quot;[error]&quot; 105 106 107# Access policies 108ACCESS_PERMITTED = &quot;ACCESS_PERMITTED&quot; 109ACCESS_DENIED = &quot;ACCESS_DENIED&quot; 110ACCESS_REQUESTED = &quot;ACCESS_REQUESTED&quot; 111 112 113def action(*args, **kwargs): 114 &quot;&quot;&quot; 115 Declares instance methods as actions making them accessible to other agents. 116 117 Keyword arguments: 118 name: The name of the action. Defaults to the name of the method. 119 help: The help object. Defaults to a generated object. 120 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 121 &quot;&quot;&quot; 122 def decorator(method): 123 action_name = kwargs.get(&quot;name&quot;, method.__name__) 124 if action_name == _RESPONSE_ACTION_NAME: 125 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 126 method.action_properties: dict = { 127 &quot;name&quot;: method.__name__, 128 &quot;help&quot;: _generate_help(method), 129 &quot;access_policy&quot;: ACCESS_PERMITTED, 130 **kwargs, 131 } 132 return method 133 134 if len(args) == 1 and callable(args[0]) and not kwargs: 135 return decorator(args[0]) # The decorator was used without parentheses 136 else: 137 return decorator # The decorator was used with parentheses 138 139 140class ActionError(Exception): 141 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; 142 143 144class Agent(): 145 &quot;&quot;&quot; 146 An Actor that may represent an AI agent, software interface, or human user 147 &quot;&quot;&quot; 148 149 def __init__(self, id: str, receive_own_broadcasts: bool = True): 150 &quot;&quot;&quot; 151 Initializes an Agent. 152 153 This constructor is not meant to be called directly. It is invoked by 154 the Space class when adding an agent. 155 156 Subclasses should call super().__init__() in their constructor. 157 158 Args: 159 id: The id of the agent 160 receive_own_broadcasts: 161 Whether the agent will receive its own broadcasts. Defaults to 162 True 163 &quot;&quot;&quot; 164 if len(id) &lt; 1 or len(id) &gt; 255: 165 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 166 if re.match(r&quot;^amq\\.&quot;, id): 167 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 168 if id == &quot;*&quot;: 169 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 170 self._id: str = id 171 self._receive_own_broadcasts: bool = receive_own_broadcasts 172 # --- non-constructor properties set by Space/Processor --- 173 self._outbound_queue: Queue = None 174 self._is_processing: bool = False 175 # --- non-constructor properties --- 176 self._message_log: List[Message] = [] 177 self._message_log_lock: threading.Lock = threading.Lock() 178 self._pending_requests: Dict[str, Union[threading.Event, Message]] = {} 179 self._pending_requests_lock: threading.Lock = threading.Lock() 180 self.__thread_local_current_message = threading.local() 181 self.__thread_local_current_message.value: Message = None 182 183 def id(self) -&gt; str: 184 return self._id 185 186 def send(self, message: dict) -&gt; str: 187 &quot;&quot;&quot; 188 Sends (out) a message from this agent. 189 190 Args: 191 message: The message 192 193 Returns: 194 The meta.id of the sent message 195 196 Raises: 197 TypeError: If the message is not a dict 198 ValueError: If the message is invalid 199 &quot;&quot;&quot; 200 if not isinstance(message, dict): 201 raise TypeError(&quot;message must be a dict&quot;) 202 if &quot;from&quot; in message and message[&quot;from&quot;] != self.id(): 203 raise ValueError( 204 f&quot;&#39;from&#39; field value &#39;{message[&#39;from&#39;]}&#39; does not match this agent&#39;s id.&quot;) 205 message[&quot;from&quot;] = self.id() 206 message[&quot;meta&quot;] = { 207 &quot;id&quot;: uuid.uuid4().__str__(), 208 **message.get(&quot;meta&quot;, {}), 209 } 210 message = Message(**message).dict(by_alias=True, exclude_unset=True) 211 with self._message_log_lock: 212 log(&quot;info&quot;, f&quot;{self._id}: sending&quot;, message) 213 self._message_log.append(message) 214 self._outbound_queue.put(message) 215 return message[&quot;meta&quot;][&quot;id&quot;] 216 217 def request(self, message: dict, timeout: float = 3) -&gt; object: 218 &quot;&quot;&quot; 219 Synchronously sends a message then waits for and returns the return 220 value of the invoked action. 221 222 This method allows you to call an action synchronously like a function 223 and receive its return value in python. If the action raises an 224 exception an ActionError will be raised containing the error message. 225 226 Args: 227 message: The message to send 228 timeout: 229 The timeout in seconds to wait for the returned value. 230 Defaults to 3 seconds. 231 232 Returns: 233 object: The return value of the action. 234 235 Raises: 236 TimeoutError: If the timeout is reached 237 ActionError: If the action raised an exception 238 RuntimeError: 239 If called before the agent is processing incoming messages 240 &quot;&quot;&quot; 241 if not self._is_processing: 242 raise RuntimeError( 243 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 244 245 # Send and mark the request as pending 246 with self._pending_requests_lock: 247 request_id = self.send(message) 248 self._pending_requests[request_id] = threading.Event() 249 250 # Wait for response 251 if not self._pending_requests[request_id].wait(timeout=timeout): 252 raise TimeoutError 253 254 with self._pending_requests_lock: 255 response_message = self._pending_requests.pop(request_id) 256 257 # Raise error or return value from response 258 if response_message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 259 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 260 261 if response_message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 262 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 263 264 raise RuntimeError(&quot;We should never get here&quot;) 265 266 def respond_with(self, value): 267 &quot;&quot;&quot; 268 Sends a response with the given value. 269 270 Parameters: 271 value (any): The value to be sent in the response message. 272 &quot;&quot;&quot; 273 self.send({ 274 &quot;meta&quot;: { 275 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;] 276 }, 277 &quot;to&quot;: self.current_message()[&#39;from&#39;], 278 &quot;action&quot;: { 279 &quot;name&quot;: _RESPONSE_ACTION_NAME, 280 &quot;args&quot;: { 281 &quot;value&quot;: value, 282 } 283 } 284 }) 285 286 def raise_with(self, error: Exception): 287 &quot;&quot;&quot; 288 Sends an error response. 289 290 Args: 291 error (Exception): The error to send. 292 &quot;&quot;&quot; 293 self.send({ 294 &quot;meta&quot;: { 295 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;], 296 }, 297 &quot;to&quot;: self.current_message()[&#39;from&#39;], 298 &quot;action&quot;: { 299 &quot;name&quot;: _ERROR_ACTION_NAME, 300 &quot;args&quot;: { 301 &quot;error&quot;: f&quot;{error.__class__.__name__}: {error}&quot; 302 } 303 } 304 }) 305 306 def _receive(self, message: dict): 307 &quot;&quot;&quot; 308 Receives and handles an incoming message. 309 310 Args: 311 message: The incoming message 312 &quot;&quot;&quot; 313 try: 314 # Ignore own broadcasts if _receive_own_broadcasts is false 315 if not self._receive_own_broadcasts \\ 316 and message[&#39;from&#39;] == self.id() \\ 317 and message[&#39;to&#39;] == &#39;*&#39;: 318 return 319 320 log(&quot;debug&quot;, f&quot;{self.id()}: received message&quot;, message) 321 322 # Record the received message before handling 323 with self._message_log_lock: 324 self._message_log.append(message) 325 326 # Handle incoming responses 327 # TODO: make serial/fan-out optional 328 if message[&quot;action&quot;][&quot;name&quot;] in [_RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME]: 329 parent_id = message[&quot;meta&quot;][&quot;parent_id&quot;] 330 if parent_id in self._pending_requests.keys(): 331 # This was a response to a request(). We use a little trick 332 # here and simply swap out the event that is waiting with 333 # the message, then set the event. The request() method will 334 # pick up the response message in the existing thread. 335 event = self._pending_requests[parent_id] 336 self._pending_requests[parent_id] = message 337 event.set() 338 else: 339 # This was a response to a send() 340 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 341 handler_callback = self.handle_action_value 342 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 343 elif message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 344 handler_callback = self.handle_action_error 345 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 346 else: 347 raise RuntimeError(&quot;Unknown action response&quot;) 348 349 # Spawn a thread to handle the response 350 def __process_response(arg, current_message): 351 self.__thread_local_current_message.value = current_message 352 handler_callback(arg) 353 354 threading.Thread( 355 target=__process_response, 356 args=(arg, message, ), 357 daemon=True, 358 name=f&quot;{self.id()} response handler {message[&#39;meta&#39;][&#39;id&#39;]}&quot;, 359 ).start() 360 361 # Handle all other messages 362 else: 363 # Spawn a thread to process the message. This means that messages 364 # are processed concurrently, but may be processed out of order. 365 threading.Thread( 366 target=self.__process, 367 args=(message,), 368 daemon=True, 369 name=f&quot;{self.id()} message handler {message[&#39;meta&#39;][&#39;id&#39;]}&quot;, 370 ).start() 371 except Exception as e: 372 log(&quot;error&quot;, f&quot;{self.id()}: raised exception in _receive&quot;, e) 373 374 def __process(self, message: dict): 375 &quot;&quot;&quot; 376 Top level method within the action processing thread. 377 &quot;&quot;&quot; 378 self.__thread_local_current_message.value = message 379 try: 380 log(&quot;debug&quot;, f&quot;{self.id()}: committing action&quot;, message) 381 self.__commit(message) 382 except Exception as e: 383 # Handle errors (including PermissionError) that occur while 384 # committing an action by reporting back to the sender. 385 log(&quot;warning&quot;, 386 f&quot;{self.id()}: raised exception while committing action &#39;{message[&#39;action&#39;][&#39;name&#39;]}&#39;&quot;, e) 387 self.raise_with(e) 388 389 def __commit(self, message: dict): 390 &quot;&quot;&quot; 391 Invokes the action method 392 393 Args: 394 message: The incoming message specifying the action 395 396 Raises: 397 AttributeError: If the action method is not found 398 PermissionError: If the action is not permitted 399 &quot;&quot;&quot; 400 try: 401 # Check if the action method exists 402 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 403 except KeyError: 404 # the action was not found 405 if message[&#39;to&#39;] == &#39;*&#39;: 406 return # broadcasts will not raise an error in this situation 407 else: 408 raise AttributeError( 409 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 410 411 # Check if the action is permitted 412 if not self.__permitted(message): 413 raise PermissionError( 414 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 415 416 self.before_action(message) 417 418 return_value = None 419 error = None 420 try: 421 # Invoke the action method 422 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 423 except Exception as e: 424 error = e 425 raise 426 finally: 427 self.after_action(message, return_value, error) 428 return return_value 429 430 def __permitted(self, message: dict) -&gt; bool: 431 &quot;&quot;&quot; 432 Checks whether the message&#39;s action is allowed 433 &quot;&quot;&quot; 434 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 435 policy = action_method.action_properties[&quot;access_policy&quot;] 436 if policy == ACCESS_PERMITTED: 437 return True 438 elif policy == ACCESS_DENIED: 439 return False 440 elif policy == ACCESS_REQUESTED: 441 return self.request_permission(message) 442 else: 443 raise Exception( 444 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 445 446 def __action_methods(self) -&gt; dict: 447 instance_methods = inspect.getmembers(self, inspect.ismethod) 448 action_methods = { 449 method_name: method 450 for method_name, method in instance_methods 451 if hasattr(method, &quot;action_properties&quot;) 452 } 453 return action_methods 454 455 def __action_method(self, action_name: str): 456 &quot;&quot;&quot; 457 Returns the method for the given action name. 458 &quot;&quot;&quot; 459 action_methods = self.__action_methods() 460 return action_methods[action_name] 461 462 def _find_message(self, message_id: str) -&gt; Message: 463 &quot;&quot;&quot; 464 Returns a message from the log with the given ID. 465 466 Args: 467 message_id: The ID of the message 468 469 Returns: 470 The message or None if not found 471 &quot;&quot;&quot; 472 for message in self._message_log: 473 if message[&quot;meta&quot;][&quot;id&quot;] == message_id: 474 return message 475 476 def current_message(self) -&gt; Message: 477 &quot;&quot;&quot; 478 Returns the full incoming message which invoked the current action. 479 480 This method may be called within an action or action related callback to 481 retrieve the current message, for example to determine the sender or 482 inspect other details. 483 484 Returns: 485 The current message 486 &quot;&quot;&quot; 487 return self.__thread_local_current_message.value 488 489 def parent_message(self, message: Message = None) -&gt; Message: 490 &quot;&quot;&quot; 491 Returns the message that the given message is responding to, if any. 492 493 This method may be used within the handle_action_value and 494 handle_action_error callbacks. 495 496 Args: 497 message: The message to get the parent message of. Defaults to the 498 current message. 499 500 Returns: 501 The parent message or None 502 &quot;&quot;&quot; 503 if message is None: 504 message = self.current_message() 505 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 506 if parent_id is not None: 507 return self._find_message(parent_id) 508 509 @action 510 def help(self, action_name: str = None) -&gt; dict: 511 &quot;&quot;&quot; 512 Returns a list of actions on this agent. 513 514 If action_name is passed, returns a list with only that action. 515 If no action_name is passed, returns all actions. 516 517 Args: 518 action_name: (Optional) The name of an action to request help for 519 520 Returns: 521 A dictionary of actions 522 &quot;&quot;&quot; 523 self.respond_with(self._help(action_name)) 524 525 def _help(self, action_name: str = None) -&gt; dict: 526 &quot;&quot;&quot; 527 Generates the help information returned by the help() action 528 &quot;&quot;&quot; 529 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME] 530 help_list = { 531 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 532 for method in self.__action_methods().values() 533 if action_name is None 534 and method.action_properties[&quot;name&quot;] not in special_actions 535 or method.action_properties[&quot;name&quot;] == action_name 536 } 537 return help_list 538 539 def handle_action_value(self, value): 540 &quot;&quot;&quot; 541 Receives a return value from a previous action. 542 543 This method receives return values from actions invoked by the send() 544 method. It is not called when using the request() method, which returns 545 the value directly. 546 547 To inspect the full response message carrying this value, use 548 current_message(). To inspect the message which returned the value, use 549 parent_message(). 550 551 Args: 552 value: 553 The return value 554 &quot;&quot;&quot; 555 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 556 self._issued_handle_action_value_warning = True 557 log(&quot;warning&quot;, 558 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 559 560 def handle_action_error(self, error: ActionError): 561 &quot;&quot;&quot; 562 Receives an error from a previous action. 563 564 This method receives errors from actions invoked by the send() method. 565 It is not called when using the request() method, which raises an error 566 directly. 567 568 To inspect the full response message carrying this error, use 569 current_message(). To inspect the message which caused the error, use 570 parent_message(). 571 572 Args: 573 error: The error 574 &quot;&quot;&quot; 575 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 576 self._issued_handle_action_error_warning = True 577 log(&quot;warning&quot;, 578 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 579 580 def after_add(self): 581 &quot;&quot;&quot; 582 Called after the agent is added to a space, but before it begins 583 processing incoming messages. 584 585 The agent may send messages during this callback using the send() 586 method, but may not use the request() method since it relies on 587 processing incoming messages. 588 &quot;&quot;&quot; 589 590 def before_remove(self): 591 &quot;&quot;&quot; 592 Called before the agent is removed from a space, after it has finished 593 processing incoming messages. 594 595 The agent may send final messages during this callback using the send() 596 method, but may not use the request() method since it relies on 597 processing incoming messages. 598 &quot;&quot;&quot; 599 600 def before_action(self, message: dict): 601 &quot;&quot;&quot; 602 Called before every action. 603 604 This method will only be called if the action exists and is permitted. 605 606 Args: 607 message: The received message that contains the action 608 &quot;&quot;&quot; 609 610 def after_action(self, message: dict, return_value: str, error: str): 611 &quot;&quot;&quot; 612 Called after every action, regardless of whether an error occurred. 613 614 Args: 615 message: The message which invoked the action 616 return_value: The return value from the action 617 error: The error from the action if any 618 &quot;&quot;&quot; 619 620 def request_permission(self, proposed_message: dict) -&gt; bool: 621 &quot;&quot;&quot; 622 Receives a proposed action message and presents it to the agent for 623 review. 624 625 Args: 626 proposed_message: The proposed action message 627 628 Returns: 629 True if access should be permitted 630 &quot;&quot;&quot; 631 raise NotImplementedError( 632 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . ACCESS_PERMITTED = &#39;ACCESS_PERMITTED&#39; ACCESS_DENIED = &#39;ACCESS_DENIED&#39; ACCESS_REQUESTED = &#39;ACCESS_REQUESTED&#39; def action(*args, **kwargs): View Source 114def action(*args, **kwargs): 115 &quot;&quot;&quot; 116 Declares instance methods as actions making them accessible to other agents. 117 118 Keyword arguments: 119 name: The name of the action. Defaults to the name of the method. 120 help: The help object. Defaults to a generated object. 121 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 122 &quot;&quot;&quot; 123 def decorator(method): 124 action_name = kwargs.get(&quot;name&quot;, method.__name__) 125 if action_name == _RESPONSE_ACTION_NAME: 126 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 127 method.action_properties: dict = { 128 &quot;name&quot;: method.__name__, 129 &quot;help&quot;: _generate_help(method), 130 &quot;access_policy&quot;: ACCESS_PERMITTED, 131 **kwargs, 132 } 133 return method 134 135 if len(args) == 1 and callable(args[0]) and not kwargs: 136 return decorator(args[0]) # The decorator was used without parentheses 137 else: 138 return decorator # The decorator was used with parentheses . Declares instance methods as actions making them accessible to other agents. Keyword arguments: . name: The name of the action. Defaults to the name of the method. help: The help object. Defaults to a generated object. access_policy: The access policy. Defaults to ACCESS_PERMITTED. class ActionError(builtins.Exception): View Source 141class ActionError(Exception): 142 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; . Raised from the request() method if the action responds with an error . Inherited Members . builtins.Exception Exception builtins.BaseException with_traceback args class Agent: View Source 145class Agent(): 146 &quot;&quot;&quot; 147 An Actor that may represent an AI agent, software interface, or human user 148 &quot;&quot;&quot; 149 150 def __init__(self, id: str, receive_own_broadcasts: bool = True): 151 &quot;&quot;&quot; 152 Initializes an Agent. 153 154 This constructor is not meant to be called directly. It is invoked by 155 the Space class when adding an agent. 156 157 Subclasses should call super().__init__() in their constructor. 158 159 Args: 160 id: The id of the agent 161 receive_own_broadcasts: 162 Whether the agent will receive its own broadcasts. Defaults to 163 True 164 &quot;&quot;&quot; 165 if len(id) &lt; 1 or len(id) &gt; 255: 166 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 167 if re.match(r&quot;^amq\\.&quot;, id): 168 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 169 if id == &quot;*&quot;: 170 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 171 self._id: str = id 172 self._receive_own_broadcasts: bool = receive_own_broadcasts 173 # --- non-constructor properties set by Space/Processor --- 174 self._outbound_queue: Queue = None 175 self._is_processing: bool = False 176 # --- non-constructor properties --- 177 self._message_log: List[Message] = [] 178 self._message_log_lock: threading.Lock = threading.Lock() 179 self._pending_requests: Dict[str, Union[threading.Event, Message]] = {} 180 self._pending_requests_lock: threading.Lock = threading.Lock() 181 self.__thread_local_current_message = threading.local() 182 self.__thread_local_current_message.value: Message = None 183 184 def id(self) -&gt; str: 185 return self._id 186 187 def send(self, message: dict) -&gt; str: 188 &quot;&quot;&quot; 189 Sends (out) a message from this agent. 190 191 Args: 192 message: The message 193 194 Returns: 195 The meta.id of the sent message 196 197 Raises: 198 TypeError: If the message is not a dict 199 ValueError: If the message is invalid 200 &quot;&quot;&quot; 201 if not isinstance(message, dict): 202 raise TypeError(&quot;message must be a dict&quot;) 203 if &quot;from&quot; in message and message[&quot;from&quot;] != self.id(): 204 raise ValueError( 205 f&quot;&#39;from&#39; field value &#39;{message[&#39;from&#39;]}&#39; does not match this agent&#39;s id.&quot;) 206 message[&quot;from&quot;] = self.id() 207 message[&quot;meta&quot;] = { 208 &quot;id&quot;: uuid.uuid4().__str__(), 209 **message.get(&quot;meta&quot;, {}), 210 } 211 message = Message(**message).dict(by_alias=True, exclude_unset=True) 212 with self._message_log_lock: 213 log(&quot;info&quot;, f&quot;{self._id}: sending&quot;, message) 214 self._message_log.append(message) 215 self._outbound_queue.put(message) 216 return message[&quot;meta&quot;][&quot;id&quot;] 217 218 def request(self, message: dict, timeout: float = 3) -&gt; object: 219 &quot;&quot;&quot; 220 Synchronously sends a message then waits for and returns the return 221 value of the invoked action. 222 223 This method allows you to call an action synchronously like a function 224 and receive its return value in python. If the action raises an 225 exception an ActionError will be raised containing the error message. 226 227 Args: 228 message: The message to send 229 timeout: 230 The timeout in seconds to wait for the returned value. 231 Defaults to 3 seconds. 232 233 Returns: 234 object: The return value of the action. 235 236 Raises: 237 TimeoutError: If the timeout is reached 238 ActionError: If the action raised an exception 239 RuntimeError: 240 If called before the agent is processing incoming messages 241 &quot;&quot;&quot; 242 if not self._is_processing: 243 raise RuntimeError( 244 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 245 246 # Send and mark the request as pending 247 with self._pending_requests_lock: 248 request_id = self.send(message) 249 self._pending_requests[request_id] = threading.Event() 250 251 # Wait for response 252 if not self._pending_requests[request_id].wait(timeout=timeout): 253 raise TimeoutError 254 255 with self._pending_requests_lock: 256 response_message = self._pending_requests.pop(request_id) 257 258 # Raise error or return value from response 259 if response_message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 260 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 261 262 if response_message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 263 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 264 265 raise RuntimeError(&quot;We should never get here&quot;) 266 267 def respond_with(self, value): 268 &quot;&quot;&quot; 269 Sends a response with the given value. 270 271 Parameters: 272 value (any): The value to be sent in the response message. 273 &quot;&quot;&quot; 274 self.send({ 275 &quot;meta&quot;: { 276 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;] 277 }, 278 &quot;to&quot;: self.current_message()[&#39;from&#39;], 279 &quot;action&quot;: { 280 &quot;name&quot;: _RESPONSE_ACTION_NAME, 281 &quot;args&quot;: { 282 &quot;value&quot;: value, 283 } 284 } 285 }) 286 287 def raise_with(self, error: Exception): 288 &quot;&quot;&quot; 289 Sends an error response. 290 291 Args: 292 error (Exception): The error to send. 293 &quot;&quot;&quot; 294 self.send({ 295 &quot;meta&quot;: { 296 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;], 297 }, 298 &quot;to&quot;: self.current_message()[&#39;from&#39;], 299 &quot;action&quot;: { 300 &quot;name&quot;: _ERROR_ACTION_NAME, 301 &quot;args&quot;: { 302 &quot;error&quot;: f&quot;{error.__class__.__name__}: {error}&quot; 303 } 304 } 305 }) 306 307 def _receive(self, message: dict): 308 &quot;&quot;&quot; 309 Receives and handles an incoming message. 310 311 Args: 312 message: The incoming message 313 &quot;&quot;&quot; 314 try: 315 # Ignore own broadcasts if _receive_own_broadcasts is false 316 if not self._receive_own_broadcasts \\ 317 and message[&#39;from&#39;] == self.id() \\ 318 and message[&#39;to&#39;] == &#39;*&#39;: 319 return 320 321 log(&quot;debug&quot;, f&quot;{self.id()}: received message&quot;, message) 322 323 # Record the received message before handling 324 with self._message_log_lock: 325 self._message_log.append(message) 326 327 # Handle incoming responses 328 # TODO: make serial/fan-out optional 329 if message[&quot;action&quot;][&quot;name&quot;] in [_RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME]: 330 parent_id = message[&quot;meta&quot;][&quot;parent_id&quot;] 331 if parent_id in self._pending_requests.keys(): 332 # This was a response to a request(). We use a little trick 333 # here and simply swap out the event that is waiting with 334 # the message, then set the event. The request() method will 335 # pick up the response message in the existing thread. 336 event = self._pending_requests[parent_id] 337 self._pending_requests[parent_id] = message 338 event.set() 339 else: 340 # This was a response to a send() 341 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 342 handler_callback = self.handle_action_value 343 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 344 elif message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 345 handler_callback = self.handle_action_error 346 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 347 else: 348 raise RuntimeError(&quot;Unknown action response&quot;) 349 350 # Spawn a thread to handle the response 351 def __process_response(arg, current_message): 352 self.__thread_local_current_message.value = current_message 353 handler_callback(arg) 354 355 threading.Thread( 356 target=__process_response, 357 args=(arg, message, ), 358 daemon=True, 359 name=f&quot;{self.id()} response handler {message[&#39;meta&#39;][&#39;id&#39;]}&quot;, 360 ).start() 361 362 # Handle all other messages 363 else: 364 # Spawn a thread to process the message. This means that messages 365 # are processed concurrently, but may be processed out of order. 366 threading.Thread( 367 target=self.__process, 368 args=(message,), 369 daemon=True, 370 name=f&quot;{self.id()} message handler {message[&#39;meta&#39;][&#39;id&#39;]}&quot;, 371 ).start() 372 except Exception as e: 373 log(&quot;error&quot;, f&quot;{self.id()}: raised exception in _receive&quot;, e) 374 375 def __process(self, message: dict): 376 &quot;&quot;&quot; 377 Top level method within the action processing thread. 378 &quot;&quot;&quot; 379 self.__thread_local_current_message.value = message 380 try: 381 log(&quot;debug&quot;, f&quot;{self.id()}: committing action&quot;, message) 382 self.__commit(message) 383 except Exception as e: 384 # Handle errors (including PermissionError) that occur while 385 # committing an action by reporting back to the sender. 386 log(&quot;warning&quot;, 387 f&quot;{self.id()}: raised exception while committing action &#39;{message[&#39;action&#39;][&#39;name&#39;]}&#39;&quot;, e) 388 self.raise_with(e) 389 390 def __commit(self, message: dict): 391 &quot;&quot;&quot; 392 Invokes the action method 393 394 Args: 395 message: The incoming message specifying the action 396 397 Raises: 398 AttributeError: If the action method is not found 399 PermissionError: If the action is not permitted 400 &quot;&quot;&quot; 401 try: 402 # Check if the action method exists 403 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 404 except KeyError: 405 # the action was not found 406 if message[&#39;to&#39;] == &#39;*&#39;: 407 return # broadcasts will not raise an error in this situation 408 else: 409 raise AttributeError( 410 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 411 412 # Check if the action is permitted 413 if not self.__permitted(message): 414 raise PermissionError( 415 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 416 417 self.before_action(message) 418 419 return_value = None 420 error = None 421 try: 422 # Invoke the action method 423 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 424 except Exception as e: 425 error = e 426 raise 427 finally: 428 self.after_action(message, return_value, error) 429 return return_value 430 431 def __permitted(self, message: dict) -&gt; bool: 432 &quot;&quot;&quot; 433 Checks whether the message&#39;s action is allowed 434 &quot;&quot;&quot; 435 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 436 policy = action_method.action_properties[&quot;access_policy&quot;] 437 if policy == ACCESS_PERMITTED: 438 return True 439 elif policy == ACCESS_DENIED: 440 return False 441 elif policy == ACCESS_REQUESTED: 442 return self.request_permission(message) 443 else: 444 raise Exception( 445 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 446 447 def __action_methods(self) -&gt; dict: 448 instance_methods = inspect.getmembers(self, inspect.ismethod) 449 action_methods = { 450 method_name: method 451 for method_name, method in instance_methods 452 if hasattr(method, &quot;action_properties&quot;) 453 } 454 return action_methods 455 456 def __action_method(self, action_name: str): 457 &quot;&quot;&quot; 458 Returns the method for the given action name. 459 &quot;&quot;&quot; 460 action_methods = self.__action_methods() 461 return action_methods[action_name] 462 463 def _find_message(self, message_id: str) -&gt; Message: 464 &quot;&quot;&quot; 465 Returns a message from the log with the given ID. 466 467 Args: 468 message_id: The ID of the message 469 470 Returns: 471 The message or None if not found 472 &quot;&quot;&quot; 473 for message in self._message_log: 474 if message[&quot;meta&quot;][&quot;id&quot;] == message_id: 475 return message 476 477 def current_message(self) -&gt; Message: 478 &quot;&quot;&quot; 479 Returns the full incoming message which invoked the current action. 480 481 This method may be called within an action or action related callback to 482 retrieve the current message, for example to determine the sender or 483 inspect other details. 484 485 Returns: 486 The current message 487 &quot;&quot;&quot; 488 return self.__thread_local_current_message.value 489 490 def parent_message(self, message: Message = None) -&gt; Message: 491 &quot;&quot;&quot; 492 Returns the message that the given message is responding to, if any. 493 494 This method may be used within the handle_action_value and 495 handle_action_error callbacks. 496 497 Args: 498 message: The message to get the parent message of. Defaults to the 499 current message. 500 501 Returns: 502 The parent message or None 503 &quot;&quot;&quot; 504 if message is None: 505 message = self.current_message() 506 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 507 if parent_id is not None: 508 return self._find_message(parent_id) 509 510 @action 511 def help(self, action_name: str = None) -&gt; dict: 512 &quot;&quot;&quot; 513 Returns a list of actions on this agent. 514 515 If action_name is passed, returns a list with only that action. 516 If no action_name is passed, returns all actions. 517 518 Args: 519 action_name: (Optional) The name of an action to request help for 520 521 Returns: 522 A dictionary of actions 523 &quot;&quot;&quot; 524 self.respond_with(self._help(action_name)) 525 526 def _help(self, action_name: str = None) -&gt; dict: 527 &quot;&quot;&quot; 528 Generates the help information returned by the help() action 529 &quot;&quot;&quot; 530 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME] 531 help_list = { 532 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 533 for method in self.__action_methods().values() 534 if action_name is None 535 and method.action_properties[&quot;name&quot;] not in special_actions 536 or method.action_properties[&quot;name&quot;] == action_name 537 } 538 return help_list 539 540 def handle_action_value(self, value): 541 &quot;&quot;&quot; 542 Receives a return value from a previous action. 543 544 This method receives return values from actions invoked by the send() 545 method. It is not called when using the request() method, which returns 546 the value directly. 547 548 To inspect the full response message carrying this value, use 549 current_message(). To inspect the message which returned the value, use 550 parent_message(). 551 552 Args: 553 value: 554 The return value 555 &quot;&quot;&quot; 556 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 557 self._issued_handle_action_value_warning = True 558 log(&quot;warning&quot;, 559 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 560 561 def handle_action_error(self, error: ActionError): 562 &quot;&quot;&quot; 563 Receives an error from a previous action. 564 565 This method receives errors from actions invoked by the send() method. 566 It is not called when using the request() method, which raises an error 567 directly. 568 569 To inspect the full response message carrying this error, use 570 current_message(). To inspect the message which caused the error, use 571 parent_message(). 572 573 Args: 574 error: The error 575 &quot;&quot;&quot; 576 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 577 self._issued_handle_action_error_warning = True 578 log(&quot;warning&quot;, 579 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 580 581 def after_add(self): 582 &quot;&quot;&quot; 583 Called after the agent is added to a space, but before it begins 584 processing incoming messages. 585 586 The agent may send messages during this callback using the send() 587 method, but may not use the request() method since it relies on 588 processing incoming messages. 589 &quot;&quot;&quot; 590 591 def before_remove(self): 592 &quot;&quot;&quot; 593 Called before the agent is removed from a space, after it has finished 594 processing incoming messages. 595 596 The agent may send final messages during this callback using the send() 597 method, but may not use the request() method since it relies on 598 processing incoming messages. 599 &quot;&quot;&quot; 600 601 def before_action(self, message: dict): 602 &quot;&quot;&quot; 603 Called before every action. 604 605 This method will only be called if the action exists and is permitted. 606 607 Args: 608 message: The received message that contains the action 609 &quot;&quot;&quot; 610 611 def after_action(self, message: dict, return_value: str, error: str): 612 &quot;&quot;&quot; 613 Called after every action, regardless of whether an error occurred. 614 615 Args: 616 message: The message which invoked the action 617 return_value: The return value from the action 618 error: The error from the action if any 619 &quot;&quot;&quot; 620 621 def request_permission(self, proposed_message: dict) -&gt; bool: 622 &quot;&quot;&quot; 623 Receives a proposed action message and presents it to the agent for 624 review. 625 626 Args: 627 proposed_message: The proposed action message 628 629 Returns: 630 True if access should be permitted 631 &quot;&quot;&quot; 632 raise NotImplementedError( 633 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . An Actor that may represent an AI agent, software interface, or human user . Agent(id: str, receive_own_broadcasts: bool = True) View Source 150 def __init__(self, id: str, receive_own_broadcasts: bool = True): 151 &quot;&quot;&quot; 152 Initializes an Agent. 153 154 This constructor is not meant to be called directly. It is invoked by 155 the Space class when adding an agent. 156 157 Subclasses should call super().__init__() in their constructor. 158 159 Args: 160 id: The id of the agent 161 receive_own_broadcasts: 162 Whether the agent will receive its own broadcasts. Defaults to 163 True 164 &quot;&quot;&quot; 165 if len(id) &lt; 1 or len(id) &gt; 255: 166 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 167 if re.match(r&quot;^amq\\.&quot;, id): 168 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 169 if id == &quot;*&quot;: 170 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 171 self._id: str = id 172 self._receive_own_broadcasts: bool = receive_own_broadcasts 173 # --- non-constructor properties set by Space/Processor --- 174 self._outbound_queue: Queue = None 175 self._is_processing: bool = False 176 # --- non-constructor properties --- 177 self._message_log: List[Message] = [] 178 self._message_log_lock: threading.Lock = threading.Lock() 179 self._pending_requests: Dict[str, Union[threading.Event, Message]] = {} 180 self._pending_requests_lock: threading.Lock = threading.Lock() 181 self.__thread_local_current_message = threading.local() 182 self.__thread_local_current_message.value: Message = None . Initializes an Agent. This constructor is not meant to be called directly. It is invoked by the Space class when adding an agent. Subclasses should call super().__init__() in their constructor. Arguments: . | id: The id of the agent | receive_own_broadcasts: Whether the agent will receive its own broadcasts. Defaults to True | . def id(self) -> str: View Source 184 def id(self) -&gt; str: 185 return self._id . def send(self, message: dict) -> str: View Source 187 def send(self, message: dict) -&gt; str: 188 &quot;&quot;&quot; 189 Sends (out) a message from this agent. 190 191 Args: 192 message: The message 193 194 Returns: 195 The meta.id of the sent message 196 197 Raises: 198 TypeError: If the message is not a dict 199 ValueError: If the message is invalid 200 &quot;&quot;&quot; 201 if not isinstance(message, dict): 202 raise TypeError(&quot;message must be a dict&quot;) 203 if &quot;from&quot; in message and message[&quot;from&quot;] != self.id(): 204 raise ValueError( 205 f&quot;&#39;from&#39; field value &#39;{message[&#39;from&#39;]}&#39; does not match this agent&#39;s id.&quot;) 206 message[&quot;from&quot;] = self.id() 207 message[&quot;meta&quot;] = { 208 &quot;id&quot;: uuid.uuid4().__str__(), 209 **message.get(&quot;meta&quot;, {}), 210 } 211 message = Message(**message).dict(by_alias=True, exclude_unset=True) 212 with self._message_log_lock: 213 log(&quot;info&quot;, f&quot;{self._id}: sending&quot;, message) 214 self._message_log.append(message) 215 self._outbound_queue.put(message) 216 return message[&quot;meta&quot;][&quot;id&quot;] . Sends (out) a message from this agent. Arguments: . | message: The message | . Returns: . The meta.id of the sent message . Raises: . | TypeError: If the message is not a dict | ValueError: If the message is invalid | . def request(self, message: dict, timeout: float = 3) -> object: View Source 218 def request(self, message: dict, timeout: float = 3) -&gt; object: 219 &quot;&quot;&quot; 220 Synchronously sends a message then waits for and returns the return 221 value of the invoked action. 222 223 This method allows you to call an action synchronously like a function 224 and receive its return value in python. If the action raises an 225 exception an ActionError will be raised containing the error message. 226 227 Args: 228 message: The message to send 229 timeout: 230 The timeout in seconds to wait for the returned value. 231 Defaults to 3 seconds. 232 233 Returns: 234 object: The return value of the action. 235 236 Raises: 237 TimeoutError: If the timeout is reached 238 ActionError: If the action raised an exception 239 RuntimeError: 240 If called before the agent is processing incoming messages 241 &quot;&quot;&quot; 242 if not self._is_processing: 243 raise RuntimeError( 244 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 245 246 # Send and mark the request as pending 247 with self._pending_requests_lock: 248 request_id = self.send(message) 249 self._pending_requests[request_id] = threading.Event() 250 251 # Wait for response 252 if not self._pending_requests[request_id].wait(timeout=timeout): 253 raise TimeoutError 254 255 with self._pending_requests_lock: 256 response_message = self._pending_requests.pop(request_id) 257 258 # Raise error or return value from response 259 if response_message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 260 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 261 262 if response_message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 263 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 264 265 raise RuntimeError(&quot;We should never get here&quot;) . Synchronously sends a message then waits for and returns the return value of the invoked action. This method allows you to call an action synchronously like a function and receive its return value in python. If the action raises an exception an ActionError will be raised containing the error message. Arguments: . | message: The message to send | timeout: The timeout in seconds to wait for the returned value. Defaults to 3 seconds. | . Returns: . object: The return value of the action. Raises: . | TimeoutError: If the timeout is reached | ActionError: If the action raised an exception | RuntimeError: If called before the agent is processing incoming messages | . def respond_with(self, value): View Source 267 def respond_with(self, value): 268 &quot;&quot;&quot; 269 Sends a response with the given value. 270 271 Parameters: 272 value (any): The value to be sent in the response message. 273 &quot;&quot;&quot; 274 self.send({ 275 &quot;meta&quot;: { 276 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;] 277 }, 278 &quot;to&quot;: self.current_message()[&#39;from&#39;], 279 &quot;action&quot;: { 280 &quot;name&quot;: _RESPONSE_ACTION_NAME, 281 &quot;args&quot;: { 282 &quot;value&quot;: value, 283 } 284 } 285 }) . Sends a response with the given value. Arguments: . | value (any): The value to be sent in the response message. | . def raise_with(self, error: Exception): View Source 287 def raise_with(self, error: Exception): 288 &quot;&quot;&quot; 289 Sends an error response. 290 291 Args: 292 error (Exception): The error to send. 293 &quot;&quot;&quot; 294 self.send({ 295 &quot;meta&quot;: { 296 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;], 297 }, 298 &quot;to&quot;: self.current_message()[&#39;from&#39;], 299 &quot;action&quot;: { 300 &quot;name&quot;: _ERROR_ACTION_NAME, 301 &quot;args&quot;: { 302 &quot;error&quot;: f&quot;{error.__class__.__name__}: {error}&quot; 303 } 304 } 305 }) . Sends an error response. Arguments: . | error (Exception): The error to send. | . def current_message(self) -> agency.schema.Message: View Source 477 def current_message(self) -&gt; Message: 478 &quot;&quot;&quot; 479 Returns the full incoming message which invoked the current action. 480 481 This method may be called within an action or action related callback to 482 retrieve the current message, for example to determine the sender or 483 inspect other details. 484 485 Returns: 486 The current message 487 &quot;&quot;&quot; 488 return self.__thread_local_current_message.value . Returns the full incoming message which invoked the current action. This method may be called within an action or action related callback to retrieve the current message, for example to determine the sender or inspect other details. Returns: . The current message . def parent_message(self, message: agency.schema.Message = None) -> agency.schema.Message: View Source 490 def parent_message(self, message: Message = None) -&gt; Message: 491 &quot;&quot;&quot; 492 Returns the message that the given message is responding to, if any. 493 494 This method may be used within the handle_action_value and 495 handle_action_error callbacks. 496 497 Args: 498 message: The message to get the parent message of. Defaults to the 499 current message. 500 501 Returns: 502 The parent message or None 503 &quot;&quot;&quot; 504 if message is None: 505 message = self.current_message() 506 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 507 if parent_id is not None: 508 return self._find_message(parent_id) . Returns the message that the given message is responding to, if any. This method may be used within the handle_action_value and handle_action_error callbacks. Arguments: . | message: The message to get the parent message of. Defaults to the | current message. | . Returns: . The parent message or None . @action def help(self, action_name: str = None) -> dict: View Source 510 @action 511 def help(self, action_name: str = None) -&gt; dict: 512 &quot;&quot;&quot; 513 Returns a list of actions on this agent. 514 515 If action_name is passed, returns a list with only that action. 516 If no action_name is passed, returns all actions. 517 518 Args: 519 action_name: (Optional) The name of an action to request help for 520 521 Returns: 522 A dictionary of actions 523 &quot;&quot;&quot; 524 self.respond_with(self._help(action_name)) . Returns a list of actions on this agent. If action_name is passed, returns a list with only that action. If no action_name is passed, returns all actions. Arguments: . | action_name: (Optional) The name of an action to request help for | . Returns: . A dictionary of actions . def handle_action_value(self, value): View Source 540 def handle_action_value(self, value): 541 &quot;&quot;&quot; 542 Receives a return value from a previous action. 543 544 This method receives return values from actions invoked by the send() 545 method. It is not called when using the request() method, which returns 546 the value directly. 547 548 To inspect the full response message carrying this value, use 549 current_message(). To inspect the message which returned the value, use 550 parent_message(). 551 552 Args: 553 value: 554 The return value 555 &quot;&quot;&quot; 556 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 557 self._issued_handle_action_value_warning = True 558 log(&quot;warning&quot;, 559 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) . Receives a return value from a previous action. This method receives return values from actions invoked by the send() method. It is not called when using the request() method, which returns the value directly. To inspect the full response message carrying this value, use current_message(). To inspect the message which returned the value, use parent_message(). Arguments: . | value: The return value | . def handle_action_error(self, error: ActionError): View Source 561 def handle_action_error(self, error: ActionError): 562 &quot;&quot;&quot; 563 Receives an error from a previous action. 564 565 This method receives errors from actions invoked by the send() method. 566 It is not called when using the request() method, which raises an error 567 directly. 568 569 To inspect the full response message carrying this error, use 570 current_message(). To inspect the message which caused the error, use 571 parent_message(). 572 573 Args: 574 error: The error 575 &quot;&quot;&quot; 576 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 577 self._issued_handle_action_error_warning = True 578 log(&quot;warning&quot;, 579 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) . Receives an error from a previous action. This method receives errors from actions invoked by the send() method. It is not called when using the request() method, which raises an error directly. To inspect the full response message carrying this error, use current_message(). To inspect the message which caused the error, use parent_message(). Arguments: . | error: The error | . def after_add(self): View Source 581 def after_add(self): 582 &quot;&quot;&quot; 583 Called after the agent is added to a space, but before it begins 584 processing incoming messages. 585 586 The agent may send messages during this callback using the send() 587 method, but may not use the request() method since it relies on 588 processing incoming messages. 589 &quot;&quot;&quot; . Called after the agent is added to a space, but before it begins processing incoming messages. The agent may send messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_remove(self): View Source 591 def before_remove(self): 592 &quot;&quot;&quot; 593 Called before the agent is removed from a space, after it has finished 594 processing incoming messages. 595 596 The agent may send final messages during this callback using the send() 597 method, but may not use the request() method since it relies on 598 processing incoming messages. 599 &quot;&quot;&quot; . Called before the agent is removed from a space, after it has finished processing incoming messages. The agent may send final messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_action(self, message: dict): View Source 601 def before_action(self, message: dict): 602 &quot;&quot;&quot; 603 Called before every action. 604 605 This method will only be called if the action exists and is permitted. 606 607 Args: 608 message: The received message that contains the action 609 &quot;&quot;&quot; . Called before every action. This method will only be called if the action exists and is permitted. Arguments: . | message: The received message that contains the action | . def after_action(self, message: dict, return_value: str, error: str): View Source 611 def after_action(self, message: dict, return_value: str, error: str): 612 &quot;&quot;&quot; 613 Called after every action, regardless of whether an error occurred. 614 615 Args: 616 message: The message which invoked the action 617 return_value: The return value from the action 618 error: The error from the action if any 619 &quot;&quot;&quot; . Called after every action, regardless of whether an error occurred. Arguments: . | message: The message which invoked the action | return_value: The return value from the action | error: The error from the action if any | . def request_permission(self, proposed_message: dict) -> bool: View Source 621 def request_permission(self, proposed_message: dict) -&gt; bool: 622 &quot;&quot;&quot; 623 Receives a proposed action message and presents it to the agent for 624 review. 625 626 Args: 627 proposed_message: The proposed action message 628 629 Returns: 630 True if access should be permitted 631 &quot;&quot;&quot; 632 raise NotImplementedError( 633 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . Receives a proposed action message and presents it to the agent for review. Arguments: . | proposed_message: The proposed action message | . Returns: . True if access should be permitted . ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"33": {
    "doc": "agency.agent",
    "title": "agency.agent",
    "content": " ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"34": {
    "doc": "agency.logger",
    "title": "\nagency.logger    ",
    "content": "View Source 1import json 2import logging 3import os 4import traceback 5 6import colorlog 7from colorlog.escape_codes import escape_codes 8from pygments import highlight 9from pygments.formatters import Terminal256Formatter 10from pygments.lexers import get_lexer_by_name 11 12_LOGLEVELS = { 13 &#39;CRITICAL&#39;: 50, 14 &#39;ERROR&#39;: 40, 15 &#39;WARNING&#39;: 30, 16 &#39;INFO&#39;: 20, 17 &#39;DEBUG&#39;: 10, 18 &#39;NOTSET&#39;: 0 19} 20 21_env_loglevel = os.environ.get(&#39;LOGLEVEL&#39;, &#39;WARNING&#39;).upper() 22_LOGLEVEL = _LOGLEVELS[_env_loglevel] 23_LOGFORMAT = &#39;%(asctime_color)s%(asctime)s%(reset_color)s - %(levelname_color)s%(levelname)s%(reset_color)s - %(message_color)s%(message)s%(reset_color)s%(object_color)s%(object)s%(reset_color)s&#39; 24_LOG_PYGMENTS_STYLE = os.environ.get(&#39;LOG_PYGMENTS_STYLE&#39;, &#39;monokai&#39;) 25 26 27class CustomColoredFormatter(colorlog.ColoredFormatter): 28 def format(self, record): 29 record.reset_color = escape_codes[&#39;reset&#39;] 30 record.asctime_color = escape_codes[&#39;light_black&#39;] 31 record.levelname_color = escape_codes[self.log_colors[record.levelname]] 32 record.message_color = escape_codes[&#39;reset&#39;] 33 record.object_color = escape_codes[&#39;reset&#39;] 34 35 return super().format(record) 36 37 38_logger = logging.getLogger(&quot;agency&quot;) 39_logger.setLevel(_LOGLEVEL) 40_handler = logging.StreamHandler() 41_handler.setLevel(_LOGLEVEL) 42 43_formatter = CustomColoredFormatter( 44 _LOGFORMAT, 45 log_colors={ 46 &#39;CRITICAL&#39;: &#39;bold_red&#39;, 47 &#39;ERROR&#39;: &#39;red&#39;, 48 &#39;WARNING&#39;: &#39;yellow&#39;, 49 &#39;INFO&#39;: &#39;green&#39;, 50 &#39;DEBUG&#39;: &#39;cyan&#39;, 51 } 52) 53 54_handler.setFormatter(_formatter) 55_logger.addHandler(_handler) 56 57 58class _CustomEncoder(json.JSONEncoder): 59 def default(self, obj): 60 try: 61 return super().default(obj) 62 except TypeError: 63 return str(obj) 64 65 66def log(level: str, message: str, object=None): 67 pretty_object: str = &quot;&quot; 68 if object != None: 69 try: 70 if isinstance(object, Exception): 71 pretty_object = &quot;\\n&quot; + &quot;&quot;.join(traceback.format_exception( 72 etype=type(object), value=object, tb=object.__traceback__)) 73 else: 74 json_str = json.dumps(object, indent=2, cls=_CustomEncoder) 75 pretty_object = &quot;\\n&quot; + \\ 76 highlight(json_str, get_lexer_by_name(&#39;json&#39;), 77 Terminal256Formatter(style=_LOG_PYGMENTS_STYLE)) 78 except: 79 pass 80 81 numeric_level = _LOGLEVELS.get(level.upper()) 82 if numeric_level is not None: 83 _logger.log(numeric_level, message, extra={&#39;object&#39;: pretty_object}) 84 else: 85 raise ValueError(f&quot;Invalid log level: {level}&quot;) . class CustomColoredFormatter(colorlog.formatter.ColoredFormatter): View Source 28class CustomColoredFormatter(colorlog.ColoredFormatter): 29 def format(self, record): 30 record.reset_color = escape_codes[&#39;reset&#39;] 31 record.asctime_color = escape_codes[&#39;light_black&#39;] 32 record.levelname_color = escape_codes[self.log_colors[record.levelname]] 33 record.message_color = escape_codes[&#39;reset&#39;] 34 record.object_color = escape_codes[&#39;reset&#39;] 35 36 return super().format(record) . A formatter that allows colors to be placed in the format string. Intended to help in creating more readable logging output. def format(self, record): View Source 29 def format(self, record): 30 record.reset_color = escape_codes[&#39;reset&#39;] 31 record.asctime_color = escape_codes[&#39;light_black&#39;] 32 record.levelname_color = escape_codes[self.log_colors[record.levelname]] 33 record.message_color = escape_codes[&#39;reset&#39;] 34 record.object_color = escape_codes[&#39;reset&#39;] 35 36 return super().format(record) . Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Inherited Members . colorlog.formatter.ColoredFormatter ColoredFormatter log_colors secondary_log_colors reset stream no_color force_color formatMessage logging.Formatter converter datefmt default_time_format default_msec_format formatTime formatException usesTime formatStack def log(level: str, message: str, object=None): View Source 67def log(level: str, message: str, object=None): 68 pretty_object: str = &quot;&quot; 69 if object != None: 70 try: 71 if isinstance(object, Exception): 72 pretty_object = &quot;\\n&quot; + &quot;&quot;.join(traceback.format_exception( 73 etype=type(object), value=object, tb=object.__traceback__)) 74 else: 75 json_str = json.dumps(object, indent=2, cls=_CustomEncoder) 76 pretty_object = &quot;\\n&quot; + \\ 77 highlight(json_str, get_lexer_by_name(&#39;json&#39;), 78 Terminal256Formatter(style=_LOG_PYGMENTS_STYLE)) 79 except: 80 pass 81 82 numeric_level = _LOGLEVELS.get(level.upper()) 83 if numeric_level is not None: 84 _logger.log(numeric_level, message, extra={&#39;object&#39;: pretty_object}) 85 else: 86 raise ValueError(f&quot;Invalid log level: {level}&quot;) . ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"35": {
    "doc": "agency.logger",
    "title": "agency.logger",
    "content": " ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"36": {
    "doc": "agency.processor",
    "title": "\nagency.processor    ",
    "content": "View Source 1import multiprocessing 2import queue 3import threading 4from abc import ABC, ABCMeta 5from concurrent.futures import (Executor, Future) 6from typing import Dict, List, Protocol, Type 7 8from agency.agent import Agent 9from agency.logger import log 10from agency.queue import Queue 11 12 13class _EventProtocol(Protocol): 14 def set(self) -&gt; None: 15 pass 16 17 def clear(self) -&gt; None: 18 pass 19 20 def is_set(self) -&gt; bool: 21 pass 22 23 def wait(self, timeout: float = None) -&gt; bool: 24 pass 25 26 27class Processor(ABC, metaclass=ABCMeta): 28 &quot;&quot;&quot; 29 Encapsulates a running Agent instance 30 &quot;&quot;&quot; 31 def __init__(self, 32 agent_type: Type[Agent], 33 agent_id: str, 34 agent_args: List, 35 agent_kwargs: Dict, 36 inbound_queue: Queue, 37 outbound_queue: Queue, 38 started: _EventProtocol, 39 stopping: _EventProtocol, 40 new_message_event: _EventProtocol, 41 executor: Executor): 42 self.agent_type: Type[Agent] = agent_type 43 self.agent_id: str = agent_id 44 self.agent_args: List = agent_args 45 self.agent_kwargs: Dict = agent_kwargs 46 self.inbound_queue: Queue = inbound_queue 47 self.outbound_queue: Queue = outbound_queue 48 self.started: _EventProtocol = started 49 self.stopping: _EventProtocol = stopping 50 self.new_message_event: _EventProtocol = new_message_event 51 self.executor: Executor = executor 52 # --- non-constructor properties --- 53 self._future: Future = None 54 self._agent: Agent = None # Accessible if in foreground 55 56 def start(self) -&gt; Agent: 57 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor starting ...&quot;) 58 59 agent_ref: List = [] 60 self._future = self.executor.submit( 61 _process_loop, 62 self.agent_type, 63 self.agent_id, 64 self.agent_args, 65 self.agent_kwargs, 66 self.inbound_queue, 67 self.outbound_queue, 68 self.started, 69 self.stopping, 70 self.new_message_event, 71 agent_ref, 72 ) 73 74 if not self.started.wait(timeout=5): 75 # it couldn&#39;t start, force stop it and raise an exception 76 self.stop() 77 error = self._future.exception() 78 if error is not None: 79 raise error 80 else: 81 raise Exception(&quot;Processor could not be started.&quot;) 82 83 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor started&quot;) 84 85 # return the agent if present. only works in foreground 86 if agent_ref: 87 return agent_ref[0] 88 89 def stop(self): 90 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopping ...&quot;) 91 self.stopping.set() 92 if self._future is not None: 93 self._future.result() 94 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopped&quot;) 95 96 97# Placed at the top-level to play nice with the multiprocessing module 98def _process_loop(agent_type: Type[Agent], 99 agent_id: str, 100 agent_args: List, 101 agent_kwargs: Dict, 102 inbound_queue: Queue, 103 outbound_queue: Queue, 104 started: _EventProtocol, 105 stopping: _EventProtocol, 106 new_message_event: _EventProtocol, 107 agent_ref: List): 108 &quot;&quot;&quot; 109 The main agent processing loop 110 &quot;&quot;&quot; 111 # Set process or thread name 112 if isinstance(started, threading.Event): 113 threading.current_thread( 114 ).name = f&quot;{agent_id}: processor loop thread&quot; 115 else: 116 multiprocessing.current_process( 117 ).name = f&quot;{agent_id}: processor loop process&quot; 118 119 try: 120 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop starting&quot;) 121 agent: Agent = agent_type(agent_id, *agent_args, **agent_kwargs) 122 agent_ref.append(agent) # set the agent reference 123 inbound_queue.connect() 124 outbound_queue.connect() 125 agent._outbound_queue = outbound_queue 126 agent.after_add() 127 agent._is_processing = True 128 started.set() 129 stopping.clear() 130 new_message_event.clear() 131 while not stopping.is_set(): 132 new_message_event.wait(timeout=0.1) # TODO make configurable 133 if stopping.is_set(): 134 log(&quot;debug&quot;, 135 f&quot;{agent_id}: processor loop stopping&quot;) 136 break 137 while True: # drain inbound_queue 138 try: 139 message = inbound_queue.get(block=False) 140 log(&quot;debug&quot;, 141 f&quot;{agent_id}: processor loop got message&quot;, message) 142 agent._receive(message) 143 except queue.Empty: 144 break 145 new_message_event.clear() 146 except KeyboardInterrupt: 147 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop interrupted&quot;) 148 pass 149 except Exception as e: 150 log(&quot;error&quot;, f&quot;{agent_id}: processor loop failed&quot;, e) 151 raise 152 finally: 153 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop cleaning up&quot;) 154 agent._is_processing = False 155 agent.before_remove() 156 inbound_queue.disconnect() 157 outbound_queue.disconnect() 158 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop stopped&quot;) . class Processor(abc.ABC): View Source 28class Processor(ABC, metaclass=ABCMeta): 29 &quot;&quot;&quot; 30 Encapsulates a running Agent instance 31 &quot;&quot;&quot; 32 def __init__(self, 33 agent_type: Type[Agent], 34 agent_id: str, 35 agent_args: List, 36 agent_kwargs: Dict, 37 inbound_queue: Queue, 38 outbound_queue: Queue, 39 started: _EventProtocol, 40 stopping: _EventProtocol, 41 new_message_event: _EventProtocol, 42 executor: Executor): 43 self.agent_type: Type[Agent] = agent_type 44 self.agent_id: str = agent_id 45 self.agent_args: List = agent_args 46 self.agent_kwargs: Dict = agent_kwargs 47 self.inbound_queue: Queue = inbound_queue 48 self.outbound_queue: Queue = outbound_queue 49 self.started: _EventProtocol = started 50 self.stopping: _EventProtocol = stopping 51 self.new_message_event: _EventProtocol = new_message_event 52 self.executor: Executor = executor 53 # --- non-constructor properties --- 54 self._future: Future = None 55 self._agent: Agent = None # Accessible if in foreground 56 57 def start(self) -&gt; Agent: 58 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor starting ...&quot;) 59 60 agent_ref: List = [] 61 self._future = self.executor.submit( 62 _process_loop, 63 self.agent_type, 64 self.agent_id, 65 self.agent_args, 66 self.agent_kwargs, 67 self.inbound_queue, 68 self.outbound_queue, 69 self.started, 70 self.stopping, 71 self.new_message_event, 72 agent_ref, 73 ) 74 75 if not self.started.wait(timeout=5): 76 # it couldn&#39;t start, force stop it and raise an exception 77 self.stop() 78 error = self._future.exception() 79 if error is not None: 80 raise error 81 else: 82 raise Exception(&quot;Processor could not be started.&quot;) 83 84 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor started&quot;) 85 86 # return the agent if present. only works in foreground 87 if agent_ref: 88 return agent_ref[0] 89 90 def stop(self): 91 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopping ...&quot;) 92 self.stopping.set() 93 if self._future is not None: 94 self._future.result() 95 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopped&quot;) . Encapsulates a running Agent instance . Processor( agent_type: Type[agency.agent.Agent], agent_id: str, agent_args: List, agent_kwargs: Dict, inbound_queue: agency.queue.Queue, outbound_queue: agency.queue.Queue, started: agency.processor._EventProtocol, stopping: agency.processor._EventProtocol, new_message_event: agency.processor._EventProtocol, executor: concurrent.futures._base.Executor) View Source 32 def __init__(self, 33 agent_type: Type[Agent], 34 agent_id: str, 35 agent_args: List, 36 agent_kwargs: Dict, 37 inbound_queue: Queue, 38 outbound_queue: Queue, 39 started: _EventProtocol, 40 stopping: _EventProtocol, 41 new_message_event: _EventProtocol, 42 executor: Executor): 43 self.agent_type: Type[Agent] = agent_type 44 self.agent_id: str = agent_id 45 self.agent_args: List = agent_args 46 self.agent_kwargs: Dict = agent_kwargs 47 self.inbound_queue: Queue = inbound_queue 48 self.outbound_queue: Queue = outbound_queue 49 self.started: _EventProtocol = started 50 self.stopping: _EventProtocol = stopping 51 self.new_message_event: _EventProtocol = new_message_event 52 self.executor: Executor = executor 53 # --- non-constructor properties --- 54 self._future: Future = None 55 self._agent: Agent = None # Accessible if in foreground . agent_type: Type[agency.agent.Agent] agent_id: str agent_args: List agent_kwargs: Dict inbound_queue: agency.queue.Queue outbound_queue: agency.queue.Queue started: agency.processor._EventProtocol stopping: agency.processor._EventProtocol new_message_event: agency.processor._EventProtocol executor: concurrent.futures._base.Executor def start(self) -> agency.agent.Agent: View Source 57 def start(self) -&gt; Agent: 58 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor starting ...&quot;) 59 60 agent_ref: List = [] 61 self._future = self.executor.submit( 62 _process_loop, 63 self.agent_type, 64 self.agent_id, 65 self.agent_args, 66 self.agent_kwargs, 67 self.inbound_queue, 68 self.outbound_queue, 69 self.started, 70 self.stopping, 71 self.new_message_event, 72 agent_ref, 73 ) 74 75 if not self.started.wait(timeout=5): 76 # it couldn&#39;t start, force stop it and raise an exception 77 self.stop() 78 error = self._future.exception() 79 if error is not None: 80 raise error 81 else: 82 raise Exception(&quot;Processor could not be started.&quot;) 83 84 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor started&quot;) 85 86 # return the agent if present. only works in foreground 87 if agent_ref: 88 return agent_ref[0] . def stop(self): View Source 90 def stop(self): 91 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopping ...&quot;) 92 self.stopping.set() 93 if self._future is not None: 94 self._future.result() 95 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopped&quot;) . ",
    "url": "/api_docs/agency/processor.html",
    
    "relUrl": "/api_docs/agency/processor.html"
  },"37": {
    "doc": "agency.processor",
    "title": "agency.processor",
    "content": " ",
    "url": "/api_docs/agency/processor.html",
    
    "relUrl": "/api_docs/agency/processor.html"
  },"38": {
    "doc": "agency.queue",
    "title": "\nagency.queue    ",
    "content": "View Source 1from abc import ABC, ABCMeta, abstractmethod 2 3from agency.schema import Message 4 5 6class Queue(ABC, metaclass=ABCMeta): 7 &quot;&quot;&quot; 8 Encapsulates a queue intended to be used for communication 9 &quot;&quot;&quot; 10 11 def connect(self) -&gt; None: 12 &quot;&quot;&quot; 13 Connects to the queue 14 15 This method is called before the queue is first accessed and establishes 16 a connection if necessary. 17 &quot;&quot;&quot; 18 19 def disconnect(self) -&gt; None: 20 &quot;&quot;&quot; 21 Disconnects from the queue 22 23 This method is called after the queue will no longer be accessed and 24 closes a connection if necessary. 25 &quot;&quot;&quot; 26 27 @abstractmethod 28 def put(self, message: Message): 29 &quot;&quot;&quot; 30 Put a message onto the queue for sending 31 32 Args: 33 message: The message 34 &quot;&quot;&quot; 35 36 @abstractmethod 37 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 38 &quot;&quot;&quot; 39 Get the next message from the queue 40 41 Args: 42 block: Whether to block 43 timeout: The timeout 44 45 Returns: 46 The next message 47 48 Raises: 49 queue.Empty: If there are no messages 50 &quot;&quot;&quot; . class Queue(abc.ABC): View Source 7class Queue(ABC, metaclass=ABCMeta): 8 &quot;&quot;&quot; 9 Encapsulates a queue intended to be used for communication 10 &quot;&quot;&quot; 11 12 def connect(self) -&gt; None: 13 &quot;&quot;&quot; 14 Connects to the queue 15 16 This method is called before the queue is first accessed and establishes 17 a connection if necessary. 18 &quot;&quot;&quot; 19 20 def disconnect(self) -&gt; None: 21 &quot;&quot;&quot; 22 Disconnects from the queue 23 24 This method is called after the queue will no longer be accessed and 25 closes a connection if necessary. 26 &quot;&quot;&quot; 27 28 @abstractmethod 29 def put(self, message: Message): 30 &quot;&quot;&quot; 31 Put a message onto the queue for sending 32 33 Args: 34 message: The message 35 &quot;&quot;&quot; 36 37 @abstractmethod 38 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 39 &quot;&quot;&quot; 40 Get the next message from the queue 41 42 Args: 43 block: Whether to block 44 timeout: The timeout 45 46 Returns: 47 The next message 48 49 Raises: 50 queue.Empty: If there are no messages 51 &quot;&quot;&quot; . Encapsulates a queue intended to be used for communication . def connect(self) -> None: View Source 12 def connect(self) -&gt; None: 13 &quot;&quot;&quot; 14 Connects to the queue 15 16 This method is called before the queue is first accessed and establishes 17 a connection if necessary. 18 &quot;&quot;&quot; . Connects to the queue . This method is called before the queue is first accessed and establishes a connection if necessary. def disconnect(self) -> None: View Source 20 def disconnect(self) -&gt; None: 21 &quot;&quot;&quot; 22 Disconnects from the queue 23 24 This method is called after the queue will no longer be accessed and 25 closes a connection if necessary. 26 &quot;&quot;&quot; . Disconnects from the queue . This method is called after the queue will no longer be accessed and closes a connection if necessary. @abstractmethod def put(self, message: agency.schema.Message): View Source 28 @abstractmethod 29 def put(self, message: Message): 30 &quot;&quot;&quot; 31 Put a message onto the queue for sending 32 33 Args: 34 message: The message 35 &quot;&quot;&quot; . Put a message onto the queue for sending . Arguments: . | message: The message | . @abstractmethod def get(self, block: bool = True, timeout: float = None) -> agency.schema.Message: View Source 37 @abstractmethod 38 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 39 &quot;&quot;&quot; 40 Get the next message from the queue 41 42 Args: 43 block: Whether to block 44 timeout: The timeout 45 46 Returns: 47 The next message 48 49 Raises: 50 queue.Empty: If there are no messages 51 &quot;&quot;&quot; . Get the next message from the queue . Arguments: . | block: Whether to block | timeout: The timeout | . Returns: . The next message . Raises: . | queue.Empty: If there are no messages | . ",
    "url": "/api_docs/agency/queue.html",
    
    "relUrl": "/api_docs/agency/queue.html"
  },"39": {
    "doc": "agency.queue",
    "title": "agency.queue",
    "content": " ",
    "url": "/api_docs/agency/queue.html",
    
    "relUrl": "/api_docs/agency/queue.html"
  },"40": {
    "doc": "agency.schema",
    "title": "\nagency.schema    ",
    "content": "View Source 1from typing import Dict, Optional 2 3from pydantic import BaseModel, Field 4 5 6class Meta(BaseModel): 7 &quot;&quot;&quot;A dictionary field for storing metadata about the message&quot;&quot;&quot; 8 9 class Config: 10 extra = &quot;allow&quot; 11 validate_assignment = True 12 13 id: str = Field( 14 ..., 15 description=&quot;The id of the message.&quot; 16 ) 17 18 parent_id: Optional[str] = Field( 19 None, 20 description=&quot;The id of the previous message that generated this message.&quot; 21 ) 22 23 24class Action(BaseModel): 25 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 26 27 class Config: 28 extra = &quot;forbid&quot; 29 validate_assignment = True 30 31 name: str = Field( 32 ..., 33 description=&quot;The name of the action.&quot; 34 ) 35 36 args: Optional[Dict] = Field( 37 None, 38 description=&quot;The arguments for the action.&quot; 39 ) 40 41 42class Message(BaseModel): 43 &quot;&quot;&quot;The full message schema used for communication&quot;&quot;&quot; 44 45 class Config: 46 extra = &quot;forbid&quot; 47 validate_assignment = True 48 49 meta: Meta 50 51 from_: str = Field( 52 ..., 53 alias=&quot;from&quot;, 54 description=&quot;The id of the sender.&quot; 55 ) 56 57 to: str = Field( 58 ..., 59 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 60 ) 61 62 action: Action . class Meta(pydantic.main.BaseModel): View Source 7class Meta(BaseModel): 8 &quot;&quot;&quot;A dictionary field for storing metadata about the message&quot;&quot;&quot; 9 10 class Config: 11 extra = &quot;allow&quot; 12 validate_assignment = True 13 14 id: str = Field( 15 ..., 16 description=&quot;The id of the message.&quot; 17 ) 18 19 parent_id: Optional[str] = Field( 20 None, 21 description=&quot;The id of the previous message that generated this message.&quot; 22 ) . A dictionary field for storing metadata about the message . id: str parent_id: Optional[str] Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Meta.Config: View Source 10 class Config: 11 extra = &quot;allow&quot; 12 validate_assignment = True . extra = &#39;allow&#39; validate_assignment = True class Action(pydantic.main.BaseModel): View Source 25class Action(BaseModel): 26 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 27 28 class Config: 29 extra = &quot;forbid&quot; 30 validate_assignment = True 31 32 name: str = Field( 33 ..., 34 description=&quot;The name of the action.&quot; 35 ) 36 37 args: Optional[Dict] = Field( 38 None, 39 description=&quot;The arguments for the action.&quot; 40 ) . Schema for an action . name: str args: Optional[Dict] Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Action.Config: View Source 28 class Config: 29 extra = &quot;forbid&quot; 30 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True class Message(pydantic.main.BaseModel): View Source 43class Message(BaseModel): 44 &quot;&quot;&quot;The full message schema used for communication&quot;&quot;&quot; 45 46 class Config: 47 extra = &quot;forbid&quot; 48 validate_assignment = True 49 50 meta: Meta 51 52 from_: str = Field( 53 ..., 54 alias=&quot;from&quot;, 55 description=&quot;The id of the sender.&quot; 56 ) 57 58 to: str = Field( 59 ..., 60 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 61 ) 62 63 action: Action . The full message schema used for communication . meta: Meta from_: str to: str action: Action Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Message.Config: View Source 46 class Config: 47 extra = &quot;forbid&quot; 48 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"41": {
    "doc": "agency.schema",
    "title": "agency.schema",
    "content": " ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"42": {
    "doc": "agency.space",
    "title": "\nagency.space    ",
    "content": "View Source 1import multiprocessing 2import threading 3from abc import ABC, ABCMeta, abstractmethod 4from concurrent.futures import (Executor, ProcessPoolExecutor, 5 ThreadPoolExecutor) 6from typing import Dict, List, Type 7 8from agency.agent import Agent 9from agency.logger import log 10from agency.processor import Processor, _EventProtocol 11from agency.queue import Queue 12 13 14class _ResourceManager: 15 &quot;&quot;&quot; 16 Singleton for globally managing concurrency primitives 17 &quot;&quot;&quot; 18 _instance = None 19 _initialized = False 20 21 def __new__(cls): 22 if cls._instance is None: 23 cls._instance = super(_ResourceManager, cls).__new__(cls) 24 return cls._instance 25 26 def __init__(self): 27 if not self._initialized: 28 self.thread_pool_executor = ThreadPoolExecutor() 29 self.process_pool_executor = ProcessPoolExecutor() 30 self.multiprocessing_manager = multiprocessing.Manager() 31 self._initialized = True 32 33 34class Space(ABC, metaclass=ABCMeta): 35 &quot;&quot;&quot; 36 A Space is where Agents communicate. 37 &quot;&quot;&quot; 38 39 def __init__(self): 40 self.processors: Dict[str, Processor] = {} 41 self._processors_lock: threading.Lock = threading.Lock() 42 43 def __enter__(self): 44 log(&quot;debug&quot;, &quot;Entering Space context&quot;) 45 return self 46 47 def __exit__(self, exc_type, exc_val, exc_tb): 48 if exc_type is not None: 49 log(&quot;debug&quot;, &quot;Exiting Space context with exception&quot;, { 50 &quot;exc_type&quot;: exc_type, 51 &quot;exc_val&quot;: exc_val, 52 &quot;exc_tb&quot;: exc_tb, 53 }) 54 self.destroy() 55 56 def add(self, 57 agent_type: Type[Agent], 58 agent_id: str, 59 *agent_args, 60 **agent_kwargs): 61 &quot;&quot;&quot; 62 Adds an agent to the space allowing it to communicate. 63 64 This method adds the agent in a subprocess. The agent may not be 65 directly accessed from the main thread. 66 67 Args: 68 agent_type: The type of agent to add 69 agent_id: The id of the agent to add 70 71 All other arguments are passed to the Agent constructor 72 73 Raises: 74 ValueError: If the agent ID is already in use 75 &quot;&quot;&quot; 76 self._add(foreground=False, 77 agent_type=agent_type, 78 agent_id=agent_id, 79 *agent_args, 80 **agent_kwargs) 81 82 def add_foreground(self, 83 agent_type: Type[Agent], 84 agent_id: str, 85 *agent_args, 86 **agent_kwargs) -&gt; Agent: 87 &quot;&quot;&quot; 88 Adds an agent to the space and returns it in the current thread. 89 90 This method adds an agent using threading. The agent instance is 91 returned allowing direct access. 92 93 It is recommended to use the `add` method instead of this method in most 94 cases. Agents added this way may block other agents or threads in the 95 main process. Use this method when direct access to the agent instance 96 is desired. 97 98 Args: 99 agent_type: The type of agent to add 100 agent_id: The id of the agent to add 101 102 All other arguments are passed to the Agent constructor 103 104 Returns: 105 The agent 106 107 Raises: 108 ValueError: If the agent ID is already in use 109 &quot;&quot;&quot; 110 agent = self._add(foreground=True, 111 agent_type=agent_type, 112 agent_id=agent_id, 113 *agent_args, 114 **agent_kwargs) 115 return agent 116 117 def remove(self, agent_id: str): 118 &quot;&quot;&quot; 119 Removes an agent from the space by id. 120 121 This method cannot remove an agent added from a different instance. In 122 other words, a Space instance cannot remove an agent that it did not 123 add. 124 125 Args: 126 agent_id: The id of the agent to remove 127 128 Raises: 129 ValueError: If the agent is not present in the space 130 &quot;&quot;&quot; 131 self._stop_processor(agent_id) 132 log(&quot;info&quot;, f&quot;{agent_id}: removed from space&quot;) 133 134 def destroy(self): 135 &quot;&quot;&quot; 136 Cleans up resources used by this space. 137 138 Subclasses should call super().destroy() when overriding. 139 &quot;&quot;&quot; 140 self._stop_all_processors() 141 142 def _add(self, 143 foreground: bool, 144 agent_type: Type[Agent], 145 agent_id: str, 146 *agent_args, 147 **agent_kwargs) -&gt; Agent: 148 149 try: 150 agent = self._start_processor( 151 foreground=foreground, 152 agent_type=agent_type, 153 agent_id=agent_id, 154 agent_args=agent_args, 155 agent_kwargs=agent_kwargs, 156 ) 157 log(&quot;info&quot;, f&quot;{agent_id}: added to space&quot;) 158 return agent 159 except: 160 # clean up if an error occurs 161 self.remove(agent_id) 162 raise 163 164 def _start_processor(self, 165 foreground: bool, 166 agent_type: Type[Agent], 167 agent_id: str, 168 agent_args: List, 169 agent_kwargs: Dict): 170 with self._processors_lock: 171 # Early existence check. Processor.start() will also check. This is 172 # because Spaces may be distributed. 173 if agent_id in self.processors.keys(): 174 raise ValueError(f&quot;Agent &#39;{agent_id}&#39; already exists&quot;) 175 176 self.processors[agent_id] = Processor( 177 agent_type=agent_type, 178 agent_id=agent_id, 179 agent_args=agent_args, 180 agent_kwargs=agent_kwargs, 181 inbound_queue=self._create_inbound_queue(agent_id), 182 outbound_queue=self._create_outbound_queue(agent_id), 183 started=self._define_event(foreground=foreground), 184 stopping=self._define_event(foreground=foreground), 185 new_message_event=self._define_event(foreground=foreground), 186 executor=self._get_executor(foreground=foreground), 187 ) 188 return self.processors[agent_id].start() 189 190 def _stop_processor_unsafe(self, agent_id: str): 191 self.processors[agent_id].stop() 192 self.processors.pop(agent_id) 193 194 def _stop_processor(self, agent_id: str): 195 with self._processors_lock: 196 self._stop_processor_unsafe(agent_id) 197 198 def _stop_all_processors(self): 199 for agent_id in list(self.processors.keys()): 200 try: 201 with self._processors_lock: 202 self._stop_processor_unsafe(agent_id) 203 except Exception as e: 204 log(&quot;error&quot;, 205 f&quot;{agent_id}: processor failed to stop&quot;, e) 206 207 def _get_executor(self, foreground: bool = False) -&gt; Executor: 208 if foreground: 209 return _ResourceManager().thread_pool_executor 210 else: 211 return _ResourceManager().process_pool_executor 212 213 def _define_event(self, foreground: bool = False) -&gt; _EventProtocol: 214 if foreground: 215 return threading.Event() 216 else: 217 return _ResourceManager().multiprocessing_manager.Event() 218 219 @abstractmethod 220 def _create_inbound_queue(self, agent_id) -&gt; Queue: 221 &quot;&quot;&quot; 222 Returns a Queue suitable for receiving messages 223 &quot;&quot;&quot; 224 raise NotImplementedError 225 226 @abstractmethod 227 def _create_outbound_queue(self, agent_id) -&gt; Queue: 228 &quot;&quot;&quot; 229 Returns a Queue suitable for sending messages 230 &quot;&quot;&quot; 231 raise NotImplementedError . class Space(abc.ABC): View Source 35class Space(ABC, metaclass=ABCMeta): 36 &quot;&quot;&quot; 37 A Space is where Agents communicate. 38 &quot;&quot;&quot; 39 40 def __init__(self): 41 self.processors: Dict[str, Processor] = {} 42 self._processors_lock: threading.Lock = threading.Lock() 43 44 def __enter__(self): 45 log(&quot;debug&quot;, &quot;Entering Space context&quot;) 46 return self 47 48 def __exit__(self, exc_type, exc_val, exc_tb): 49 if exc_type is not None: 50 log(&quot;debug&quot;, &quot;Exiting Space context with exception&quot;, { 51 &quot;exc_type&quot;: exc_type, 52 &quot;exc_val&quot;: exc_val, 53 &quot;exc_tb&quot;: exc_tb, 54 }) 55 self.destroy() 56 57 def add(self, 58 agent_type: Type[Agent], 59 agent_id: str, 60 *agent_args, 61 **agent_kwargs): 62 &quot;&quot;&quot; 63 Adds an agent to the space allowing it to communicate. 64 65 This method adds the agent in a subprocess. The agent may not be 66 directly accessed from the main thread. 67 68 Args: 69 agent_type: The type of agent to add 70 agent_id: The id of the agent to add 71 72 All other arguments are passed to the Agent constructor 73 74 Raises: 75 ValueError: If the agent ID is already in use 76 &quot;&quot;&quot; 77 self._add(foreground=False, 78 agent_type=agent_type, 79 agent_id=agent_id, 80 *agent_args, 81 **agent_kwargs) 82 83 def add_foreground(self, 84 agent_type: Type[Agent], 85 agent_id: str, 86 *agent_args, 87 **agent_kwargs) -&gt; Agent: 88 &quot;&quot;&quot; 89 Adds an agent to the space and returns it in the current thread. 90 91 This method adds an agent using threading. The agent instance is 92 returned allowing direct access. 93 94 It is recommended to use the `add` method instead of this method in most 95 cases. Agents added this way may block other agents or threads in the 96 main process. Use this method when direct access to the agent instance 97 is desired. 98 99 Args: 100 agent_type: The type of agent to add 101 agent_id: The id of the agent to add 102 103 All other arguments are passed to the Agent constructor 104 105 Returns: 106 The agent 107 108 Raises: 109 ValueError: If the agent ID is already in use 110 &quot;&quot;&quot; 111 agent = self._add(foreground=True, 112 agent_type=agent_type, 113 agent_id=agent_id, 114 *agent_args, 115 **agent_kwargs) 116 return agent 117 118 def remove(self, agent_id: str): 119 &quot;&quot;&quot; 120 Removes an agent from the space by id. 121 122 This method cannot remove an agent added from a different instance. In 123 other words, a Space instance cannot remove an agent that it did not 124 add. 125 126 Args: 127 agent_id: The id of the agent to remove 128 129 Raises: 130 ValueError: If the agent is not present in the space 131 &quot;&quot;&quot; 132 self._stop_processor(agent_id) 133 log(&quot;info&quot;, f&quot;{agent_id}: removed from space&quot;) 134 135 def destroy(self): 136 &quot;&quot;&quot; 137 Cleans up resources used by this space. 138 139 Subclasses should call super().destroy() when overriding. 140 &quot;&quot;&quot; 141 self._stop_all_processors() 142 143 def _add(self, 144 foreground: bool, 145 agent_type: Type[Agent], 146 agent_id: str, 147 *agent_args, 148 **agent_kwargs) -&gt; Agent: 149 150 try: 151 agent = self._start_processor( 152 foreground=foreground, 153 agent_type=agent_type, 154 agent_id=agent_id, 155 agent_args=agent_args, 156 agent_kwargs=agent_kwargs, 157 ) 158 log(&quot;info&quot;, f&quot;{agent_id}: added to space&quot;) 159 return agent 160 except: 161 # clean up if an error occurs 162 self.remove(agent_id) 163 raise 164 165 def _start_processor(self, 166 foreground: bool, 167 agent_type: Type[Agent], 168 agent_id: str, 169 agent_args: List, 170 agent_kwargs: Dict): 171 with self._processors_lock: 172 # Early existence check. Processor.start() will also check. This is 173 # because Spaces may be distributed. 174 if agent_id in self.processors.keys(): 175 raise ValueError(f&quot;Agent &#39;{agent_id}&#39; already exists&quot;) 176 177 self.processors[agent_id] = Processor( 178 agent_type=agent_type, 179 agent_id=agent_id, 180 agent_args=agent_args, 181 agent_kwargs=agent_kwargs, 182 inbound_queue=self._create_inbound_queue(agent_id), 183 outbound_queue=self._create_outbound_queue(agent_id), 184 started=self._define_event(foreground=foreground), 185 stopping=self._define_event(foreground=foreground), 186 new_message_event=self._define_event(foreground=foreground), 187 executor=self._get_executor(foreground=foreground), 188 ) 189 return self.processors[agent_id].start() 190 191 def _stop_processor_unsafe(self, agent_id: str): 192 self.processors[agent_id].stop() 193 self.processors.pop(agent_id) 194 195 def _stop_processor(self, agent_id: str): 196 with self._processors_lock: 197 self._stop_processor_unsafe(agent_id) 198 199 def _stop_all_processors(self): 200 for agent_id in list(self.processors.keys()): 201 try: 202 with self._processors_lock: 203 self._stop_processor_unsafe(agent_id) 204 except Exception as e: 205 log(&quot;error&quot;, 206 f&quot;{agent_id}: processor failed to stop&quot;, e) 207 208 def _get_executor(self, foreground: bool = False) -&gt; Executor: 209 if foreground: 210 return _ResourceManager().thread_pool_executor 211 else: 212 return _ResourceManager().process_pool_executor 213 214 def _define_event(self, foreground: bool = False) -&gt; _EventProtocol: 215 if foreground: 216 return threading.Event() 217 else: 218 return _ResourceManager().multiprocessing_manager.Event() 219 220 @abstractmethod 221 def _create_inbound_queue(self, agent_id) -&gt; Queue: 222 &quot;&quot;&quot; 223 Returns a Queue suitable for receiving messages 224 &quot;&quot;&quot; 225 raise NotImplementedError 226 227 @abstractmethod 228 def _create_outbound_queue(self, agent_id) -&gt; Queue: 229 &quot;&quot;&quot; 230 Returns a Queue suitable for sending messages 231 &quot;&quot;&quot; 232 raise NotImplementedError . A Space is where Agents communicate. processors: Dict[str, agency.processor.Processor] def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, *agent_args, **agent_kwargs): View Source 57 def add(self, 58 agent_type: Type[Agent], 59 agent_id: str, 60 *agent_args, 61 **agent_kwargs): 62 &quot;&quot;&quot; 63 Adds an agent to the space allowing it to communicate. 64 65 This method adds the agent in a subprocess. The agent may not be 66 directly accessed from the main thread. 67 68 Args: 69 agent_type: The type of agent to add 70 agent_id: The id of the agent to add 71 72 All other arguments are passed to the Agent constructor 73 74 Raises: 75 ValueError: If the agent ID is already in use 76 &quot;&quot;&quot; 77 self._add(foreground=False, 78 agent_type=agent_type, 79 agent_id=agent_id, 80 *agent_args, 81 **agent_kwargs) . Adds an agent to the space allowing it to communicate. This method adds the agent in a subprocess. The agent may not be directly accessed from the main thread. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | All other arguments are passed to the Agent constructor | . Raises: . | ValueError: If the agent ID is already in use | . def add_foreground( self, agent_type: Type[agency.agent.Agent], agent_id: str, *agent_args, **agent_kwargs) -> agency.agent.Agent: View Source 83 def add_foreground(self, 84 agent_type: Type[Agent], 85 agent_id: str, 86 *agent_args, 87 **agent_kwargs) -&gt; Agent: 88 &quot;&quot;&quot; 89 Adds an agent to the space and returns it in the current thread. 90 91 This method adds an agent using threading. The agent instance is 92 returned allowing direct access. 93 94 It is recommended to use the `add` method instead of this method in most 95 cases. Agents added this way may block other agents or threads in the 96 main process. Use this method when direct access to the agent instance 97 is desired. 98 99 Args: 100 agent_type: The type of agent to add 101 agent_id: The id of the agent to add 102 103 All other arguments are passed to the Agent constructor 104 105 Returns: 106 The agent 107 108 Raises: 109 ValueError: If the agent ID is already in use 110 &quot;&quot;&quot; 111 agent = self._add(foreground=True, 112 agent_type=agent_type, 113 agent_id=agent_id, 114 *agent_args, 115 **agent_kwargs) 116 return agent . Adds an agent to the space and returns it in the current thread. This method adds an agent using threading. The agent instance is returned allowing direct access. It is recommended to use the add method instead of this method in most cases. Agents added this way may block other agents or threads in the main process. Use this method when direct access to the agent instance is desired. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | All other arguments are passed to the Agent constructor | . Returns: . The agent . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 118 def remove(self, agent_id: str): 119 &quot;&quot;&quot; 120 Removes an agent from the space by id. 121 122 This method cannot remove an agent added from a different instance. In 123 other words, a Space instance cannot remove an agent that it did not 124 add. 125 126 Args: 127 agent_id: The id of the agent to remove 128 129 Raises: 130 ValueError: If the agent is not present in the space 131 &quot;&quot;&quot; 132 self._stop_processor(agent_id) 133 log(&quot;info&quot;, f&quot;{agent_id}: removed from space&quot;) . Removes an agent from the space by id. This method cannot remove an agent added from a different instance. In other words, a Space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def destroy(self): View Source 135 def destroy(self): 136 &quot;&quot;&quot; 137 Cleans up resources used by this space. 138 139 Subclasses should call super().destroy() when overriding. 140 &quot;&quot;&quot; 141 self._stop_all_processors() . Cleans up resources used by this space. Subclasses should call super().destroy() when overriding. ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"43": {
    "doc": "agency.space",
    "title": "agency.space",
    "content": " ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"44": {
    "doc": "agency.spaces",
    "title": "\nagency.spaces    ",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"45": {
    "doc": "agency.spaces",
    "title": "Submodules",
    "content": ". | amqp_space | local_space | . ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"46": {
    "doc": "agency.spaces",
    "title": "agency.spaces",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"47": {
    "doc": "agency.spaces.amqp_space",
    "title": "\nagency.spaces.amqp_space    ",
    "content": "View Source 1import json 2import os 3import queue 4import socket 5import threading 6import time 7from concurrent.futures import Future 8from dataclasses import dataclass 9 10import amqp 11import kombu 12 13from agency.logger import log 14from agency.queue import Queue 15from agency.schema import Message 16from agency.space import Space, _ResourceManager 17 18_BROADCAST_KEY = &quot;__broadcast__&quot; 19 20@dataclass 21class AMQPOptions: 22 &quot;&quot;&quot;A class that defines AMQP connection options&quot;&quot;&quot; 23 hostname: str = &#39;localhost&#39; 24 port: int = &#39;5672&#39; 25 username: str = &#39;guest&#39; 26 password: str = &#39;guest&#39; 27 virtual_host: str = &#39;/&#39; 28 use_ssl: bool = False 29 heartbeat: float = 60 30 31 32class _AMQPQueue(Queue): 33 &quot;&quot;&quot;An AMQP based Queue using the kombu library&quot;&quot;&quot; 34 35 def __init__(self, amqp_options: AMQPOptions, exchange_name: str, routing_key: str): 36 self.kombu_connection_options = { 37 &#39;hostname&#39;: amqp_options.hostname, 38 &#39;port&#39;: amqp_options.port, 39 &#39;userid&#39;: amqp_options.username, 40 &#39;password&#39;: amqp_options.password, 41 &#39;virtual_host&#39;: amqp_options.virtual_host, 42 &#39;ssl&#39;: amqp_options.use_ssl, 43 &#39;heartbeat&#39;: amqp_options.heartbeat, 44 } 45 self.exchange_name: str = exchange_name 46 self.routing_key: str = routing_key 47 48 49class _AMQPInboundQueue(_AMQPQueue): 50 51 def __init__(self, amqp_options: AMQPOptions, exchange_name: str, routing_key: str): 52 super().__init__(amqp_options, exchange_name, routing_key) 53 self._connection: kombu.Connection = None 54 self._exchange: kombu.Exchange = None 55 self._direct_queue: kombu.Queue = None 56 self._broadcast_queue: kombu.Queue = None 57 self._heartbeat_future: Future = None 58 self._received_queue: queue.Queue = None 59 self._disconnecting: threading.Event = None 60 61 def connect(self): 62 log(&quot;debug&quot;, f&quot;{self.routing_key}: connecting&quot;) 63 64 self._received_queue = queue.Queue() 65 66 def _callback(body, amqp_message): 67 amqp_message.ack() 68 self._received_queue.put(json.loads(body)) 69 70 try: 71 self._connection = kombu.Connection( 72 **self.kombu_connection_options) 73 self._connection.connect() 74 self._exchange = kombu.Exchange( 75 self.exchange_name, &#39;topic&#39;, durable=True) 76 self._direct_queue = kombu.Queue( 77 self.routing_key, 78 exchange=self._exchange, 79 routing_key=self.routing_key, 80 exclusive=True) 81 self._broadcast_queue = kombu.Queue( 82 f&quot;{self.routing_key}-broadcast&quot;, 83 exchange=self._exchange, 84 routing_key=_BROADCAST_KEY, 85 exclusive=True) 86 self._consumer = kombu.Consumer( 87 self._connection, 88 [self._direct_queue, self._broadcast_queue], 89 callbacks=[_callback]) 90 self._consumer.consume() 91 except amqp.exceptions.ResourceLocked: 92 raise ValueError(f&quot;Agent &#39;{self.routing_key}&#39; already exists&quot;) 93 94 # start heartbeat thread 95 def _heartbeat_thread(disconnecting): 96 log(&quot;debug&quot;, f&quot;{self.routing_key}: heartbeat thread starting&quot;) 97 try: 98 while not disconnecting.is_set(): 99 try: 100 self._connection.heartbeat_check() 101 self._connection.drain_events(timeout=0.2) 102 time.sleep(0.1) 103 except socket.timeout: 104 pass 105 except amqp.exceptions.ConnectionForced: 106 log(&quot;warning&quot;, 107 f&quot;{self.routing_key}: heartbeat connection force closed&quot;) 108 log(&quot;debug&quot;, f&quot;{self.routing_key}: heartbeat thread stopped&quot;) 109 self._disconnecting = threading.Event() 110 self._disconnecting.clear() 111 self._heartbeat_future = _ResourceManager( 112 ).thread_pool_executor.submit(_heartbeat_thread, self._disconnecting) 113 114 log(&quot;debug&quot;, f&quot;{self.routing_key}: connected&quot;) 115 116 def disconnect(self): 117 log(&quot;debug&quot;, f&quot;{self.routing_key}: disconnecting&quot;) 118 if self._disconnecting: 119 self._disconnecting.set() 120 try: 121 if self._heartbeat_future is not None: 122 self._heartbeat_future.result(timeout=5) 123 finally: 124 if self._connection: 125 self._connection.close() 126 log(&quot;debug&quot;, f&quot;{self.routing_key}: disconnected&quot;) 127 128 def put(self, message: Message): 129 raise NotImplementedError(&quot;AMQPInboundQueue does not support put&quot;) 130 131 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 132 message = self._received_queue.get(block=block, timeout=timeout) 133 return message 134 135 136class _AMQPOutboundQueue(_AMQPQueue): 137 138 def __init__(self, amqp_options: AMQPOptions, exchange_name: str, routing_key: str): 139 super().__init__(amqp_options, exchange_name, routing_key) 140 self._exchange: kombu.Exchange = None 141 142 def connect(self): 143 self._exchange = kombu.Exchange( 144 self.exchange_name, &#39;topic&#39;, durable=True) 145 146 def put(self, message: Message): 147 with kombu.Connection(**self.kombu_connection_options) as connection: 148 with connection.Producer() as producer: 149 if message[&#39;to&#39;] == &#39;*&#39;: 150 producer.publish( 151 json.dumps(message), 152 exchange=self._exchange, 153 routing_key=_BROADCAST_KEY, 154 ) 155 else: 156 producer.publish( 157 json.dumps(message), 158 exchange=self._exchange, 159 routing_key=message[&#39;to&#39;], 160 ) 161 162 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 163 raise NotImplementedError(&quot;AMQPOutboundQueue does not support get&quot;) 164 165 166class AMQPSpace(Space): 167 &quot;&quot;&quot; 168 A Space that uses AMQP for message delivery. 169 170 This Space type is useful for distributing agents across multiple hosts. 171 &quot;&quot;&quot; 172 173 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 174 super().__init__() 175 if amqp_options is None: 176 amqp_options = self.__default_amqp_options() 177 self.amqp_options = amqp_options 178 self.exchange_name = exchange_name 179 180 def __default_amqp_options(self) -&gt; AMQPOptions: 181 &quot;&quot;&quot; 182 Returns a default AMQPOptions object configurable from environment 183 variables. 184 &quot;&quot;&quot; 185 # TODO add support for AMQP_URL 186 return AMQPOptions( 187 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 188 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 189 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 190 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 191 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 192 use_ssl=False, 193 heartbeat=60, 194 ) 195 196 def _create_inbound_queue(self, agent_id) -&gt; Queue: 197 return _AMQPInboundQueue( 198 amqp_options=self.amqp_options, 199 exchange_name=self.exchange_name, 200 routing_key=agent_id, 201 ) 202 203 def _create_outbound_queue(self, agent_id) -&gt; Queue: 204 return _AMQPOutboundQueue( 205 amqp_options=self.amqp_options, 206 exchange_name=self.exchange_name, 207 routing_key=agent_id, 208 ) . @dataclass class AMQPOptions: View Source 21@dataclass 22class AMQPOptions: 23 &quot;&quot;&quot;A class that defines AMQP connection options&quot;&quot;&quot; 24 hostname: str = &#39;localhost&#39; 25 port: int = &#39;5672&#39; 26 username: str = &#39;guest&#39; 27 password: str = &#39;guest&#39; 28 virtual_host: str = &#39;/&#39; 29 use_ssl: bool = False 30 heartbeat: float = 60 . A class that defines AMQP connection options . AMQPOptions( hostname: str = &#39;localhost&#39;, port: int = &#39;5672&#39;, username: str = &#39;guest&#39;, password: str = &#39;guest&#39;, virtual_host: str = &#39;/&#39;, use_ssl: bool = False, heartbeat: float = 60) hostname: str = &#39;localhost&#39; port: int = &#39;5672&#39; username: str = &#39;guest&#39; password: str = &#39;guest&#39; virtual_host: str = &#39;/&#39; use_ssl: bool = False heartbeat: float = 60 class AMQPSpace(agency.space.Space): View Source 167class AMQPSpace(Space): 168 &quot;&quot;&quot; 169 A Space that uses AMQP for message delivery. 170 171 This Space type is useful for distributing agents across multiple hosts. 172 &quot;&quot;&quot; 173 174 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 175 super().__init__() 176 if amqp_options is None: 177 amqp_options = self.__default_amqp_options() 178 self.amqp_options = amqp_options 179 self.exchange_name = exchange_name 180 181 def __default_amqp_options(self) -&gt; AMQPOptions: 182 &quot;&quot;&quot; 183 Returns a default AMQPOptions object configurable from environment 184 variables. 185 &quot;&quot;&quot; 186 # TODO add support for AMQP_URL 187 return AMQPOptions( 188 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 189 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 190 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 191 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 192 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 193 use_ssl=False, 194 heartbeat=60, 195 ) 196 197 def _create_inbound_queue(self, agent_id) -&gt; Queue: 198 return _AMQPInboundQueue( 199 amqp_options=self.amqp_options, 200 exchange_name=self.exchange_name, 201 routing_key=agent_id, 202 ) 203 204 def _create_outbound_queue(self, agent_id) -&gt; Queue: 205 return _AMQPOutboundQueue( 206 amqp_options=self.amqp_options, 207 exchange_name=self.exchange_name, 208 routing_key=agent_id, 209 ) . A Space that uses AMQP for message delivery. This Space type is useful for distributing agents across multiple hosts. AMQPSpace( amqp_options: AMQPOptions = None, exchange_name: str = &#39;agency&#39;) View Source 174 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 175 super().__init__() 176 if amqp_options is None: 177 amqp_options = self.__default_amqp_options() 178 self.amqp_options = amqp_options 179 self.exchange_name = exchange_name . amqp_options exchange_name Inherited Members . agency.space.Space processors add add_foreground remove destroy ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"48": {
    "doc": "agency.spaces.amqp_space",
    "title": "agency.spaces.amqp_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"49": {
    "doc": "agency.spaces.local_space",
    "title": "\nagency.spaces.local_space    ",
    "content": "View Source 1import multiprocessing 2import queue 3import threading 4from concurrent.futures import Future 5 6from agency.logger import log 7from agency.queue import Queue 8from agency.schema import Message 9from agency.space import _ResourceManager, Space 10 11 12class _LocalQueue(Queue): 13 &quot;&quot;&quot;A multiprocessing based implementation of Queue&quot;&quot;&quot; 14 15 def __init__(self, outbound_message_event: multiprocessing.Event = None): 16 self.outbound_message_event = outbound_message_event 17 self._queue = _ResourceManager().multiprocessing_manager.Queue() 18 19 def put(self, message: Message): 20 self._queue.put(message) 21 if self.outbound_message_event is not None: 22 self.outbound_message_event.set() 23 24 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 25 return self._queue.get(block=block, timeout=timeout) 26 27 28class LocalSpace(Space): 29 &quot;&quot;&quot; 30 A LocalSpace allows Agents to communicate within the python application 31 &quot;&quot;&quot; 32 33 def __init__(self): 34 super().__init__() 35 self._stop_router_event: threading.Event = threading.Event() 36 self._outbound_message_event: multiprocessing.Event = _ResourceManager( 37 ).multiprocessing_manager.Event() 38 self._router_future: Future = self._start_router_thread() 39 40 def destroy(self): 41 self._stop_router_thread() 42 super().destroy() 43 44 def _start_router_thread(self): 45 def _router_thread(): 46 &quot;&quot;&quot;Routes outbound messages&quot;&quot;&quot; 47 log(&quot;debug&quot;, &quot;LocalSpace: router thread starting&quot;) 48 while not self._stop_router_event.is_set(): 49 self._outbound_message_event.wait(timeout=0.1) 50 if self._stop_router_event.is_set(): 51 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopping&quot;) 52 break 53 self._outbound_message_event.clear() 54 # drain each outbound queue 55 processors = list(self.processors.values()) 56 for processor in processors: 57 outbound_queue = processor.outbound_queue 58 while True: 59 try: 60 message = outbound_queue.get(block=False) 61 log(&quot;debug&quot;, f&quot;LocalSpace: routing message&quot;, message) 62 recipient_processors = [ 63 processor for processor in processors 64 if message[&quot;to&quot;] == processor.agent_id or message[&quot;to&quot;] == &quot;*&quot; 65 ] 66 for recipient_processor in recipient_processors: 67 recipient_processor.inbound_queue.put(message) 68 except queue.Empty: 69 break 70 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopped&quot;) 71 72 return _ResourceManager().thread_pool_executor.submit(_router_thread) 73 74 def _stop_router_thread(self): 75 self._stop_router_event.set() 76 self._router_future.result() 77 78 def _create_inbound_queue(self, agent_id) -&gt; Queue: 79 return _LocalQueue() 80 81 def _create_outbound_queue(self, agent_id) -&gt; Queue: 82 return _LocalQueue(outbound_message_event=self._outbound_message_event) . class LocalSpace(agency.space.Space): View Source 29class LocalSpace(Space): 30 &quot;&quot;&quot; 31 A LocalSpace allows Agents to communicate within the python application 32 &quot;&quot;&quot; 33 34 def __init__(self): 35 super().__init__() 36 self._stop_router_event: threading.Event = threading.Event() 37 self._outbound_message_event: multiprocessing.Event = _ResourceManager( 38 ).multiprocessing_manager.Event() 39 self._router_future: Future = self._start_router_thread() 40 41 def destroy(self): 42 self._stop_router_thread() 43 super().destroy() 44 45 def _start_router_thread(self): 46 def _router_thread(): 47 &quot;&quot;&quot;Routes outbound messages&quot;&quot;&quot; 48 log(&quot;debug&quot;, &quot;LocalSpace: router thread starting&quot;) 49 while not self._stop_router_event.is_set(): 50 self._outbound_message_event.wait(timeout=0.1) 51 if self._stop_router_event.is_set(): 52 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopping&quot;) 53 break 54 self._outbound_message_event.clear() 55 # drain each outbound queue 56 processors = list(self.processors.values()) 57 for processor in processors: 58 outbound_queue = processor.outbound_queue 59 while True: 60 try: 61 message = outbound_queue.get(block=False) 62 log(&quot;debug&quot;, f&quot;LocalSpace: routing message&quot;, message) 63 recipient_processors = [ 64 processor for processor in processors 65 if message[&quot;to&quot;] == processor.agent_id or message[&quot;to&quot;] == &quot;*&quot; 66 ] 67 for recipient_processor in recipient_processors: 68 recipient_processor.inbound_queue.put(message) 69 except queue.Empty: 70 break 71 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopped&quot;) 72 73 return _ResourceManager().thread_pool_executor.submit(_router_thread) 74 75 def _stop_router_thread(self): 76 self._stop_router_event.set() 77 self._router_future.result() 78 79 def _create_inbound_queue(self, agent_id) -&gt; Queue: 80 return _LocalQueue() 81 82 def _create_outbound_queue(self, agent_id) -&gt; Queue: 83 return _LocalQueue(outbound_message_event=self._outbound_message_event) . A LocalSpace allows Agents to communicate within the python application . def destroy(self): View Source 41 def destroy(self): 42 self._stop_router_thread() 43 super().destroy() . Cleans up resources used by this space. Subclasses should call super().destroy() when overriding. Inherited Members . agency.space.Space processors add add_foreground remove ",
    "url": "/api_docs/agency/spaces/local_space.html",
    
    "relUrl": "/api_docs/agency/spaces/local_space.html"
  },"50": {
    "doc": "agency.spaces.local_space",
    "title": "agency.spaces.local_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/local_space.html",
    
    "relUrl": "/api_docs/agency/spaces/local_space.html"
  }
}
