{"0": {
    "doc": "Agent Implementation",
    "title": "Agent Implementation",
    "content": "To create an agent, extend the Agent class. class MyAgent(Agent): ... ",
    "url": "/articles/agent_implementation",
    
    "relUrl": "/articles/agent_implementation"
  },"1": {
    "doc": "Agent Implementation",
    "title": "Defining Actions",
    "content": "Actions are simply instance methods decorated with @action. The @action decorator takes the following keyword arguments: . | name: The name of the action. Defaults to the method name | help: The description of the action. Defaults to autogenerated object | access_policy: The access policy of the action. Defaults to ACCESS_PERMITTED | . ",
    "url": "/articles/agent_implementation#defining-actions",
    
    "relUrl": "/articles/agent_implementation#defining-actions"
  },"2": {
    "doc": "Agent Implementation",
    "title": "Defining Help",
    "content": "The help attribute may be used for describing the given action to other agents. Below is an example of the help information generated by default from the @action decorator arguments and the method’s signature. { \"shell_command\": { \"description\": \"Execute a shell command\", \"args\": { \"command\": { \"type\": \"string\" \"description\": \"The command to execute\" } }, \"returns\": { \"type\": \"string\" \"description\": \"The output of the command\" } }, ... } . The following example shows how the same help information above can be defined using a docstring that follows the Google style guide: . @action def shell_command(self, command: str) -&gt; str: \"\"\" Execute a shell command Args: command (str): The command to execute Returns: str: The output of the command \"\"\" . The action name is determined by the method name. Types are determined by looking at the docstring and the signature, with the signature type hint taking precedence. Action and argument descriptions are parsed from the docstring. Overriding Help Information . The default help data structure could be customized as well: . @action( help={ \"You\": \"can define\", \"any\": { \"structure\": [\"you\", \"want\", \"here.\"] } } ) def say(self, content: str) -&gt; None: . If a help object is provided to the decorator, it overrides the generated object entirely. You can use this to experiment with different help information schemas. Merging the two objects, for example to only override specific fields, is not (yet) supported. Please open an issue if you’d like to see this feature developed. ",
    "url": "/articles/agent_implementation#defining-help",
    
    "relUrl": "/articles/agent_implementation#defining-help"
  },"3": {
    "doc": "Agent Implementation",
    "title": "Special Actions",
    "content": "There are three special actions present on all agents by default: . Override or extend these actions to customize the behavior of your agent. | help Returns a list of all actions on this agent. This is used by agents for action discovery. You normally do not need to implement this method but you may do so for example, to control which actions are returned to other agents. | response If an action method returns a value, this method will be called with the value. | error Receives any error messages from an action invoked by the agent. | . ",
    "url": "/articles/agent_implementation#special-actions",
    
    "relUrl": "/articles/agent_implementation#special-actions"
  },"4": {
    "doc": "Agent Implementation",
    "title": "Callbacks",
    "content": "The following is the list of agent callbacks you may implement. | before_action Called before an action is attempted. If an exception is raised in before_action, the action method and after_action callbacks will not be executed and the error will be returned to the sender. | after_action Called after an action is attempted. Provides the original message, the return value, and error if applicable. This method is called even if an exception is raised in the action. | after_add Called after an agent is added to a space and may begin sending/receiving messages. Use this method to perform any initial setup necessary upon being added to a space. | before_remove Called before an agent is removed from a space and will no longer send/receive messages. Use this method to perform any cleanup necessary before being removed from a space. | request_permission Called when an agent attempts to perform an action that requires permission. This method should return True or False to indicate whether the action should be allowed. A rejected action will be returned as a permission error to the sender. | . ",
    "url": "/articles/agent_implementation#callbacks",
    
    "relUrl": "/articles/agent_implementation#callbacks"
  },"5": {
    "doc": "Messaging",
    "title": "Messaging",
    "content": " ",
    "url": "/articles/messaging",
    
    "relUrl": "/articles/messaging"
  },"6": {
    "doc": "Messaging",
    "title": "Schema",
    "content": "All messages are validated upon sending and must conform to the message schema. The full message schema is summarized by this example: . { \"id\": \"some optional id\", \"meta\": { \"an\": \"optional\", \"object\": { \"for\": \"metadata\", } }, \"from\": \"the sender's id\", \"to\": \"the receiver's id\", \"action\": { \"name\": \"the_action_name\", \"args\": { \"the\": \"args\", } } } . Note that when sending, you may not need to supply this entire structure. The id and meta fields are optional. Additionally, the from field is automatically populated for you in the send() method. A minimal example of calling Agent.send() with only the required fields would look like: . my_agent.send({ \"to\": \"some_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } }) . See agency/schema.py for the pydantic model definition used for validation. ",
    "url": "/articles/messaging#schema",
    
    "relUrl": "/articles/messaging#schema"
  },"7": {
    "doc": "Messaging",
    "title": "Using the id Field",
    "content": "The message id field may be used to correlate an incoming message with a previously sent message, for example to associate response data with the request. The id field is not populated by default. To use the id field, you must explicitly specify it in the outgoing message object. You can set it to any string identifier you choose. By default, the id field is used by the response and error actions. If a response or error is received, the original_message_id argument will be populated with the id of the original message. For example, say we have an add action which returns the sum of its arguments. @action def add(self, a: int, b: int) -&gt; int: return a + b . Sending the following message: . my_agent.send({ \"id\": \"a custom message id\", \"to\": \"calculator_agent\", \"action\": { \"name\": \"add\", \"args\": { \"a\": 1, \"b\": 2 } } }) . … would result in a subsequent response message like the following: . { \"from\": \"calculator_agent\", \"to\": \"my_agent\", \"action\": { \"name\": \"response\", \"args\": { \"data\": 3, \"original_message_id\": \"a custom message id\" } } } . Notice the original_message_id argument populated with the id of the original message. ",
    "url": "/articles/messaging#using-the-id-field",
    
    "relUrl": "/articles/messaging#using-the-id-field"
  },"8": {
    "doc": "Messaging",
    "title": "Using the meta Field",
    "content": "The meta field may be used to store arbitrary key-value metadata about the message. It is entirely optional. Possible uses of the meta field include: . | Storing “thoughts” associated with an action. This is a common pattern used with LLM agents. For example, an LLM agent may send the following message: { \"meta\": { \"thoughts\": \"I should say hello to everyone\", }, \"to\": \"my_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } } . | Storing timestamps associated with an action. For example: { \"meta\": { \"timestamp\": 12345, }, ... } . | . These are just a couple ideas to illustrate the use of the meta field. ",
    "url": "/articles/messaging#using-the-meta-field",
    
    "relUrl": "/articles/messaging#using-the-meta-field"
  },"9": {
    "doc": "Messaging",
    "title": "Broadcast vs Point-to-Point",
    "content": "All messages require the to field to be specified. The to field should be the id of an agent in the space (point-to-point) or the special id * to broadcast the message to all agents in the space. By default, agents receive their own broadcasts, but you may change this behavior with the receive_own_broadcasts argument when creating the agent. For example: . my_agent = MyAgent(\"MyAgent\", receive_own_broadcasts=False) . ",
    "url": "/articles/messaging#broadcast-vs-point-to-point",
    
    "relUrl": "/articles/messaging#broadcast-vs-point-to-point"
  },"10": {
    "doc": "Messaging",
    "title": "Non-Existent Agents or Actions",
    "content": "If you send a message to a non-existent agent, it will silently fail. If you send a message to an existent agent, but specify a non-existent action, you will receive an error message in response. Broadcasts which specify a non-existent action are silently ignored, so that broadcasts do not result in many error messages. ",
    "url": "/articles/messaging#non-existent-agents-or-actions",
    
    "relUrl": "/articles/messaging#non-existent-agents-or-actions"
  },"11": {
    "doc": "Using AMQPSpace",
    "title": "Using AMQPSpace",
    "content": "To use AMQP for multi-process or networked communication, you can simply swap the AMQPSpace class for the NativeSpace class. Then to take advantage of parallelism, you would also separate your agents into multiple processes configured to use the same AMQP server. For example, the following would separate the Host agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a host agent to the space space.add(Host(\"Host\")) # keep alive while True: time.sleep(1) . And the following would separate the ChattyAI agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a simple HF based chat agent to the space space.add( ChattyAI(\"Chatty\", model=\"EleutherAI/gpt-neo-125m\")) # keep alive while True: time.sleep(1) . Make sure to reuse the same AMQP server and configuration for both applications. Then you can run both applications at the same time, and the agents will be able to connect and communicate with each other over AMQP. This approach allows you to scale your agents across multiple processes or hosts, and avoids the multithreading limitations of python’s GIL. See the example application for a full working example. ",
    "url": "/articles/using_amqpspace",
    
    "relUrl": "/articles/using_amqpspace"
  },"12": {
    "doc": "Using AMQPSpace",
    "title": "Configuring AMQP Connectivity",
    "content": "By default, the AMQPSpace class will read the following environment variables and will otherwise use default settings. AMQP_HOST AMQP_PORT AMQP_USERNAME AMQP_PASSWORD AMQP_VHOST . You may also customize the full list of options if you provide your own AMQPOptions object when instantiating an AMQPSpace. For example: . space = AMQPSpace( amqp_options=AMQPOptions( hostname=\"localhost\", port=5672, username=\"guest\", password=\"guest\", virtual_host=\"/\", use_ssl=True, heartbeat=60)) . ",
    "url": "/articles/using_amqpspace#configuring-amqp-connectivity",
    
    "relUrl": "/articles/using_amqpspace#configuring-amqp-connectivity"
  },"13": {
    "doc": "Example Application Walkthrough",
    "title": "Example Application Walkthrough",
    "content": "The following walkthrough will guide you through the basic concepts of Agency’s API, and how to use it to build your own agent systems. ",
    "url": "/articles/walkthrough",
    
    "relUrl": "/articles/walkthrough"
  },"14": {
    "doc": "Example Application Walkthrough",
    "title": "Creating an Agency Application",
    "content": "The snippet below is an example of a simple Agency application. For this walkthrough, we’ll be using the NativeSpace class for connecting agents. Usage is exactly the same as with the AMQPSpace class, except that a NativeSpace is for agents in the same process, and does not require an AMQP server. The following application includes the OpenAIFunctionAgent class, a transformers based chat agent named ChattyAI, operating system access, and a Gradio based web application hosted at http://localhost:8080, all integrated with the following implementation. # Create a space space = NativeSpace() # Add a simple HF based chat agent to the space space.add( ChattyAI(\"Chatty\", model=\"EleutherAI/gpt-neo-125m\")) # Add a host agent to the space, exposing access to the host system space.add(Host(\"Host\")) # Add an OpenAI agent to the space space.add( OpenAIFunctionAgent(\"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the OpenAI chat API user_id=\"User\")) # Connect the Gradio app user to the space space.add(gradio_user) # Launch Gradio UI demo.launch() . ",
    "url": "/articles/walkthrough#creating-an-agency-application",
    
    "relUrl": "/articles/walkthrough#creating-an-agency-application"
  },"15": {
    "doc": "Example Application Walkthrough",
    "title": "Creating a Space and adding an Agent",
    "content": "space = NativeSpace() space.add(ChattyAI(\"Chatty\", model=\"EleutherAI/gpt-neo-125m\")) . This creates a space and adds a new ChattyAI instance to it, with the id of Chatty. An agent’s id is used to identify the agent within the space. Other agents may send messages to Chatty by using that id, as we’ll see later. id’s are unique. Two agents may not declare the same id within the same space. ",
    "url": "/articles/walkthrough#creating-a-space-and-adding-an-agent",
    
    "relUrl": "/articles/walkthrough#creating-a-space-and-adding-an-agent"
  },"16": {
    "doc": "Example Application Walkthrough",
    "title": "Defining Actions",
    "content": "Looking at ChattyAI’s source code, you’ll see that it is a subclass of Agent, and that it exposes a single action called say. The following is a typical action method signature taken from ChattyAI. @action def say(self, content: str): \"\"\"Use this action to say something to Chatty\"\"\" ... The decorator @action is used to indicate that this is an action that can be invoked by other agents in their space. The method name say is the name of the action by default. The say action takes a single string argument content. This action is intended to allow other agents to chat with Chatty, as expressed in its docstring. When ChattyAI receives a say action, it will generate a response using its underlying language model, and return the result to the sender. ",
    "url": "/articles/walkthrough#defining-actions",
    
    "relUrl": "/articles/walkthrough#defining-actions"
  },"17": {
    "doc": "Example Application Walkthrough",
    "title": "Invoking Actions",
    "content": "An example of invoking an action can be seen here, taken from the same ChattyAI.say() method... self.send({ \"to\": self._current_message['from'], \"action\": { \"name\": \"say\", \"args\": { \"content\": response_content, } } }) . This demonstrates the basic idea of how to invoke an action on another agent. When an agent receives a message, it invokes the action method specified by the action.name field of the message, passing the action.args dictionary to the action method as keyword arguments. So here Chatty is invoking the say action on the sender of the original message, passing the response as the content argument. This way, the original sender and Chatty can have a conversation. Note the use of the _current_message variable. That variable may be inspected during an action to access the entire incoming message which invoked the action. ",
    "url": "/articles/walkthrough#invoking-actions",
    
    "relUrl": "/articles/walkthrough#invoking-actions"
  },"18": {
    "doc": "Example Application Walkthrough",
    "title": "Access Control",
    "content": "Access policies may be used to control when actions can be invoked by agents. All actions may declare an access policy like the following example: . @action(access_policy=ACCESS_PERMITTED) def my_action(self): ... An access policy can currently be one of three values: . | ACCESS_PERMITTED - (Default) Permits any agent to use that action at any time. | ACCESS_DENIED - Prevents access to that action. | ACCESS_REQUESTED - Prompts the receiving agent for permission when access is attempted. Access will await approval or denial. | . If ACCESS_REQUESTED is used, the receiving agent will be prompted to approve the action via the request_permission() callback method. If any actions declare a policy of ACCESS_REQUESTED, you must implement the request_permission() method with the following signature in order to receive permission requests. def request_permission(self, proposed_message: dict) -&gt; bool: ... Your implementation should inspect proposed_message and return a boolean indicating whether or not to permit the action. You can use this approach to protect against dangerous actions being taken. For example if you allow terminal access, you may want to review commands before they are invoked. ",
    "url": "/articles/walkthrough#access-control",
    
    "relUrl": "/articles/walkthrough#access-control"
  },"19": {
    "doc": "Example Application Walkthrough",
    "title": "The Gradio UI",
    "content": "The Gradio UI is a Chatbot based application used for development and demonstration purposes, that allows human users to connect to a space and chat with the connected agents. It is defined in examples/demo/apps/gradio_app.py and simply needs to be imported and used like so: . from apps.gradio_app import demo, gradio_user ... space.add(gradio_user) ... demo.launch() . You can also invoke actions on agents using a custom “slash” syntax. To broadcast a message to all other agents in the space, simply type without a format. The client will automatically convert unformatted text to a say action. For example, simply writing: . Hello, world! . will be broadcast to all agents as a say action. To send a point-to-point message to a specific agent, or to call actions other than say, you can use the following format: . /agent_id.action_name arg1:\"value 1\" arg2:\"value 2\" . ",
    "url": "/articles/walkthrough#the-gradio-ui",
    
    "relUrl": "/articles/walkthrough#the-gradio-ui"
  },"20": {
    "doc": "Example Application Walkthrough",
    "title": "Adding OS Access with the Host Agent",
    "content": "space.add(Host(\"Host\")) . The Host class demonstrates allowing access to the host operating system where the python application is running. It exposes actions such as read_file and shell_command which allow other agents to interact with the host. This class is a good example of one with potentially dangerous actions that must be accessed with care. You’ll notice that all the methods in the Host class have been given the access policy: . @action(access_policy=ACCESS_REQUESTED) ... Thanks to the implementation of request_permission() in the Host class, all actions on the host will require a confirmation from the terminal where the application is being run. Note that this implementation of request_permission() is just one possibility. We could have implemented for example, a phone notification for a human to review from elsewhere. ",
    "url": "/articles/walkthrough#adding-os-access-with-the-host-agent",
    
    "relUrl": "/articles/walkthrough#adding-os-access-with-the-host-agent"
  },"21": {
    "doc": "Example Application Walkthrough",
    "title": "Discovering Actions",
    "content": "At this point, we can demonstrate how action discovery works from the perspective of a human user of the web application. Once added to a space, each agent may broadcast a help message to discover other agents and actions that are available in the space. So a person using the chat UI can discover all available actions by typing: . /*.help . Note the use of *. This is a reserved name for broadcasting messages to all agents in the space. So the above command will broadcast a help action to all other agents, who will individually respond with a dictionary of their available actions. To invoke an action (like help) on a specific agent, you can use the following syntax: . /Host.help action_name:\"say\" . Note the agent name used before the action name. In this case, the help action takes an argument called action_name. So this will send the help action to the Host agent requesting information on the say action. ",
    "url": "/articles/walkthrough#discovering-actions",
    
    "relUrl": "/articles/walkthrough#discovering-actions"
  },"22": {
    "doc": "Example Application Walkthrough",
    "title": "Adding an Intelligent Agent",
    "content": "Lastly we can add an intelligent agent into the space. To add the OpenAIFunctionAgent class to the environment: . space.add( OpenAIFunctionAgent(\"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the chat API user_id=\"User\")) . For more agent examples that you can try, see the examples/demo/agents/ directory. That concludes the example walkthrough. To try the demo application, please jump to the examples/demo/ directory. ",
    "url": "/articles/walkthrough#adding-an-intelligent-agent",
    
    "relUrl": "/articles/walkthrough#adding-an-intelligent-agent"
  },"23": {
    "doc": "agency",
    "title": "\nagency    ",
    "content": " ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"24": {
    "doc": "agency",
    "title": "Submodules",
    "content": ". | agent | processor | processors | schema | space | spaces | util | . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"25": {
    "doc": "agency",
    "title": "agency",
    "content": " ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"26": {
    "doc": "agency.agent",
    "title": "\nagency.agent    ",
    "content": "View Source 1import inspect 2import re 3from typing import List 4from docstring_parser import DocstringStyle, parse 5from agency import util 6from agency.schema import Message 7from agency.util import print_warning 8 9 10# access keys 11ACCESS_PERMITTED = &quot;permitted&quot; 12ACCESS_DENIED = &quot;denied&quot; 13ACCESS_REQUESTED = &quot;requested&quot; 14 15 16def __generate_help(method: callable) -&gt; dict: 17 &quot;&quot;&quot; 18 Generates a help object from a method&#39;s docstring and signature 19 20 Args: 21 method: the method 22 23 Returns: 24 A help object of the form: 25 26 { 27 &quot;description&quot;: &lt;description&gt;, 28 &quot;args&quot;: { 29 &quot;arg_name&quot;: { 30 &quot;type&quot;: &lt;type&gt;, 31 &quot;description&quot;: &lt;description&gt; 32 }, 33 } 34 &quot;returns&quot;: { 35 &quot;type&quot;: &lt;type&gt;, 36 &quot;description&quot;: &lt;description&gt; 37 } 38 } 39 &quot;&quot;&quot; 40 signature = inspect.signature(method) 41 parsed_docstring = parse(method.__doc__, DocstringStyle.GOOGLE) 42 43 help_object = {} 44 45 # description 46 if parsed_docstring.short_description is not None: 47 description = parsed_docstring.short_description 48 if parsed_docstring.long_description is not None: 49 description += &quot; &quot; + parsed_docstring.long_description 50 help_object[&quot;description&quot;] = re.sub(r&quot;\\s+&quot;, &quot; &quot;, description).strip() 51 52 # args 53 help_object[&quot;args&quot;] = {} 54 docstring_args = {arg.arg_name: arg for arg in parsed_docstring.params} 55 arg_names = list(signature.parameters.keys())[1:] # skip &#39;self&#39; argument 56 for arg_name in arg_names: 57 arg_object = {} 58 59 # type 60 sig_annotation = signature.parameters[arg_name].annotation 61 if sig_annotation is not None and sig_annotation.__name__ != &quot;_empty&quot;: 62 arg_object[&quot;type&quot;] = util.python_to_json_type_name( 63 signature.parameters[arg_name].annotation.__name__) 64 elif arg_name in docstring_args and docstring_args[arg_name].type_name is not None: 65 arg_object[&quot;type&quot;] = util.python_to_json_type_name( 66 docstring_args[arg_name].type_name) 67 68 # description 69 if arg_name in docstring_args and docstring_args[arg_name].description is not None: 70 arg_object[&quot;description&quot;] = docstring_args[arg_name].description.strip() 71 72 help_object[&quot;args&quot;][arg_name] = arg_object 73 74 # returns 75 if parsed_docstring.returns is not None: 76 help_object[&quot;returns&quot;] = {} 77 78 # type 79 if signature.return_annotation is not None: 80 help_object[&quot;returns&quot;][&quot;type&quot;] = util.python_to_json_type_name( 81 signature.return_annotation.__name__) 82 elif parsed_docstring.returns.type_name is not None: 83 help_object[&quot;returns&quot;][&quot;type&quot;] = util.python_to_json_type_name( 84 parsed_docstring.returns.type_name) 85 86 # description 87 if parsed_docstring.returns.description is not None: 88 help_object[&quot;returns&quot;][&quot;description&quot;] = parsed_docstring.returns.description.strip() 89 90 return help_object 91 92 93def action(*args, **kwargs): 94 def decorator(method): 95 method.action_properties = { 96 &quot;name&quot;: method.__name__, 97 &quot;access_policy&quot;: ACCESS_PERMITTED, 98 &quot;help&quot;: __generate_help(method), 99 **kwargs, 100 } 101 return method 102 103 if len(args) == 1 and callable(args[0]) and not kwargs: 104 return decorator(args[0]) # The decorator was used without parentheses 105 else: 106 return decorator # The decorator was used with parentheses 107 108 109class Agent(): 110 &quot;&quot;&quot; 111 An Actor that may represent an AI agent, computing system, or human user 112 &quot;&quot;&quot; 113 114 def __init__(self, id: str, receive_own_broadcasts: bool = True) -&gt; None: 115 if len(id) &lt; 1 or len(id) &gt; 255: 116 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 117 if re.match(r&quot;^amq\\.&quot;, id): 118 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 119 if id == &quot;*&quot;: 120 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 121 self.__id: str = id 122 self.__receive_own_broadcasts = receive_own_broadcasts 123 self._space = None # set by Space when added 124 self._message_log: List[Message] = [] # stores all messages 125 126 def id(self) -&gt; str: 127 &quot;&quot;&quot; 128 Returns the id of this agent 129 &quot;&quot;&quot; 130 return self.__id 131 132 def send(self, message: dict): 133 &quot;&quot;&quot; 134 Sends (out) a message 135 &quot;&quot;&quot; 136 message[&quot;from&quot;] = self.id() 137 self._message_log.append(message) 138 self._space._route(message) 139 140 def _receive(self, message: dict): 141 &quot;&quot;&quot; 142 Receives and processes an incoming message 143 &quot;&quot;&quot; 144 if not self.__receive_own_broadcasts \\ 145 and message[&#39;from&#39;] == self.id() \\ 146 and message[&#39;to&#39;] == &#39;*&#39;: 147 return 148 149 try: 150 # Record message and commit action 151 self._message_log.append(message) 152 self.__commit(message) 153 except Exception as e: 154 # Here we handle exceptions that occur while committing an action, 155 # including PermissionError&#39;s from access denial, by reporting the 156 # error back to the sender. 157 self.send({ 158 &quot;to&quot;: message[&#39;from&#39;], 159 &quot;from&quot;: self.id(), 160 &quot;action&quot;: { 161 &quot;name&quot;: &quot;error&quot;, 162 &quot;args&quot;: { 163 &quot;error&quot;: f&quot;{e}&quot;, 164 &quot;original_message_id&quot;: message.get(&#39;id&#39;), 165 } 166 } 167 }) 168 169 def __commit(self, message: dict): 170 &quot;&quot;&quot; 171 Invokes action if permitted otherwise raises PermissionError 172 &quot;&quot;&quot; 173 # Check if the action method exists 174 try: 175 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 176 except KeyError: 177 # the action was not found 178 if message[&#39;to&#39;] == self.id(): 179 # if it was point to point, raise an error 180 raise AttributeError( 181 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 182 else: 183 # broadcasts will not raise an error 184 return 185 186 self.before_action(message) 187 188 return_value = None 189 error = None 190 try: 191 192 # Check if the action is permitted 193 if self.__permitted(message): 194 195 # Invoke the action method 196 # (set _current_message so that it can be used by the action) 197 self._current_message = message 198 return_value = action_method(**message[&#39;action&#39;][&#39;args&#39;]) 199 self._current_message = None 200 201 # The return value if any, from an action method is sent back to 202 # the sender as a &quot;response&quot; action. 203 if return_value is not None: 204 self.send({ 205 &quot;to&quot;: message[&#39;from&#39;], 206 &quot;action&quot;: { 207 &quot;name&quot;: &quot;response&quot;, 208 &quot;args&quot;: { 209 &quot;data&quot;: return_value, 210 &quot;original_message_id&quot;: message.get(&#39;id&#39;), 211 }, 212 } 213 }) 214 else: 215 raise PermissionError( 216 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 217 except Exception as e: 218 error = e # save the error for after_action 219 raise 220 finally: 221 self.after_action(message, return_value, error) 222 223 def __permitted(self, message: dict) -&gt; bool: 224 &quot;&quot;&quot; 225 Checks whether the action represented by the message is allowed 226 &quot;&quot;&quot; 227 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 228 policy = action_method.action_properties[&quot;access_policy&quot;] 229 if policy == ACCESS_PERMITTED: 230 return True 231 elif policy == ACCESS_DENIED: 232 return False 233 elif policy == ACCESS_REQUESTED: 234 return self.request_permission(message) 235 else: 236 raise Exception( 237 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 238 239 def __action_methods(self) -&gt; dict: 240 instance_methods = inspect.getmembers(self, inspect.ismethod) 241 action_methods = { 242 method_name: method 243 for method_name, method in instance_methods 244 if hasattr(method, &quot;action_properties&quot;) 245 } 246 return action_methods 247 248 def __action_method(self, action_name: str): 249 &quot;&quot;&quot; 250 Returns the method for the given action name. 251 &quot;&quot;&quot; 252 action_methods = self.__action_methods() 253 return action_methods[action_name] 254 255 @action 256 def help(self, action_name: str = None) -&gt; dict: 257 &quot;&quot;&quot; 258 Returns a list of actions on this agent. 259 260 If action_name is passed, returns a list with only that action. 261 If no action_name is passed, returns all actions. 262 263 Args: 264 action_name: (Optional) The name of an action to request help for 265 266 Returns: 267 A list of actions 268 &quot;&quot;&quot; 269 special_actions = [&quot;help&quot;, &quot;response&quot;, &quot;error&quot;] 270 help_list = { 271 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 272 for method in self.__action_methods().values() 273 if action_name is None 274 and method.action_properties[&quot;name&quot;] not in special_actions 275 or method.action_properties[&quot;name&quot;] == action_name 276 } 277 return help_list 278 279 @action 280 def response(self, data, original_message_id: str = None): 281 &quot;&quot;&quot; 282 Receives a return value from a prior action. 283 284 Args: 285 data: The returned value from the action. 286 original_message_id: The id field of the original message 287 &quot;&quot;&quot; 288 print_warning( 289 f&quot;Data was returned from an action. Implement a `response` action to handle it.&quot;) 290 291 @action 292 def error(self, error: str, original_message_id: str = None): 293 &quot;&quot;&quot; 294 Receives errors from a prior action. 295 296 Args: 297 error: The error message 298 original_message_id: The id field of the original message 299 &quot;&quot;&quot; 300 print_warning( 301 f&quot;An error occurred in an action. Implement an `error` action to handle it.&quot;) 302 303 def after_add(self): 304 &quot;&quot;&quot; 305 Called after the agent is added to a space. Override this method to 306 perform any additional setup. 307 &quot;&quot;&quot; 308 309 def before_remove(self): 310 &quot;&quot;&quot; 311 Called before the agent is removed from a space. Override this method to 312 perform any cleanup. 313 &quot;&quot;&quot; 314 315 def before_action(self, message: dict): 316 &quot;&quot;&quot; 317 Called before every action. Override this method for logging or other 318 situations where you may want to process all actions. 319 &quot;&quot;&quot; 320 321 def after_action(self, original_message: dict, return_value: str, error: str): 322 &quot;&quot;&quot; 323 Called after every action. Override this method for logging or other 324 situations where you may want to pass through all actions. 325 &quot;&quot;&quot; 326 327 def request_permission(self, proposed_message: dict) -&gt; bool: 328 &quot;&quot;&quot; 329 Implement this method to receive a proposed action message and present 330 it to the agent for review. Return true or false to indicate whether 331 access should be permitted. 332 &quot;&quot;&quot; 333 raise NotImplementedError( 334 f&quot;You must implement {self.__class__.__name__}.request_permission to use ACCESS_REQUESTED&quot;) . ACCESS_PERMITTED = &#39;permitted&#39; ACCESS_DENIED = &#39;denied&#39; ACCESS_REQUESTED = &#39;requested&#39; def action(*args, **kwargs): View Source 94def action(*args, **kwargs): 95 def decorator(method): 96 method.action_properties = { 97 &quot;name&quot;: method.__name__, 98 &quot;access_policy&quot;: ACCESS_PERMITTED, 99 &quot;help&quot;: __generate_help(method), 100 **kwargs, 101 } 102 return method 103 104 if len(args) == 1 and callable(args[0]) and not kwargs: 105 return decorator(args[0]) # The decorator was used without parentheses 106 else: 107 return decorator # The decorator was used with parentheses . class Agent: View Source 110class Agent(): 111 &quot;&quot;&quot; 112 An Actor that may represent an AI agent, computing system, or human user 113 &quot;&quot;&quot; 114 115 def __init__(self, id: str, receive_own_broadcasts: bool = True) -&gt; None: 116 if len(id) &lt; 1 or len(id) &gt; 255: 117 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 118 if re.match(r&quot;^amq\\.&quot;, id): 119 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 120 if id == &quot;*&quot;: 121 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 122 self.__id: str = id 123 self.__receive_own_broadcasts = receive_own_broadcasts 124 self._space = None # set by Space when added 125 self._message_log: List[Message] = [] # stores all messages 126 127 def id(self) -&gt; str: 128 &quot;&quot;&quot; 129 Returns the id of this agent 130 &quot;&quot;&quot; 131 return self.__id 132 133 def send(self, message: dict): 134 &quot;&quot;&quot; 135 Sends (out) a message 136 &quot;&quot;&quot; 137 message[&quot;from&quot;] = self.id() 138 self._message_log.append(message) 139 self._space._route(message) 140 141 def _receive(self, message: dict): 142 &quot;&quot;&quot; 143 Receives and processes an incoming message 144 &quot;&quot;&quot; 145 if not self.__receive_own_broadcasts \\ 146 and message[&#39;from&#39;] == self.id() \\ 147 and message[&#39;to&#39;] == &#39;*&#39;: 148 return 149 150 try: 151 # Record message and commit action 152 self._message_log.append(message) 153 self.__commit(message) 154 except Exception as e: 155 # Here we handle exceptions that occur while committing an action, 156 # including PermissionError&#39;s from access denial, by reporting the 157 # error back to the sender. 158 self.send({ 159 &quot;to&quot;: message[&#39;from&#39;], 160 &quot;from&quot;: self.id(), 161 &quot;action&quot;: { 162 &quot;name&quot;: &quot;error&quot;, 163 &quot;args&quot;: { 164 &quot;error&quot;: f&quot;{e}&quot;, 165 &quot;original_message_id&quot;: message.get(&#39;id&#39;), 166 } 167 } 168 }) 169 170 def __commit(self, message: dict): 171 &quot;&quot;&quot; 172 Invokes action if permitted otherwise raises PermissionError 173 &quot;&quot;&quot; 174 # Check if the action method exists 175 try: 176 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 177 except KeyError: 178 # the action was not found 179 if message[&#39;to&#39;] == self.id(): 180 # if it was point to point, raise an error 181 raise AttributeError( 182 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 183 else: 184 # broadcasts will not raise an error 185 return 186 187 self.before_action(message) 188 189 return_value = None 190 error = None 191 try: 192 193 # Check if the action is permitted 194 if self.__permitted(message): 195 196 # Invoke the action method 197 # (set _current_message so that it can be used by the action) 198 self._current_message = message 199 return_value = action_method(**message[&#39;action&#39;][&#39;args&#39;]) 200 self._current_message = None 201 202 # The return value if any, from an action method is sent back to 203 # the sender as a &quot;response&quot; action. 204 if return_value is not None: 205 self.send({ 206 &quot;to&quot;: message[&#39;from&#39;], 207 &quot;action&quot;: { 208 &quot;name&quot;: &quot;response&quot;, 209 &quot;args&quot;: { 210 &quot;data&quot;: return_value, 211 &quot;original_message_id&quot;: message.get(&#39;id&#39;), 212 }, 213 } 214 }) 215 else: 216 raise PermissionError( 217 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 218 except Exception as e: 219 error = e # save the error for after_action 220 raise 221 finally: 222 self.after_action(message, return_value, error) 223 224 def __permitted(self, message: dict) -&gt; bool: 225 &quot;&quot;&quot; 226 Checks whether the action represented by the message is allowed 227 &quot;&quot;&quot; 228 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 229 policy = action_method.action_properties[&quot;access_policy&quot;] 230 if policy == ACCESS_PERMITTED: 231 return True 232 elif policy == ACCESS_DENIED: 233 return False 234 elif policy == ACCESS_REQUESTED: 235 return self.request_permission(message) 236 else: 237 raise Exception( 238 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 239 240 def __action_methods(self) -&gt; dict: 241 instance_methods = inspect.getmembers(self, inspect.ismethod) 242 action_methods = { 243 method_name: method 244 for method_name, method in instance_methods 245 if hasattr(method, &quot;action_properties&quot;) 246 } 247 return action_methods 248 249 def __action_method(self, action_name: str): 250 &quot;&quot;&quot; 251 Returns the method for the given action name. 252 &quot;&quot;&quot; 253 action_methods = self.__action_methods() 254 return action_methods[action_name] 255 256 @action 257 def help(self, action_name: str = None) -&gt; dict: 258 &quot;&quot;&quot; 259 Returns a list of actions on this agent. 260 261 If action_name is passed, returns a list with only that action. 262 If no action_name is passed, returns all actions. 263 264 Args: 265 action_name: (Optional) The name of an action to request help for 266 267 Returns: 268 A list of actions 269 &quot;&quot;&quot; 270 special_actions = [&quot;help&quot;, &quot;response&quot;, &quot;error&quot;] 271 help_list = { 272 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 273 for method in self.__action_methods().values() 274 if action_name is None 275 and method.action_properties[&quot;name&quot;] not in special_actions 276 or method.action_properties[&quot;name&quot;] == action_name 277 } 278 return help_list 279 280 @action 281 def response(self, data, original_message_id: str = None): 282 &quot;&quot;&quot; 283 Receives a return value from a prior action. 284 285 Args: 286 data: The returned value from the action. 287 original_message_id: The id field of the original message 288 &quot;&quot;&quot; 289 print_warning( 290 f&quot;Data was returned from an action. Implement a `response` action to handle it.&quot;) 291 292 @action 293 def error(self, error: str, original_message_id: str = None): 294 &quot;&quot;&quot; 295 Receives errors from a prior action. 296 297 Args: 298 error: The error message 299 original_message_id: The id field of the original message 300 &quot;&quot;&quot; 301 print_warning( 302 f&quot;An error occurred in an action. Implement an `error` action to handle it.&quot;) 303 304 def after_add(self): 305 &quot;&quot;&quot; 306 Called after the agent is added to a space. Override this method to 307 perform any additional setup. 308 &quot;&quot;&quot; 309 310 def before_remove(self): 311 &quot;&quot;&quot; 312 Called before the agent is removed from a space. Override this method to 313 perform any cleanup. 314 &quot;&quot;&quot; 315 316 def before_action(self, message: dict): 317 &quot;&quot;&quot; 318 Called before every action. Override this method for logging or other 319 situations where you may want to process all actions. 320 &quot;&quot;&quot; 321 322 def after_action(self, original_message: dict, return_value: str, error: str): 323 &quot;&quot;&quot; 324 Called after every action. Override this method for logging or other 325 situations where you may want to pass through all actions. 326 &quot;&quot;&quot; 327 328 def request_permission(self, proposed_message: dict) -&gt; bool: 329 &quot;&quot;&quot; 330 Implement this method to receive a proposed action message and present 331 it to the agent for review. Return true or false to indicate whether 332 access should be permitted. 333 &quot;&quot;&quot; 334 raise NotImplementedError( 335 f&quot;You must implement {self.__class__.__name__}.request_permission to use ACCESS_REQUESTED&quot;) . An Actor that may represent an AI agent, computing system, or human user . Agent(id: str, receive_own_broadcasts: bool = True) View Source 115 def __init__(self, id: str, receive_own_broadcasts: bool = True) -&gt; None: 116 if len(id) &lt; 1 or len(id) &gt; 255: 117 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 118 if re.match(r&quot;^amq\\.&quot;, id): 119 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 120 if id == &quot;*&quot;: 121 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 122 self.__id: str = id 123 self.__receive_own_broadcasts = receive_own_broadcasts 124 self._space = None # set by Space when added 125 self._message_log: List[Message] = [] # stores all messages . def id(self) -> str: View Source 127 def id(self) -&gt; str: 128 &quot;&quot;&quot; 129 Returns the id of this agent 130 &quot;&quot;&quot; 131 return self.__id . Returns the id of this agent . def send(self, message: dict): View Source 133 def send(self, message: dict): 134 &quot;&quot;&quot; 135 Sends (out) a message 136 &quot;&quot;&quot; 137 message[&quot;from&quot;] = self.id() 138 self._message_log.append(message) 139 self._space._route(message) . Sends (out) a message . @action def help(self, action_name: str = None) -> dict: View Source 256 @action 257 def help(self, action_name: str = None) -&gt; dict: 258 &quot;&quot;&quot; 259 Returns a list of actions on this agent. 260 261 If action_name is passed, returns a list with only that action. 262 If no action_name is passed, returns all actions. 263 264 Args: 265 action_name: (Optional) The name of an action to request help for 266 267 Returns: 268 A list of actions 269 &quot;&quot;&quot; 270 special_actions = [&quot;help&quot;, &quot;response&quot;, &quot;error&quot;] 271 help_list = { 272 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 273 for method in self.__action_methods().values() 274 if action_name is None 275 and method.action_properties[&quot;name&quot;] not in special_actions 276 or method.action_properties[&quot;name&quot;] == action_name 277 } 278 return help_list . Returns a list of actions on this agent. If action_name is passed, returns a list with only that action. If no action_name is passed, returns all actions. Arguments: . | action_name: (Optional) The name of an action to request help for | . Returns: . A list of actions . @action def response(self, data, original_message_id: str = None): View Source 280 @action 281 def response(self, data, original_message_id: str = None): 282 &quot;&quot;&quot; 283 Receives a return value from a prior action. 284 285 Args: 286 data: The returned value from the action. 287 original_message_id: The id field of the original message 288 &quot;&quot;&quot; 289 print_warning( 290 f&quot;Data was returned from an action. Implement a `response` action to handle it.&quot;) . Receives a return value from a prior action. Arguments: . | data: The returned value from the action. | original_message_id: The id field of the original message | . @action def error(self, error: str, original_message_id: str = None): View Source 292 @action 293 def error(self, error: str, original_message_id: str = None): 294 &quot;&quot;&quot; 295 Receives errors from a prior action. 296 297 Args: 298 error: The error message 299 original_message_id: The id field of the original message 300 &quot;&quot;&quot; 301 print_warning( 302 f&quot;An error occurred in an action. Implement an `error` action to handle it.&quot;) . Receives errors from a prior action. Arguments: . | error: The error message | original_message_id: The id field of the original message | . def after_add(self): View Source 304 def after_add(self): 305 &quot;&quot;&quot; 306 Called after the agent is added to a space. Override this method to 307 perform any additional setup. 308 &quot;&quot;&quot; . Called after the agent is added to a space. Override this method to perform any additional setup. def before_remove(self): View Source 310 def before_remove(self): 311 &quot;&quot;&quot; 312 Called before the agent is removed from a space. Override this method to 313 perform any cleanup. 314 &quot;&quot;&quot; . Called before the agent is removed from a space. Override this method to perform any cleanup. def before_action(self, message: dict): View Source 316 def before_action(self, message: dict): 317 &quot;&quot;&quot; 318 Called before every action. Override this method for logging or other 319 situations where you may want to process all actions. 320 &quot;&quot;&quot; . Called before every action. Override this method for logging or other situations where you may want to process all actions. def after_action(self, original_message: dict, return_value: str, error: str): View Source 322 def after_action(self, original_message: dict, return_value: str, error: str): 323 &quot;&quot;&quot; 324 Called after every action. Override this method for logging or other 325 situations where you may want to pass through all actions. 326 &quot;&quot;&quot; . Called after every action. Override this method for logging or other situations where you may want to pass through all actions. def request_permission(self, proposed_message: dict) -> bool: View Source 328 def request_permission(self, proposed_message: dict) -&gt; bool: 329 &quot;&quot;&quot; 330 Implement this method to receive a proposed action message and present 331 it to the agent for review. Return true or false to indicate whether 332 access should be permitted. 333 &quot;&quot;&quot; 334 raise NotImplementedError( 335 f&quot;You must implement {self.__class__.__name__}.request_permission to use ACCESS_REQUESTED&quot;) . Implement this method to receive a proposed action message and present it to the agent for review. Return true or false to indicate whether access should be permitted. ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"27": {
    "doc": "agency.agent",
    "title": "agency.agent",
    "content": " ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"28": {
    "doc": "agency.processor",
    "title": "\nagency.processor    ",
    "content": "View Source 1from abc import ABC, ABCMeta, abstractmethod 2from typing import Callable 3 4 5class Processor(ABC, metaclass=ABCMeta): 6 &quot;&quot;&quot; 7 Implements the form of concurrent processing used by a Space instance. 8 9 A processor simply calls the process method frequently. It is intended to 10 run concurrently with other processors, so it must do this in a way that 11 cooperates with other processor instances. 12 &quot;&quot;&quot; 13 14 def __init__(self, process: Callable): 15 self._process = process 16 17 @abstractmethod 18 def start(self): 19 &quot;&quot;&quot; 20 Starts the processor 21 &quot;&quot;&quot; 22 23 @abstractmethod 24 def stop(self): 25 &quot;&quot;&quot; 26 Stops the processor 27 &quot;&quot;&quot; . class Processor(abc.ABC): View Source 6class Processor(ABC, metaclass=ABCMeta): 7 &quot;&quot;&quot; 8 Implements the form of concurrent processing used by a Space instance. 9 10 A processor simply calls the process method frequently. It is intended to 11 run concurrently with other processors, so it must do this in a way that 12 cooperates with other processor instances. 13 &quot;&quot;&quot; 14 15 def __init__(self, process: Callable): 16 self._process = process 17 18 @abstractmethod 19 def start(self): 20 &quot;&quot;&quot; 21 Starts the processor 22 &quot;&quot;&quot; 23 24 @abstractmethod 25 def stop(self): 26 &quot;&quot;&quot; 27 Stops the processor 28 &quot;&quot;&quot; . Implements the form of concurrent processing used by a Space instance. A processor simply calls the process method frequently. It is intended to run concurrently with other processors, so it must do this in a way that cooperates with other processor instances. @abstractmethod def start(self): View Source 18 @abstractmethod 19 def start(self): 20 &quot;&quot;&quot; 21 Starts the processor 22 &quot;&quot;&quot; . Starts the processor . @abstractmethod def stop(self): View Source 24 @abstractmethod 25 def stop(self): 26 &quot;&quot;&quot; 27 Stops the processor 28 &quot;&quot;&quot; . Stops the processor . ",
    "url": "/api_docs/agency/processor.html",
    
    "relUrl": "/api_docs/agency/processor.html"
  },"29": {
    "doc": "agency.processor",
    "title": "agency.processor",
    "content": " ",
    "url": "/api_docs/agency/processor.html",
    
    "relUrl": "/api_docs/agency/processor.html"
  },"30": {
    "doc": "agency.processors",
    "title": "\nagency.processors    ",
    "content": " ",
    "url": "/api_docs/agency/processors.html",
    
    "relUrl": "/api_docs/agency/processors.html"
  },"31": {
    "doc": "agency.processors",
    "title": "Submodules",
    "content": ". | native_thread_processor | . ",
    "url": "/api_docs/agency/processors.html",
    
    "relUrl": "/api_docs/agency/processors.html"
  },"32": {
    "doc": "agency.processors",
    "title": "agency.processors",
    "content": " ",
    "url": "/api_docs/agency/processors.html",
    
    "relUrl": "/api_docs/agency/processors.html"
  },"33": {
    "doc": "agency.processors.native_thread_processor",
    "title": "\nagency.processors.native_thread_processor    ",
    "content": "View Source 1import threading 2import time 3from agency.processor import Processor 4 5 6class NativeThreadProcessor(Processor): 7 &quot;&quot;&quot; 8 A processor implementation which uses native threads 9 &quot;&quot;&quot; 10 11 def start(self): 12 def _thread(): 13 self.__started.set() 14 while not self.__stopping.is_set(): 15 time.sleep(0) # cooperate 16 self._process() 17 18 self.__started = threading.Event() 19 self.__stopping = threading.Event() 20 self.__thread = threading.Thread(target=_thread) 21 self.__thread.start() 22 23 if not self.__started.wait(timeout=10): 24 # it couldn&#39;t start, force stop the thread and raise an exception 25 self.stop() 26 raise Exception(&quot;Thread could not be started.&quot;) 27 28 def stop(self): 29 self.__stopping.set() 30 self.__thread.join(timeout=10) 31 if self.__thread.is_alive(): 32 raise Exception(&quot;Thread could not be stopped.&quot;) . class NativeThreadProcessor(agency.processor.Processor): View Source 7class NativeThreadProcessor(Processor): 8 &quot;&quot;&quot; 9 A processor implementation which uses native threads 10 &quot;&quot;&quot; 11 12 def start(self): 13 def _thread(): 14 self.__started.set() 15 while not self.__stopping.is_set(): 16 time.sleep(0) # cooperate 17 self._process() 18 19 self.__started = threading.Event() 20 self.__stopping = threading.Event() 21 self.__thread = threading.Thread(target=_thread) 22 self.__thread.start() 23 24 if not self.__started.wait(timeout=10): 25 # it couldn&#39;t start, force stop the thread and raise an exception 26 self.stop() 27 raise Exception(&quot;Thread could not be started.&quot;) 28 29 def stop(self): 30 self.__stopping.set() 31 self.__thread.join(timeout=10) 32 if self.__thread.is_alive(): 33 raise Exception(&quot;Thread could not be stopped.&quot;) . A processor implementation which uses native threads . def start(self): View Source 12 def start(self): 13 def _thread(): 14 self.__started.set() 15 while not self.__stopping.is_set(): 16 time.sleep(0) # cooperate 17 self._process() 18 19 self.__started = threading.Event() 20 self.__stopping = threading.Event() 21 self.__thread = threading.Thread(target=_thread) 22 self.__thread.start() 23 24 if not self.__started.wait(timeout=10): 25 # it couldn&#39;t start, force stop the thread and raise an exception 26 self.stop() 27 raise Exception(&quot;Thread could not be started.&quot;) . Starts the processor . def stop(self): View Source 29 def stop(self): 30 self.__stopping.set() 31 self.__thread.join(timeout=10) 32 if self.__thread.is_alive(): 33 raise Exception(&quot;Thread could not be stopped.&quot;) . Stops the processor . Inherited Members . agency.processor.Processor Processor ",
    "url": "/api_docs/agency/processors/native_thread_processor.html",
    
    "relUrl": "/api_docs/agency/processors/native_thread_processor.html"
  },"34": {
    "doc": "agency.processors.native_thread_processor",
    "title": "agency.processors.native_thread_processor",
    "content": " ",
    "url": "/api_docs/agency/processors/native_thread_processor.html",
    
    "relUrl": "/api_docs/agency/processors/native_thread_processor.html"
  },"35": {
    "doc": "agency.schema",
    "title": "\nagency.schema    ",
    "content": "View Source 1from pydantic import BaseModel, Field 2from typing import Dict, Optional 3 4 5class Action(BaseModel): 6 &quot;&quot;&quot; 7 Schema for an action 8 &quot;&quot;&quot; 9 10 name: str = Field( 11 ..., 12 description=&quot;The name of the action.&quot; 13 ) 14 15 args: Dict = Field( 16 ..., 17 description=&quot;The arguments for the action.&quot; 18 ) 19 20 21class Message(BaseModel): 22 &quot;&quot;&quot; 23 Schema for a message 24 &quot;&quot;&quot; 25 26 id: Optional[str] = Field( 27 None, 28 description=&quot;An optional id referenced as `original_message_id` in `response` or `error` messages.&quot; 29 ) 30 31 meta: Optional[Dict] = Field( 32 None, 33 description=&quot;An optional dictionary field for storing metadata about the message.&quot; 34 ) 35 36 to: str = Field( 37 ..., 38 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 39 ) 40 41 from_: str = Field( 42 ..., 43 alias=&#39;from&#39;, 44 description=&quot;The id of the sender.&quot; 45 ) 46 47 action: Action . class Action(pydantic.main.BaseModel): View Source 6class Action(BaseModel): 7 &quot;&quot;&quot; 8 Schema for an action 9 &quot;&quot;&quot; 10 11 name: str = Field( 12 ..., 13 description=&quot;The name of the action.&quot; 14 ) 15 16 args: Dict = Field( 17 ..., 18 description=&quot;The arguments for the action.&quot; 19 ) . Schema for an action . name: str args: Dict Inherited Members . pydantic.main.BaseModel BaseModel Config dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Message(pydantic.main.BaseModel): View Source 22class Message(BaseModel): 23 &quot;&quot;&quot; 24 Schema for a message 25 &quot;&quot;&quot; 26 27 id: Optional[str] = Field( 28 None, 29 description=&quot;An optional id referenced as `original_message_id` in `response` or `error` messages.&quot; 30 ) 31 32 meta: Optional[Dict] = Field( 33 None, 34 description=&quot;An optional dictionary field for storing metadata about the message.&quot; 35 ) 36 37 to: str = Field( 38 ..., 39 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 40 ) 41 42 from_: str = Field( 43 ..., 44 alias=&#39;from&#39;, 45 description=&quot;The id of the sender.&quot; 46 ) 47 48 action: Action . Schema for a message . id: Optional[str] meta: Optional[Dict] to: str from_: str action: agency.schema.Action Inherited Members . pydantic.main.BaseModel BaseModel Config dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"36": {
    "doc": "agency.schema",
    "title": "agency.schema",
    "content": " ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"37": {
    "doc": "agency.space",
    "title": "\nagency.space    ",
    "content": "View Source 1from abc import ABC, ABCMeta, abstractmethod 2from typing import Dict 3from agency.agent import Agent 4from agency.processors.native_thread_processor import NativeThreadProcessor 5from agency.schema import Message 6 7 8class Space(ABC, metaclass=ABCMeta): 9 &quot;&quot;&quot; 10 A Space is responsible for: 11 - managing the connection lifecycle of its agents 12 - routing messages between agents 13 &quot;&quot;&quot; 14 15 def __init__(self, processor_class: type = NativeThreadProcessor): 16 self.__processor_class = processor_class 17 self.__agent_processors: Dict[str, dict] = {} 18 19 def add(self, agent: Agent): 20 &quot;&quot;&quot; 21 Adds an agent to the space allowing it to communicate 22 &quot;&quot;&quot; 23 try: 24 self._connect(agent) 25 26 def process(): 27 self._consume(agent) 28 29 processor = self.__processor_class(process) 30 self.__agent_processors[agent.id()] = { 31 &quot;agent&quot;: agent, 32 &quot;processor&quot;: processor, 33 } 34 agent._space = self 35 agent.after_add() 36 processor.start() 37 except: 38 # clean up and raise if an error occurs 39 self.remove(agent) 40 raise 41 42 def remove(self, agent: Agent): 43 &quot;&quot;&quot; 44 Removes an agent from the space. 45 &quot;&quot;&quot; 46 agent.before_remove() 47 ap = self.__agent_processors.pop(agent.id(), None) 48 if ap is not None: 49 ap[&#39;processor&#39;].stop() 50 self._disconnect(agent) 51 agent._space = None 52 53 def remove_all(self): 54 &quot;&quot;&quot; 55 Removes all agents added through this space instance. 56 &quot;&quot;&quot; 57 agents = [ap[&#39;agent&#39;] for ap in self.__agent_processors.values()] 58 for agent in agents: 59 self.remove(agent) 60 self.__agent_processors.clear() 61 62 def _route(self, message: Message) -&gt; None: 63 &quot;&quot;&quot; 64 Validates and delivers a message to the appropriate agents 65 &quot;&quot;&quot; 66 message = Message(**message).dict( 67 by_alias=True, 68 exclude_unset=True, 69 ) 70 self._deliver(message) 71 72 @abstractmethod 73 def _connect(self, agent: Agent): 74 &quot;&quot;&quot; 75 Connects an agent to the space. 76 77 This method is called when adding an agent to the space. It should 78 establish a queue or similar data structure for the agent to receive 79 messages. 80 81 Raises: 82 ValueError: If the agent ID is already in use 83 &quot;&quot;&quot; 84 85 @abstractmethod 86 def _disconnect(self, agent: Agent): 87 &quot;&quot;&quot; 88 Disconnects an agent from the space. 89 90 This method is called when removing an agent from the space. It should 91 close the queue or similar data structure for the agent. 92 &quot;&quot;&quot; 93 94 @abstractmethod 95 def _deliver(self, message: Message) -&gt; None: 96 &quot;&quot;&quot; 97 Delivers a message to the appropriate agents. 98 99 This method is called whenever an agent sends a message. It should place 100 that message on some type of queue associated with the agent id in the 101 message[&#39;to&#39;] field. 102 &quot;&quot;&quot; 103 104 @abstractmethod 105 def _consume(self, agent: Agent): 106 &quot;&quot;&quot; 107 Consumes messages from an agent&#39;s queue. 108 109 This method may be called many times per second. It should check for 110 messages on the agent&#39;s queue and pass any to agent._receive(). If no 111 messages are present it should return immediately rather than block. 112 &quot;&quot;&quot; . class Space(abc.ABC): View Source 9class Space(ABC, metaclass=ABCMeta): 10 &quot;&quot;&quot; 11 A Space is responsible for: 12 - managing the connection lifecycle of its agents 13 - routing messages between agents 14 &quot;&quot;&quot; 15 16 def __init__(self, processor_class: type = NativeThreadProcessor): 17 self.__processor_class = processor_class 18 self.__agent_processors: Dict[str, dict] = {} 19 20 def add(self, agent: Agent): 21 &quot;&quot;&quot; 22 Adds an agent to the space allowing it to communicate 23 &quot;&quot;&quot; 24 try: 25 self._connect(agent) 26 27 def process(): 28 self._consume(agent) 29 30 processor = self.__processor_class(process) 31 self.__agent_processors[agent.id()] = { 32 &quot;agent&quot;: agent, 33 &quot;processor&quot;: processor, 34 } 35 agent._space = self 36 agent.after_add() 37 processor.start() 38 except: 39 # clean up and raise if an error occurs 40 self.remove(agent) 41 raise 42 43 def remove(self, agent: Agent): 44 &quot;&quot;&quot; 45 Removes an agent from the space. 46 &quot;&quot;&quot; 47 agent.before_remove() 48 ap = self.__agent_processors.pop(agent.id(), None) 49 if ap is not None: 50 ap[&#39;processor&#39;].stop() 51 self._disconnect(agent) 52 agent._space = None 53 54 def remove_all(self): 55 &quot;&quot;&quot; 56 Removes all agents added through this space instance. 57 &quot;&quot;&quot; 58 agents = [ap[&#39;agent&#39;] for ap in self.__agent_processors.values()] 59 for agent in agents: 60 self.remove(agent) 61 self.__agent_processors.clear() 62 63 def _route(self, message: Message) -&gt; None: 64 &quot;&quot;&quot; 65 Validates and delivers a message to the appropriate agents 66 &quot;&quot;&quot; 67 message = Message(**message).dict( 68 by_alias=True, 69 exclude_unset=True, 70 ) 71 self._deliver(message) 72 73 @abstractmethod 74 def _connect(self, agent: Agent): 75 &quot;&quot;&quot; 76 Connects an agent to the space. 77 78 This method is called when adding an agent to the space. It should 79 establish a queue or similar data structure for the agent to receive 80 messages. 81 82 Raises: 83 ValueError: If the agent ID is already in use 84 &quot;&quot;&quot; 85 86 @abstractmethod 87 def _disconnect(self, agent: Agent): 88 &quot;&quot;&quot; 89 Disconnects an agent from the space. 90 91 This method is called when removing an agent from the space. It should 92 close the queue or similar data structure for the agent. 93 &quot;&quot;&quot; 94 95 @abstractmethod 96 def _deliver(self, message: Message) -&gt; None: 97 &quot;&quot;&quot; 98 Delivers a message to the appropriate agents. 99 100 This method is called whenever an agent sends a message. It should place 101 that message on some type of queue associated with the agent id in the 102 message[&#39;to&#39;] field. 103 &quot;&quot;&quot; 104 105 @abstractmethod 106 def _consume(self, agent: Agent): 107 &quot;&quot;&quot; 108 Consumes messages from an agent&#39;s queue. 109 110 This method may be called many times per second. It should check for 111 messages on the agent&#39;s queue and pass any to agent._receive(). If no 112 messages are present it should return immediately rather than block. 113 &quot;&quot;&quot; . A Space is responsible for: . | managing the connection lifecycle of its agents | routing messages between agents | . def add(self, agent: agency.agent.Agent): View Source 20 def add(self, agent: Agent): 21 &quot;&quot;&quot; 22 Adds an agent to the space allowing it to communicate 23 &quot;&quot;&quot; 24 try: 25 self._connect(agent) 26 27 def process(): 28 self._consume(agent) 29 30 processor = self.__processor_class(process) 31 self.__agent_processors[agent.id()] = { 32 &quot;agent&quot;: agent, 33 &quot;processor&quot;: processor, 34 } 35 agent._space = self 36 agent.after_add() 37 processor.start() 38 except: 39 # clean up and raise if an error occurs 40 self.remove(agent) 41 raise . Adds an agent to the space allowing it to communicate . def remove(self, agent: agency.agent.Agent): View Source 43 def remove(self, agent: Agent): 44 &quot;&quot;&quot; 45 Removes an agent from the space. 46 &quot;&quot;&quot; 47 agent.before_remove() 48 ap = self.__agent_processors.pop(agent.id(), None) 49 if ap is not None: 50 ap[&#39;processor&#39;].stop() 51 self._disconnect(agent) 52 agent._space = None . Removes an agent from the space. def remove_all(self): View Source 54 def remove_all(self): 55 &quot;&quot;&quot; 56 Removes all agents added through this space instance. 57 &quot;&quot;&quot; 58 agents = [ap[&#39;agent&#39;] for ap in self.__agent_processors.values()] 59 for agent in agents: 60 self.remove(agent) 61 self.__agent_processors.clear() . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"38": {
    "doc": "agency.space",
    "title": "agency.space",
    "content": " ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"39": {
    "doc": "agency.spaces",
    "title": "\nagency.spaces    ",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"40": {
    "doc": "agency.spaces",
    "title": "Submodules",
    "content": ". | amqp_space | native_space | . ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"41": {
    "doc": "agency.spaces",
    "title": "agency.spaces",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"42": {
    "doc": "agency.spaces.amqp_space",
    "title": "\nagency.spaces.amqp_space    ",
    "content": "View Source 1import json 2import os 3import socket 4from dataclasses import dataclass 5from typing import Dict 6import amqp 7 8from kombu import Connection, Exchange, Queue 9 10from agency.agent import Agent 11from agency.processors.native_thread_processor import NativeThreadProcessor 12from agency.schema import Message 13from agency.space import Space 14from agency.util import print_warning 15 16 17@dataclass 18class AMQPOptions: 19 &quot;&quot;&quot; 20 A class that defines AMQP connection options 21 &quot;&quot;&quot; 22 hostname: str = &#39;localhost&#39; 23 port: int = &#39;5672&#39; 24 username: str = &#39;guest&#39; 25 password: str = &#39;guest&#39; 26 virtual_host: str = &#39;/&#39; 27 use_ssl: bool = False 28 heartbeat: float = 60 29 30 31class AMQPSpace(Space): 32 &quot;&quot;&quot; 33 A Space that uses AMQP for message delivery 34 &quot;&quot;&quot; 35 36 BROADCAST_KEY = &quot;__broadcast__&quot; 37 38 def __init__(self, amqp_options: AMQPOptions = None, exchange: str = &quot;agency&quot;, processor_class: type = NativeThreadProcessor): 39 super().__init__() 40 if amqp_options is None: 41 amqp_options = self.default_amqp_options() 42 self.__kombu_connection_options = { 43 &#39;hostname&#39;: amqp_options.hostname, 44 &#39;port&#39;: amqp_options.port, 45 &#39;userid&#39;: amqp_options.username, 46 &#39;password&#39;: amqp_options.password, 47 &#39;virtual_host&#39;: amqp_options.virtual_host, 48 &#39;ssl&#39;: amqp_options.use_ssl, 49 &#39;heartbeat&#39;: amqp_options.heartbeat, 50 } 51 self.__topic_exchange = Exchange(exchange, type=&quot;topic&quot;, durable=False) 52 self.__agent_connections: Dict[str, Connection] = {} 53 54 @classmethod 55 def default_amqp_options(cls) -&gt; AMQPOptions: 56 &quot;&quot;&quot; 57 Returns a default AMQPOptions object configurable from environment 58 variables. 59 &quot;&quot;&quot; 60 return AMQPOptions( 61 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 62 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 63 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 64 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 65 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 66 use_ssl=False, 67 heartbeat=60, 68 ) 69 70 def _connect(self, agent: Agent): 71 try: 72 # Create a connection 73 connection = Connection(**self.__kombu_connection_options) 74 connection.connect() 75 if not connection.connected: 76 raise ConnectionError(&quot;Unable to connect to AMQP server&quot;) 77 self.__agent_connections[agent.id()] = connection 78 79 # Create a queue for direct messages 80 direct_queue = Queue( 81 f&quot;{agent.id()}-direct&quot;, 82 exchange=self.__topic_exchange, 83 routing_key=agent.id(), 84 exclusive=True, 85 ) 86 direct_queue(connection.channel()).declare() 87 88 # Create a separate broadcast queue 89 broadcast_queue = Queue( 90 f&quot;{agent.id()}-broadcast&quot;, 91 exchange=self.__topic_exchange, 92 routing_key=self.BROADCAST_KEY, 93 exclusive=True, 94 ) 95 broadcast_queue(connection.channel()).declare() 96 97 # Define callback for incoming messages 98 def _on_message(body, message): 99 message.ack() 100 message_data = json.loads(body) 101 if message_data[&#39;to&#39;] == &#39;*&#39; or message_data[&#39;to&#39;] == agent.id(): 102 agent._receive(message_data) 103 104 # Consume from direct and broadcast queues 105 consumer = connection.Consumer( 106 [direct_queue, broadcast_queue], 107 callbacks=[_on_message], 108 ) 109 110 # Start the consumer 111 consumer.consume() 112 113 except amqp.exceptions.ResourceLocked as e: 114 raise ValueError(f&quot;Agent id already exists: &#39;{agent.id()}&#39;)&quot;) 115 116 def _disconnect(self, agent: Agent): 117 connection = self.__agent_connections.pop(agent.id(), None) 118 if connection is not None: 119 connection.release() 120 121 def _deliver(self, message: Message) -&gt; dict: 122 if message[&#39;to&#39;] == &#39;*&#39;: 123 # broadcast 124 routing_key = self.BROADCAST_KEY 125 else: 126 # point to point 127 routing_key = message[&#39;to&#39;] 128 129 with Connection(**self.__kombu_connection_options) as connection: 130 with connection.Producer(serializer=&quot;json&quot;) as producer: 131 producer.publish( 132 json.dumps(message), 133 exchange=self.__topic_exchange, 134 routing_key=routing_key, 135 ) 136 137 def _consume(self, agent: Agent): 138 connection = self.__agent_connections[agent.id()] 139 connection.heartbeat_check() # sends heartbeat if necessary 140 try: 141 connection.drain_events(timeout=0.001) 142 except socket.timeout: 143 pass . @dataclass class AMQPOptions: View Source 18@dataclass 19class AMQPOptions: 20 &quot;&quot;&quot; 21 A class that defines AMQP connection options 22 &quot;&quot;&quot; 23 hostname: str = &#39;localhost&#39; 24 port: int = &#39;5672&#39; 25 username: str = &#39;guest&#39; 26 password: str = &#39;guest&#39; 27 virtual_host: str = &#39;/&#39; 28 use_ssl: bool = False 29 heartbeat: float = 60 . A class that defines AMQP connection options . AMQPOptions( hostname: str = &#39;localhost&#39;, port: int = &#39;5672&#39;, username: str = &#39;guest&#39;, password: str = &#39;guest&#39;, virtual_host: str = &#39;/&#39;, use_ssl: bool = False, heartbeat: float = 60) hostname: str = &#39;localhost&#39; port: int = &#39;5672&#39; username: str = &#39;guest&#39; password: str = &#39;guest&#39; virtual_host: str = &#39;/&#39; use_ssl: bool = False heartbeat: float = 60 class AMQPSpace(agency.space.Space): View Source 32class AMQPSpace(Space): 33 &quot;&quot;&quot; 34 A Space that uses AMQP for message delivery 35 &quot;&quot;&quot; 36 37 BROADCAST_KEY = &quot;__broadcast__&quot; 38 39 def __init__(self, amqp_options: AMQPOptions = None, exchange: str = &quot;agency&quot;, processor_class: type = NativeThreadProcessor): 40 super().__init__() 41 if amqp_options is None: 42 amqp_options = self.default_amqp_options() 43 self.__kombu_connection_options = { 44 &#39;hostname&#39;: amqp_options.hostname, 45 &#39;port&#39;: amqp_options.port, 46 &#39;userid&#39;: amqp_options.username, 47 &#39;password&#39;: amqp_options.password, 48 &#39;virtual_host&#39;: amqp_options.virtual_host, 49 &#39;ssl&#39;: amqp_options.use_ssl, 50 &#39;heartbeat&#39;: amqp_options.heartbeat, 51 } 52 self.__topic_exchange = Exchange(exchange, type=&quot;topic&quot;, durable=False) 53 self.__agent_connections: Dict[str, Connection] = {} 54 55 @classmethod 56 def default_amqp_options(cls) -&gt; AMQPOptions: 57 &quot;&quot;&quot; 58 Returns a default AMQPOptions object configurable from environment 59 variables. 60 &quot;&quot;&quot; 61 return AMQPOptions( 62 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 63 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 64 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 65 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 66 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 67 use_ssl=False, 68 heartbeat=60, 69 ) 70 71 def _connect(self, agent: Agent): 72 try: 73 # Create a connection 74 connection = Connection(**self.__kombu_connection_options) 75 connection.connect() 76 if not connection.connected: 77 raise ConnectionError(&quot;Unable to connect to AMQP server&quot;) 78 self.__agent_connections[agent.id()] = connection 79 80 # Create a queue for direct messages 81 direct_queue = Queue( 82 f&quot;{agent.id()}-direct&quot;, 83 exchange=self.__topic_exchange, 84 routing_key=agent.id(), 85 exclusive=True, 86 ) 87 direct_queue(connection.channel()).declare() 88 89 # Create a separate broadcast queue 90 broadcast_queue = Queue( 91 f&quot;{agent.id()}-broadcast&quot;, 92 exchange=self.__topic_exchange, 93 routing_key=self.BROADCAST_KEY, 94 exclusive=True, 95 ) 96 broadcast_queue(connection.channel()).declare() 97 98 # Define callback for incoming messages 99 def _on_message(body, message): 100 message.ack() 101 message_data = json.loads(body) 102 if message_data[&#39;to&#39;] == &#39;*&#39; or message_data[&#39;to&#39;] == agent.id(): 103 agent._receive(message_data) 104 105 # Consume from direct and broadcast queues 106 consumer = connection.Consumer( 107 [direct_queue, broadcast_queue], 108 callbacks=[_on_message], 109 ) 110 111 # Start the consumer 112 consumer.consume() 113 114 except amqp.exceptions.ResourceLocked as e: 115 raise ValueError(f&quot;Agent id already exists: &#39;{agent.id()}&#39;)&quot;) 116 117 def _disconnect(self, agent: Agent): 118 connection = self.__agent_connections.pop(agent.id(), None) 119 if connection is not None: 120 connection.release() 121 122 def _deliver(self, message: Message) -&gt; dict: 123 if message[&#39;to&#39;] == &#39;*&#39;: 124 # broadcast 125 routing_key = self.BROADCAST_KEY 126 else: 127 # point to point 128 routing_key = message[&#39;to&#39;] 129 130 with Connection(**self.__kombu_connection_options) as connection: 131 with connection.Producer(serializer=&quot;json&quot;) as producer: 132 producer.publish( 133 json.dumps(message), 134 exchange=self.__topic_exchange, 135 routing_key=routing_key, 136 ) 137 138 def _consume(self, agent: Agent): 139 connection = self.__agent_connections[agent.id()] 140 connection.heartbeat_check() # sends heartbeat if necessary 141 try: 142 connection.drain_events(timeout=0.001) 143 except socket.timeout: 144 pass . A Space that uses AMQP for message delivery . AMQPSpace( amqp_options: agency.spaces.amqp_space.AMQPOptions = None, exchange: str = &#39;agency&#39;, processor_class: type = &lt;class &#x27;agency.processors.native_thread_processor.NativeThreadProcessor&#x27;&gt;) View Source 39 def __init__(self, amqp_options: AMQPOptions = None, exchange: str = &quot;agency&quot;, processor_class: type = NativeThreadProcessor): 40 super().__init__() 41 if amqp_options is None: 42 amqp_options = self.default_amqp_options() 43 self.__kombu_connection_options = { 44 &#39;hostname&#39;: amqp_options.hostname, 45 &#39;port&#39;: amqp_options.port, 46 &#39;userid&#39;: amqp_options.username, 47 &#39;password&#39;: amqp_options.password, 48 &#39;virtual_host&#39;: amqp_options.virtual_host, 49 &#39;ssl&#39;: amqp_options.use_ssl, 50 &#39;heartbeat&#39;: amqp_options.heartbeat, 51 } 52 self.__topic_exchange = Exchange(exchange, type=&quot;topic&quot;, durable=False) 53 self.__agent_connections: Dict[str, Connection] = {} . BROADCAST_KEY = &#39;__broadcast__&#39; @classmethod def default_amqp_options(cls) -> agency.spaces.amqp_space.AMQPOptions: View Source 55 @classmethod 56 def default_amqp_options(cls) -&gt; AMQPOptions: 57 &quot;&quot;&quot; 58 Returns a default AMQPOptions object configurable from environment 59 variables. 60 &quot;&quot;&quot; 61 return AMQPOptions( 62 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 63 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 64 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 65 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 66 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 67 use_ssl=False, 68 heartbeat=60, 69 ) . Returns a default AMQPOptions object configurable from environment variables. Inherited Members . agency.space.Space add remove remove_all ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"43": {
    "doc": "agency.spaces.amqp_space",
    "title": "agency.spaces.amqp_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"44": {
    "doc": "agency.spaces.native_space",
    "title": "\nagency.spaces.native_space    ",
    "content": "View Source 1import queue 2from typing import Dict 3from agency.agent import Agent 4from agency.processors.native_thread_processor import NativeThreadProcessor 5from agency.schema import Message 6from agency.space import Space 7 8 9class NativeSpace(Space): 10 &quot;&quot;&quot; 11 A Space implementation that uses Python&#39;s built-in queue module. 12 Suitable for single-process applications and testing. 13 &quot;&quot;&quot; 14 15 def __init__(self, processor_class: type = NativeThreadProcessor): 16 super().__init__(processor_class=processor_class) 17 self.__agent_queues: Dict[str, queue.Queue] = {} 18 19 def _connect(self, agent: Agent): 20 if agent.id() in self.__agent_queues.keys(): 21 raise ValueError(f&quot;Agent id already exists: &#39;{agent.id()}&#39;)&quot;) 22 self.__agent_queues[agent.id()] = queue.Queue() 23 24 def _disconnect(self, agent: Agent): 25 del self.__agent_queues[agent.id()] 26 27 def _deliver(self, message: Message) -&gt; None: 28 for agent_id in self.__agent_queues.keys(): 29 if message[&#39;to&#39;] == &#39;*&#39; or message[&#39;to&#39;] == agent_id: 30 self.__agent_queues[agent_id].put(message) 31 32 def _consume(self, agent: Agent): 33 agent_queue = self.__agent_queues[agent.id()] 34 try: 35 message = agent_queue.get(block=False) 36 if message[&#39;to&#39;] == &#39;*&#39; or message[&#39;to&#39;] == agent.id(): 37 agent._receive(message) 38 except queue.Empty: 39 pass . class NativeSpace(agency.space.Space): View Source 10class NativeSpace(Space): 11 &quot;&quot;&quot; 12 A Space implementation that uses Python&#39;s built-in queue module. 13 Suitable for single-process applications and testing. 14 &quot;&quot;&quot; 15 16 def __init__(self, processor_class: type = NativeThreadProcessor): 17 super().__init__(processor_class=processor_class) 18 self.__agent_queues: Dict[str, queue.Queue] = {} 19 20 def _connect(self, agent: Agent): 21 if agent.id() in self.__agent_queues.keys(): 22 raise ValueError(f&quot;Agent id already exists: &#39;{agent.id()}&#39;)&quot;) 23 self.__agent_queues[agent.id()] = queue.Queue() 24 25 def _disconnect(self, agent: Agent): 26 del self.__agent_queues[agent.id()] 27 28 def _deliver(self, message: Message) -&gt; None: 29 for agent_id in self.__agent_queues.keys(): 30 if message[&#39;to&#39;] == &#39;*&#39; or message[&#39;to&#39;] == agent_id: 31 self.__agent_queues[agent_id].put(message) 32 33 def _consume(self, agent: Agent): 34 agent_queue = self.__agent_queues[agent.id()] 35 try: 36 message = agent_queue.get(block=False) 37 if message[&#39;to&#39;] == &#39;*&#39; or message[&#39;to&#39;] == agent.id(): 38 agent._receive(message) 39 except queue.Empty: 40 pass . A Space implementation that uses Python's built-in queue module. Suitable for single-process applications and testing. NativeSpace( processor_class: type = &lt;class &#x27;agency.processors.native_thread_processor.NativeThreadProcessor&#x27;&gt;) View Source 16 def __init__(self, processor_class: type = NativeThreadProcessor): 17 super().__init__(processor_class=processor_class) 18 self.__agent_queues: Dict[str, queue.Queue] = {} . Inherited Members . agency.space.Space add remove remove_all ",
    "url": "/api_docs/agency/spaces/native_space.html",
    
    "relUrl": "/api_docs/agency/spaces/native_space.html"
  },"45": {
    "doc": "agency.spaces.native_space",
    "title": "agency.spaces.native_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/native_space.html",
    
    "relUrl": "/api_docs/agency/spaces/native_space.html"
  },"46": {
    "doc": "agency.util",
    "title": "\nagency.util    ",
    "content": "View Source 1from datetime import datetime 2from typing import get_type_hints 3import inspect 4import json 5import re 6 7 8SYSTEM_TIMESTAMP_FORMAT = &#39;%Y-%m-%d %H:%M:%S&#39; 9NATURAL_TIMESTAMP_FORMAT = &#39;%A %B %d, %Y, %H:%M%p&#39; 10 11 12def to_timestamp(dt=datetime.now(), date_format=SYSTEM_TIMESTAMP_FORMAT): 13 return dt.strftime(date_format) 14 15 16def from_timestamp(timestamp_str, date_format=SYSTEM_TIMESTAMP_FORMAT): 17 return datetime.datetime.strptime(timestamp_str, date_format) 18 19 20def extract_json(input: str, stopping_strings: list = []): 21 stopping_string = next((s for s in stopping_strings if s in input), &#39;&#39;) 22 split_string = input.split(stopping_string, 1)[ 23 0] if stopping_string else input 24 start_position = split_string.find(&#39;{&#39;) 25 end_position = split_string.rfind(&#39;}&#39;) + 1 26 27 if start_position == -1 or end_position == -1 or start_position &gt; end_position: 28 raise ValueError(f&quot;Couldn&#39;t find valid JSON in \\&quot;{input}\\&quot;&quot;) 29 30 try: 31 return json.loads(split_string[start_position:end_position]) 32 except json.JSONDecodeError: 33 raise ValueError(f&quot;Couldn&#39;t parse JSON in \\&quot;{input}\\&quot;&quot;) 34 35 36def strip_ansi_codes(text): 37 ansi_escape = re.compile(r&#39;\\x1b\\[[0-9;]*m&#39;) 38 return ansi_escape.sub(&#39;&#39;, text) 39 40 41def print_warning(text): 42 print(f&quot;\\033[93mWARNING: {text}\\033[0m&quot;) 43 44 45# enables debug messages for the listed keys 46DEBUG_KEYS = { 47 &quot;*&quot;, # special key, uncomment to force enable all debug messages 48 # &quot;-&quot;, # special key, uncomment to force disable all debug messages 49 50 # you can also list keys to watch directly below: 51 # &quot;abc&quot;, 52 # ... 53} 54 55 56def debug(name, object=None): 57 &quot;&quot;&quot;pretty prints an object to the terminal for inspection&quot;&quot;&quot; 58 if ( 59 name 60 and ( 61 name in DEBUG_KEYS and 62 &quot;-&quot; not in DEBUG_KEYS # - overrides others and globally disables 63 and not name.startswith(&quot;*&quot;) # starting with * overrides - 64 ) or ( 65 name not in DEBUG_KEYS 66 and name.startswith(&quot;*&quot;) # * forces debug message 67 or ( 68 &quot;*&quot; in DEBUG_KEYS 69 and &quot;-&quot; not in DEBUG_KEYS # - overrides * here 70 # -{name} disables specific messages when * is on 71 and f&quot;-{name}&quot; not in DEBUG_KEYS 72 ) 73 ) 74 ): 75 print(debug_text(name, object), flush=True) 76 77 78class CustomEncoder(json.JSONEncoder): 79 def default(self, obj): 80 try: 81 return super().default(obj) 82 except TypeError: 83 return str(obj) 84 85 86def debug_text(name, object=None): 87 &quot;&quot;&quot; 88 Returns a pretty printed string for debugging 89 &quot;&quot;&quot; 90 START_STYLE = &quot;\\033[33m&quot; # yellow 91 RESET_STYLE = &quot;\\033[0m&quot; 92 debug_value = &quot;&quot; 93 if object != None: 94 debug_object_value = object 95 try: 96 # since this is always for a human we hardcode 2 space indentation 97 debug_object_value = json.dumps( 98 object, indent=2, cls=CustomEncoder) 99 except Exception as e: 100 print(f&quot;debug_text: {e}&quot;) 101 pass 102 debug_value = f&quot;{debug_object_value}\\n{RESET_STYLE}{&#39;_&#39;*5} {name} {&#39;_&#39;*5}&quot; 103 return f&quot;\\n{START_STYLE}{&#39;&gt;&#39;*5} {name} {&#39;&lt;&#39;*5}{RESET_STYLE}\\n{debug_value}{RESET_STYLE}&quot;.replace(&quot;\\\\n&quot;, &quot;\\n&quot;) 104 105 106def python_to_json_type_name(python_type_name: str) -&gt; str: 107 return { 108 &#39;str&#39;: &#39;string&#39;, 109 &#39;int&#39;: &#39;number&#39;, 110 &#39;float&#39;: &#39;number&#39;, 111 &#39;bool&#39;: &#39;boolean&#39;, 112 &#39;list&#39;: &#39;array&#39;, 113 &#39;dict&#39;: &#39;object&#39; 114 }[python_type_name] . SYSTEM_TIMESTAMP_FORMAT = &#39;%Y-%m-%d %H:%M:%S&#39; NATURAL_TIMESTAMP_FORMAT = &#39;%A %B %d, %Y, %H:%M%p&#39; def to_timestamp( dt=datetime.datetime(2023, 8, 19, 2, 21, 44, 413840), date_format=&#39;%Y-%m-%d %H:%M:%S&#39;): View Source 13def to_timestamp(dt=datetime.now(), date_format=SYSTEM_TIMESTAMP_FORMAT): 14 return dt.strftime(date_format) . def from_timestamp(timestamp_str, date_format=&#39;%Y-%m-%d %H:%M:%S&#39;): View Source 17def from_timestamp(timestamp_str, date_format=SYSTEM_TIMESTAMP_FORMAT): 18 return datetime.datetime.strptime(timestamp_str, date_format) . def extract_json(input: str, stopping_strings: list = []): View Source 21def extract_json(input: str, stopping_strings: list = []): 22 stopping_string = next((s for s in stopping_strings if s in input), &#39;&#39;) 23 split_string = input.split(stopping_string, 1)[ 24 0] if stopping_string else input 25 start_position = split_string.find(&#39;{&#39;) 26 end_position = split_string.rfind(&#39;}&#39;) + 1 27 28 if start_position == -1 or end_position == -1 or start_position &gt; end_position: 29 raise ValueError(f&quot;Couldn&#39;t find valid JSON in \\&quot;{input}\\&quot;&quot;) 30 31 try: 32 return json.loads(split_string[start_position:end_position]) 33 except json.JSONDecodeError: 34 raise ValueError(f&quot;Couldn&#39;t parse JSON in \\&quot;{input}\\&quot;&quot;) . def strip_ansi_codes(text): View Source 37def strip_ansi_codes(text): 38 ansi_escape = re.compile(r&#39;\\x1b\\[[0-9;]*m&#39;) 39 return ansi_escape.sub(&#39;&#39;, text) . def print_warning(text): View Source 42def print_warning(text): 43 print(f&quot;\\033[93mWARNING: {text}\\033[0m&quot;) . DEBUG_KEYS = {&#39;*&#39;} def debug(name, object=None): View Source 57def debug(name, object=None): 58 &quot;&quot;&quot;pretty prints an object to the terminal for inspection&quot;&quot;&quot; 59 if ( 60 name 61 and ( 62 name in DEBUG_KEYS and 63 &quot;-&quot; not in DEBUG_KEYS # - overrides others and globally disables 64 and not name.startswith(&quot;*&quot;) # starting with * overrides - 65 ) or ( 66 name not in DEBUG_KEYS 67 and name.startswith(&quot;*&quot;) # * forces debug message 68 or ( 69 &quot;*&quot; in DEBUG_KEYS 70 and &quot;-&quot; not in DEBUG_KEYS # - overrides * here 71 # -{name} disables specific messages when * is on 72 and f&quot;-{name}&quot; not in DEBUG_KEYS 73 ) 74 ) 75 ): 76 print(debug_text(name, object), flush=True) . pretty prints an object to the terminal for inspection . class CustomEncoder(json.encoder.JSONEncoder): View Source 79class CustomEncoder(json.JSONEncoder): 80 def default(self, obj): 81 try: 82 return super().default(obj) 83 except TypeError: 84 return str(obj) . Extensible JSON http://json.org encoder for Python data structures. Supports the following objects and types by default: . +-------------------+---------------+ | Python | JSON | +===================+===============+ | dict | object | +-------------------+---------------+ | list, tuple | array | +-------------------+---------------+ | str | string | +-------------------+---------------+ | int, float | number | +-------------------+---------------+ | True | true | +-------------------+---------------+ | False | false | +-------------------+---------------+ | None | null | +-------------------+---------------+ . To extend this to recognize other objects, subclass and implement a .default() method with another method that returns a serializable object for o if possible, otherwise it should call the superclass implementation (to raise TypeError). def default(self, obj): View Source 80 def default(self, obj): 81 try: 82 return super().default(obj) 83 except TypeError: 84 return str(obj) . Implement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a TypeError). For example, to support arbitrary iterators, you could implement default like this:: . def default(self, o): try: iterable = iter(o) except TypeError: pass else: return list(iterable) # Let the base class default method raise the TypeError return JSONEncoder.default(self, o) . Inherited Members . json.encoder.JSONEncoder JSONEncoder item_separator key_separator skipkeys ensure_ascii check_circular allow_nan sort_keys indent encode iterencode def debug_text(name, object=None): View Source 87def debug_text(name, object=None): 88 &quot;&quot;&quot; 89 Returns a pretty printed string for debugging 90 &quot;&quot;&quot; 91 START_STYLE = &quot;\\033[33m&quot; # yellow 92 RESET_STYLE = &quot;\\033[0m&quot; 93 debug_value = &quot;&quot; 94 if object != None: 95 debug_object_value = object 96 try: 97 # since this is always for a human we hardcode 2 space indentation 98 debug_object_value = json.dumps( 99 object, indent=2, cls=CustomEncoder) 100 except Exception as e: 101 print(f&quot;debug_text: {e}&quot;) 102 pass 103 debug_value = f&quot;{debug_object_value}\\n{RESET_STYLE}{&#39;_&#39;*5} {name} {&#39;_&#39;*5}&quot; 104 return f&quot;\\n{START_STYLE}{&#39;&gt;&#39;*5} {name} {&#39;&lt;&#39;*5}{RESET_STYLE}\\n{debug_value}{RESET_STYLE}&quot;.replace(&quot;\\\\n&quot;, &quot;\\n&quot;) . Returns a pretty printed string for debugging . def python_to_json_type_name(python_type_name: str) -> str: View Source 107def python_to_json_type_name(python_type_name: str) -&gt; str: 108 return { 109 &#39;str&#39;: &#39;string&#39;, 110 &#39;int&#39;: &#39;number&#39;, 111 &#39;float&#39;: &#39;number&#39;, 112 &#39;bool&#39;: &#39;boolean&#39;, 113 &#39;list&#39;: &#39;array&#39;, 114 &#39;dict&#39;: &#39;object&#39; 115 }[python_type_name] . ",
    "url": "/api_docs/agency/util.html",
    
    "relUrl": "/api_docs/agency/util.html"
  },"47": {
    "doc": "agency.util",
    "title": "agency.util",
    "content": " ",
    "url": "/api_docs/agency/util.html",
    
    "relUrl": "/api_docs/agency/util.html"
  }
}
