{"0": {
    "doc": "Agent Callbacks",
    "title": "Agent Callbacks",
    "content": "The following list describes all available agent callbacks, with a link to their API documentation. Please see the API docs for more detailed descriptions of these callbacks. after_add . Called after an agent is added to a space, but before it begins processing messages. before_remove . Called before an agent is removed from a space and will no longer process more messages. handle_action_value . If an action method returns a value, this method will be called with the value. handle_action_error . Receives any error messages from an action invoked by the agent. before_action . Called before an action is attempted. after_action . Called after an action is attempted. request_permission . Called when an agent attempts to perform an action that requires permission. ",
    "url": "/articles/agent_callbacks",
    
    "relUrl": "/articles/agent_callbacks"
  },"1": {
    "doc": "Defining Actions",
    "title": "Defining Actions",
    "content": "The @action decorator is used to define actions on instance methods of the Agent class, and takes the following keyword arguments: . | name: The name of the action. Defaults to the method name | help: The description of the action. Defaults to an autogenerated object | access_policy: The access policy of the action. Defaults to ACCESS_PERMITTED | . ",
    "url": "/articles/defining_actions",
    
    "relUrl": "/articles/defining_actions"
  },"2": {
    "doc": "Defining Actions",
    "title": "Defining Help Information",
    "content": "Below is an example of the help information generated by default from the @action decorator. It uses the docstring of the method, and its signature to generate the default help information. { \"shell_command\": { \"description\": \"Execute a shell command\", \"args\": { \"command\": { \"type\": \"string\" \"description\": \"The command to execute\" } }, \"returns\": { \"type\": \"string\" \"description\": \"The output of the command\" } }, ... } . The following example shows how the help information above can be specified from a docstring that follows the Google style guide: . @action def shell_command(self, command: str) -&gt; str: \"\"\" Execute a shell command Args: command (str): The command to execute Returns: str: The output of the command \"\"\" . When generating help information, the action name is determined by the method name. Types are determined by looking at the docstring and the signature, with the signature type hint taking precedence. Action and argument descriptions are parsed from the docstring. Overriding Help Information . The default help data structure described above can be overridden by supplying a custom help object to the @action decorator. @action( help={ \"You\": \"can define\", \"any\": { \"structure\": [\"you\", \"want\", \"here.\"] } } ) def say(self, content: str) -&gt; None: . When a custom help object is provided, it overrides the generated object entirely. You can use this to experiment with different help information schemas. ",
    "url": "/articles/defining_actions#defining-help-information",
    
    "relUrl": "/articles/defining_actions#defining-help-information"
  },"3": {
    "doc": "Defining Actions",
    "title": "Access Control",
    "content": "❗️Access control is experimental. Please share your feedback. Access policies may be used to control when actions can be invoked by agents. All actions may declare an access policy like the following example: . @action(access_policy=ACCESS_PERMITTED) def my_action(self): ... An access policy can currently be one of three values: . | ACCESS_PERMITTED - (Default) Permits any agent to use that action at any time. | ACCESS_DENIED - Prevents access to that action. | ACCESS_REQUESTED - Prompts the receiving agent for permission when access is attempted. Access will await approval or denial. | . If ACCESS_REQUESTED is used, the receiving agent will be prompted to approve the action via the request_permission() callback method. If any actions declare a policy of ACCESS_REQUESTED, you must implement the request_permission() method with the following signature in order to receive permission requests. def request_permission(self, proposed_message: dict) -&gt; bool: ... Your implementation should inspect proposed_message and return a boolean indicating whether or not to permit the action. You can use this approach to protect against dangerous actions being taken. For example if you allow terminal access, you may want to review commands before they are invoked. ",
    "url": "/articles/defining_actions#access-control",
    
    "relUrl": "/articles/defining_actions#access-control"
  },"4": {
    "doc": "Messaging",
    "title": "Messaging",
    "content": "The following details cover the message schema and other messaging behavior. ",
    "url": "/articles/messaging",
    
    "relUrl": "/articles/messaging"
  },"5": {
    "doc": "Messaging",
    "title": "Message Schema",
    "content": "All messages are validated upon sending and must conform to the message schema. Note that when sending, you normally do not supply the entire structure. The meta.id, meta.parent_id, and from fields are automatically populated for you. The full message schema is summarized by this example: . { \"meta\": { \"id\": \"a string to identify the message\", \"parent_id\": \"meta.id of the parent message, if any\", \"anything\": \"else here\", }, \"from\": \"TheSender\", # The following fields must be specified when sending \"to\": \"TheReceiver\", \"action\": { \"name\": \"the_action_name\", \"args\": { \"the\": \"args\", } } } . An example of calling Agent.send() with only the minimum fields would look like: . self.send({ \"to\": \"some_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } }) . See agency/schema.py for the pydantic model definition used for validation. ",
    "url": "/articles/messaging#message-schema",
    
    "relUrl": "/articles/messaging#message-schema"
  },"6": {
    "doc": "Messaging",
    "title": "The to and from Fields",
    "content": "The to and from fields are used for addressing messages. All messages require the to field to be specified. The to field should be the id of an agent in the space (point-to-point) or the special id * for a broadcast (see below). The from field is populated for you when sending. ",
    "url": "/articles/messaging#the-to-and-from-fields",
    
    "relUrl": "/articles/messaging#the-to-and-from-fields"
  },"7": {
    "doc": "Messaging",
    "title": "The action Field",
    "content": "The action field contains the body of the action invocation. It carries the action name and the arguments to pass as a dictionary object called args. ",
    "url": "/articles/messaging#the-action-field",
    
    "relUrl": "/articles/messaging#the-action-field"
  },"8": {
    "doc": "Messaging",
    "title": "The meta Field",
    "content": "The meta field may be used to store arbitrary key-value metadata about the message. It is optional to define, though the meta.id and meta.parent_id fields will be populated automatically by default. Example uses of the meta field include: . | Storing “thoughts” associated with an action. This is a common pattern used with LLM agents. For example, an LLM agent may send the following message: { \"meta\": { \"thoughts\": \"I should say hello to everyone\", }, \"to\": \"*\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } } . | Storing timestamps associated with an action. For example: { \"meta\": { \"timestamp\": 12345, }, ... } . | . ",
    "url": "/articles/messaging#the-meta-field",
    
    "relUrl": "/articles/messaging#the-meta-field"
  },"9": {
    "doc": "Messaging",
    "title": "Broadcast vs Point-to-Point",
    "content": "Sending a message to the special id * will broadcast the message to all agents in the space. By default, agents receive their own broadcasts, but you may change this behavior with the receive_own_broadcasts argument when creating the agent. For example: . my_agent = MyAgent(\"MyAgent\", receive_own_broadcasts=False) . ",
    "url": "/articles/messaging#broadcast-vs-point-to-point",
    
    "relUrl": "/articles/messaging#broadcast-vs-point-to-point"
  },"10": {
    "doc": "Messaging",
    "title": "Non-Existent Agents or Actions",
    "content": "If you send a message to a non-existent agent, it will silently fail. If you send a message to an existent agent, but specify a non-existent action, you will receive an error message in response. If you send a broadcast that specifies a non-existent action, agents will silently ignore the error. ",
    "url": "/articles/messaging#non-existent-agents-or-actions",
    
    "relUrl": "/articles/messaging#non-existent-agents-or-actions"
  },"11": {
    "doc": "Synchronous Messaging",
    "title": "Synchronous Messaging",
    "content": "The Agent.request() method is a synchronous version of the send() method that allows you to call an action and receive its return value or exception synchronously. If the action responds with an error, an ActionError will be raised containing the original error message. Here’s an example of how you might use request(): . try: return_value = self.request({ \"to\": \"ExampleAgent\", \"action\": { \"name\": \"example_action\", \"args\": { \"content\": \"hello\" } } }, timeout=5) except ActionError as e: print(e.message) . Note that request() may not be called during the after_add() and before_remove() callbacks, but may be used within actions or other callbacks. Also notice the timeout value. The default is 3 seconds. Make sure to increase this appropriately for longer running actions. ",
    "url": "/articles/synchronous_messaging",
    
    "relUrl": "/articles/synchronous_messaging"
  },"12": {
    "doc": "Using AMQPSpace",
    "title": "Using AMQPSpace",
    "content": "To use AMQP for networked communication, you can use the AMQPSpace class. To run across multiple hosts, you would separate your agents into multiple applications. Each application would be configured to use the same AMQP server. For example, the following would separate the Host agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a host agent to the space space.add(Host, \"Host\") # keep alive while True: time.sleep(1) . And the following would separate the ChattyAI agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a simple HF based chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") # keep alive while True: time.sleep(1) . Then you can run both applications at the same time, and the agents will be able to connect and communicate with each other over AMQP. This approach allows you to scale your agents beyond a single host. See the example application for a full working example. ",
    "url": "/articles/using_amqpspace",
    
    "relUrl": "/articles/using_amqpspace"
  },"13": {
    "doc": "Using AMQPSpace",
    "title": "Configuring AMQP Connectivity",
    "content": "By default, the AMQPSpace class will read the following environment variables and will otherwise use default settings. AMQP_HOST AMQP_PORT AMQP_USERNAME AMQP_PASSWORD AMQP_VHOST . You may also customize the options if you provide your own AMQPOptions object when instantiating an AMQPSpace. For example: . space = AMQPSpace( amqp_options=AMQPOptions( hostname=\"localhost\", port=5672, username=\"guest\", password=\"guest\", virtual_host=\"/\", use_ssl=True, heartbeat=60)) . ",
    "url": "/articles/using_amqpspace#configuring-amqp-connectivity",
    
    "relUrl": "/articles/using_amqpspace#configuring-amqp-connectivity"
  },"14": {
    "doc": "Demo Application Walkthrough",
    "title": "Demo Application Walkthrough",
    "content": "The following walkthrough will guide you through the basic concepts of Agency’s API, and how to use it to build a simple agent system, using the main demo application as an example. In this walkthrough, we’ll be using the MultiprocessSpace class for connecting agents. Usage is exactly the same as with any other space type, such as ThreadSpace or AMQPSpace. The Space type determines both the concurrency and communication implementation used for the space. ",
    "url": "/articles/walkthrough",
    
    "relUrl": "/articles/walkthrough"
  },"15": {
    "doc": "Demo Application Walkthrough",
    "title": "Creating a Space and adding Agents",
    "content": "The following snippet, adapted from the demo application, shows how to instantiate a space and add several agents to it. The application includes OpenAIFunctionAgent which uses the OpenAI API, a local LLM chat agent named ChattyAI, operating system access via the Host agent, and a Gradio based chat application which adds its user to the space as an agent as well. # Create the space instance space = MultiprocessSpace() # Add a Host agent to the space, exposing access to the host system space.add(Host, \"Host\") # Add a local chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") # Add an OpenAI function API agent to the space space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the OpenAI chat API user_id=\"User\") # GradioApp adds its user as an agent named \"User\" to the space GradioApp(space).demo().launch() . Notice that each agent is given a unique id. An agent’s id is used to identify the agent within the space. Other agents may send messages to Chatty or Host by using their id’s, as we’ll see later. ",
    "url": "/articles/walkthrough#creating-a-space-and-adding-agents",
    
    "relUrl": "/articles/walkthrough#creating-a-space-and-adding-agents"
  },"16": {
    "doc": "Demo Application Walkthrough",
    "title": "Defining an Agent and its Actions",
    "content": "To create an Agent type, simply extend the Agent class. We’ll use the ChattyAI agent as an example. class ChattyAI(Agent): ... Then to define actions, you define instance methods and use the @action decorator. For example the following defines an action called say that takes a single string argument content. @action def say(self, content: str): \"\"\"Use this action to say something to Chatty\"\"\" ... By defining an action, we allow other agents in a common space to discover and invoke the action on the agent. Other agents may invoke this action by sending a message to Chatty as we’ll see below. ",
    "url": "/articles/walkthrough#defining-an-agent-and-its-actions",
    
    "relUrl": "/articles/walkthrough#defining-an-agent-and-its-actions"
  },"17": {
    "doc": "Demo Application Walkthrough",
    "title": "Invoking Actions",
    "content": "When agents are added to a space, they may send messages to other agents to invoke their actions. An example of invoking an action can be seen here, taken from the ChattyAI.say() implementation... self.send({ \"to\": self.current_message()['from'], # reply to the sender \"action\": { \"name\": \"say\", \"args\": { \"content\": response_content, } } }) . This demonstrates the basic idea of how to send a message to invoke an action on another agent. When an agent receives a message, it invokes the actions method, passing action.args as keyword arguments. So here, Chatty is invoking the say action on the sender of the original message, passing the response as the content argument. This way, the original sender and Chatty can have a conversation. Note the use of the current_message() method. That method may be used during an action to inspect the entire message which invoked the current action. ",
    "url": "/articles/walkthrough#invoking-actions",
    
    "relUrl": "/articles/walkthrough#invoking-actions"
  },"18": {
    "doc": "Demo Application Walkthrough",
    "title": "Discovering Actions",
    "content": "At this point, we can demonstrate how action discovery works from the perspective of an agent. Each agent in the space implements a help action, which returns a dictionary of their available actions. To discover the other agents and their available actions across a space, an agent may send the following message: . self.send({ \"to\": \"*\", \"action\": { \"name\": \"help\" } }) . Each agent in the space will respond with a dictionary of their available actions. To request help on a specific agent, simply address the agent’s id: . self.send({ \"to\": \"Chatty\", \"action\": { \"name\": \"help\", } }) . To request help on a specific action, you may supply the action name as an argument: . self.send({ \"to\": \"Chatty\", \"action\": { \"name\": \"help\", \"args\": { \"action_name\": \"say\" } } }) . ",
    "url": "/articles/walkthrough#discovering-actions",
    
    "relUrl": "/articles/walkthrough#discovering-actions"
  },"19": {
    "doc": "Demo Application Walkthrough",
    "title": "Adding an Intelligent Agent",
    "content": "Finally we can add an intelligent agent into the space and allow them to discover and invoke actions. To add the OpenAIFunctionAgent to the environment: . space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the chat API user_id=\"User\") . If you inspect the implementation, you’ll see that this agent uses the after_add callback to immediately request help information from the other agents in the space when added. It later uses that information to provide a list of functions to the OpenAI function calling API. This demonstrates how an agent may discover and invoke actions across a space. ",
    "url": "/articles/walkthrough#adding-an-intelligent-agent",
    
    "relUrl": "/articles/walkthrough#adding-an-intelligent-agent"
  },"20": {
    "doc": "Demo Application Walkthrough",
    "title": "Running the Demo",
    "content": "This concludes the demo walkthrough. To try the demo, please jump to the examples/demo directory. ",
    "url": "/articles/walkthrough#running-the-demo",
    
    "relUrl": "/articles/walkthrough#running-the-demo"
  },"21": {
    "doc": "agency",
    "title": "\nagency    ",
    "content": "View Source 1import multiprocessing 2 3multiprocessing.set_start_method(&#39;spawn&#39;, force=True) . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"22": {
    "doc": "agency",
    "title": "Submodules",
    "content": ". | agent | logger | schema | space | spaces | . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"23": {
    "doc": "agency",
    "title": "agency",
    "content": " ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"24": {
    "doc": "agency.agent",
    "title": "\nagency.agent    ",
    "content": "View Source 1import inspect 2import re 3import threading 4import time 5import uuid 6from typing import Dict, List, Protocol 7 8from docstring_parser import DocstringStyle, parse 9 10from agency.logger import log 11from agency.schema import Message 12 13 14def _python_to_json_type_name(python_type_name: str) -&gt; str: 15 return { 16 &#39;str&#39;: &#39;string&#39;, 17 &#39;int&#39;: &#39;number&#39;, 18 &#39;float&#39;: &#39;number&#39;, 19 &#39;bool&#39;: &#39;boolean&#39;, 20 &#39;list&#39;: &#39;array&#39;, 21 &#39;dict&#39;: &#39;object&#39; 22 }[python_type_name] 23 24 25def _generate_help(method: callable) -&gt; dict: 26 &quot;&quot;&quot; 27 Generates a help object from a method&#39;s docstring and signature 28 29 Args: 30 method: the method 31 32 Returns: 33 A help object of the form: 34 35 { 36 &quot;description&quot;: &lt;description&gt;, 37 &quot;args&quot;: { 38 &quot;arg_name&quot;: { 39 &quot;type&quot;: &lt;type&gt;, 40 &quot;description&quot;: &lt;description&gt; 41 }, 42 } 43 &quot;returns&quot;: { 44 &quot;type&quot;: &lt;type&gt;, 45 &quot;description&quot;: &lt;description&gt; 46 } 47 } 48 &quot;&quot;&quot; 49 signature = inspect.signature(method) 50 parsed_docstring = parse(method.__doc__, DocstringStyle.GOOGLE) 51 52 help_object = {} 53 54 # description 55 if parsed_docstring.short_description is not None: 56 description = parsed_docstring.short_description 57 if parsed_docstring.long_description is not None: 58 description += &quot; &quot; + parsed_docstring.long_description 59 help_object[&quot;description&quot;] = re.sub(r&quot;\\s+&quot;, &quot; &quot;, description).strip() 60 61 # args 62 help_object[&quot;args&quot;] = {} 63 docstring_args = {arg.arg_name: arg for arg in parsed_docstring.params} 64 arg_names = list(signature.parameters.keys())[1:] # skip &#39;self&#39; argument 65 for arg_name in arg_names: 66 arg_object = {} 67 68 # type 69 sig_annotation = signature.parameters[arg_name].annotation 70 if sig_annotation is not None and sig_annotation.__name__ != &quot;_empty&quot;: 71 arg_object[&quot;type&quot;] = _python_to_json_type_name( 72 signature.parameters[arg_name].annotation.__name__) 73 elif arg_name in docstring_args and docstring_args[arg_name].type_name is not None: 74 arg_object[&quot;type&quot;] = _python_to_json_type_name( 75 docstring_args[arg_name].type_name) 76 77 # description 78 if arg_name in docstring_args and docstring_args[arg_name].description is not None: 79 arg_object[&quot;description&quot;] = docstring_args[arg_name].description.strip() 80 81 help_object[&quot;args&quot;][arg_name] = arg_object 82 83 # returns 84 if parsed_docstring.returns is not None: 85 help_object[&quot;returns&quot;] = {} 86 87 # type 88 if signature.return_annotation is not None: 89 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 90 signature.return_annotation.__name__) 91 elif parsed_docstring.returns.type_name is not None: 92 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 93 parsed_docstring.returns.type_name) 94 95 # description 96 if parsed_docstring.returns.description is not None: 97 help_object[&quot;returns&quot;][&quot;description&quot;] = parsed_docstring.returns.description.strip() 98 99 return help_object 100 101 102# Special action name for responses 103_RESPONSE_ACTION_NAME = &quot;[response]&quot; 104 105 106# Access policies 107ACCESS_PERMITTED = &quot;ACCESS_PERMITTED&quot; 108ACCESS_DENIED = &quot;ACCESS_DENIED&quot; 109ACCESS_REQUESTED = &quot;ACCESS_REQUESTED&quot; 110 111 112def action(*args, **kwargs): 113 &quot;&quot;&quot; 114 Declares instance methods as actions making them accessible to other agents. 115 116 Keyword arguments: 117 name: The name of the action. Defaults to the name of the method. 118 help: The help object. Defaults to a generated object. 119 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 120 &quot;&quot;&quot; 121 def decorator(method): 122 action_name = kwargs.get(&quot;name&quot;, method.__name__) 123 if action_name == _RESPONSE_ACTION_NAME: 124 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 125 method.action_properties = { 126 &quot;name&quot;: method.__name__, 127 &quot;help&quot;: _generate_help(method), 128 &quot;access_policy&quot;: ACCESS_PERMITTED, 129 **kwargs} 130 return method 131 132 if len(args) == 1 and callable(args[0]) and not kwargs: 133 return decorator(args[0]) # The decorator was used without parentheses 134 else: 135 return decorator # The decorator was used with parentheses 136 137 138class _QueueProtocol(Protocol): 139 &quot;&quot;&quot;A protocol for providing an outbound queue for an Agent&quot;&quot;&quot; 140 141 def put(self, message: Message): 142 &quot;&quot;&quot; 143 Put a message onto the queue for sending 144 145 Args: 146 message: The message 147 &quot;&quot;&quot; 148 149 def get(self) -&gt; Message: 150 &quot;&quot;&quot; 151 Get the next message from the queue 152 153 Returns: 154 The next message 155 156 Raises: 157 queue.Empty: If there are no messages 158 &quot;&quot;&quot; 159 160 161class ActionError(Exception): 162 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; 163 164 165class Agent(): 166 &quot;&quot;&quot; 167 An Actor that may represent an AI agent, computing system, or human user 168 &quot;&quot;&quot; 169 170 def __init__(self, 171 id: str, 172 outbound_queue: _QueueProtocol, 173 receive_own_broadcasts: bool = True): 174 &quot;&quot;&quot; 175 Initializes an Agent. 176 177 This constructor is not meant to be called directly. It is invoked by 178 the Space class when adding an agent. 179 180 Subclasses should call super().__init__() in their constructor. 181 182 Args: 183 id: The id of the agent 184 outbound_queue: The outgoing queue for sending messages 185 receive_own_broadcasts: 186 Whether the agent will receive its own broadcasts. Defaults to 187 True 188 &quot;&quot;&quot; 189 if len(id) &lt; 1 or len(id) &gt; 255: 190 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 191 if re.match(r&quot;^amq\\.&quot;, id): 192 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 193 if id == &quot;*&quot;: 194 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 195 if outbound_queue is None: 196 raise ValueError(&quot;outbound_queue must be provided&quot;) 197 self._id: str = id 198 self._outbound_queue: _QueueProtocol = outbound_queue 199 self._receive_own_broadcasts: bool = receive_own_broadcasts 200 self._is_processing: bool = False # set by the Space 201 self._message_log: List[Message] = [] 202 self._message_log_lock = threading.Lock() 203 self._pending_requests: Dict[str, Message] = {} 204 self._pending_requests_lock = threading.Lock() 205 self.__thread_local_current_message = threading.local() 206 self.__thread_local_current_message.value: Message = None 207 208 def id(self) -&gt; str: 209 return self._id 210 211 def send(self, message: dict) -&gt; str: 212 &quot;&quot;&quot; 213 Sends (out) a message from this agent. 214 215 Args: 216 message: The message 217 218 Returns: 219 The id of the sent message 220 &quot;&quot;&quot; 221 message[&quot;meta&quot;] = { 222 &quot;id&quot;: uuid.uuid4().__str__(), 223 **message.get(&quot;meta&quot;, {}), 224 } 225 message[&quot;from&quot;] = self.id() 226 log(&quot;info&quot;, f&quot;{self.id()} sending message&quot;, message) 227 with self._message_log_lock: 228 self._message_log.append(message) 229 self._outbound_queue.put(message) 230 return message[&quot;meta&quot;][&quot;id&quot;] 231 232 def request(self, message: dict, timeout: float = 3) -&gt; object: 233 &quot;&quot;&quot; 234 Synchronously sends a message then waits for and returns the return 235 value of the invoked action. 236 237 This method allows you to call an action synchronously like a function 238 and receive its return value in python. If the action raises an 239 exception an ActionError will be raised containing the error message. 240 241 Args: 242 message: The message to send 243 timeout: 244 The timeout in seconds to wait for the returned value. 245 Defaults to 3 seconds. 246 247 Returns: 248 object: The return value of the action. 249 250 Raises: 251 TimeoutError: If the timeout is reached 252 ActionError: If the action raised an exception 253 RuntimeError: 254 If called before the agent is processing incoming messages 255 &quot;&quot;&quot; 256 if not self._is_processing: 257 raise RuntimeError( 258 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 259 260 # Send and mark the request as pending 261 request_id = self.send(message) 262 pending = object() 263 with self._pending_requests_lock: 264 self._pending_requests[request_id] = pending 265 266 # Wait for response 267 start_time = time.time() 268 while self._pending_requests[request_id] == pending: 269 time.sleep(0.001) 270 if time.time() - start_time &gt; timeout: 271 raise TimeoutError 272 273 with self._pending_requests_lock: 274 response_message = self._pending_requests.pop(request_id) 275 276 # Raise error or return value from response 277 if &quot;error&quot; in response_message[&quot;action&quot;][&quot;args&quot;]: 278 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 279 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 280 281 def _receive(self, message: dict): 282 &quot;&quot;&quot; 283 Receives and handles an incoming message. 284 285 Args: 286 message: The incoming message 287 &quot;&quot;&quot; 288 # Ignore own broadcasts if _receive_own_broadcasts is false 289 if not self._receive_own_broadcasts \\ 290 and message[&#39;from&#39;] == self.id() \\ 291 and message[&#39;to&#39;] == &#39;*&#39;: 292 return 293 294 log(&quot;debug&quot;, f&quot;{self.id()} received message&quot;, message) 295 296 # Record the received message before handling 297 with self._message_log_lock: 298 self._message_log.append(message) 299 300 # Handle incoming responses 301 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 302 parent_id = message[&quot;meta&quot;][&quot;parent_id&quot;] 303 if parent_id in self._pending_requests.keys(): 304 # This was a response to a request() 305 self._pending_requests[parent_id] = message 306 # From here the request() method will pick up the response in 307 # the existing thread 308 else: 309 # This was a response to a send() 310 if &quot;value&quot; in message[&quot;action&quot;][&quot;args&quot;]: 311 handler_callback = self.handle_action_value 312 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 313 elif &quot;error&quot; in message[&quot;action&quot;][&quot;args&quot;]: 314 handler_callback = self.handle_action_error 315 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 316 else: 317 raise RuntimeError(&quot;Unknown action response&quot;) 318 319 # Spawn a thread to handle the response 320 def __process_response(arg, current_message): 321 log(&quot;debug&quot;, f&quot;{self.id()} processing response&quot;, message) 322 self.__thread_local_current_message.value = current_message 323 handler_callback(arg) 324 325 threading.Thread( 326 target=__process_response, 327 args=(arg, message, ), 328 daemon=True, 329 ).start() 330 331 # Handle all other messages 332 else: 333 # Spawn a thread to process the message. This means that messages 334 # are processed concurrently, but may be processed out of order. 335 threading.Thread( 336 target=self.__process, args=(message,), daemon=True).start() 337 338 def __process(self, message: dict): 339 &quot;&quot;&quot; 340 Top level method within the action processing thread. 341 &quot;&quot;&quot; 342 self.__thread_local_current_message.value = message 343 message_id = message[&quot;meta&quot;][&quot;id&quot;] 344 try: 345 # Commit the action 346 log(&quot;debug&quot;, f&quot;{self.id()} committing action&quot;, message) 347 return_value = self.__commit(message) 348 349 # Send the return value 350 self.send({ 351 &quot;meta&quot;: { 352 &quot;parent_id&quot;: message_id 353 }, 354 &quot;to&quot;: message[&#39;from&#39;], 355 &quot;action&quot;: { 356 &quot;name&quot;: _RESPONSE_ACTION_NAME, 357 &quot;args&quot;: { 358 &quot;value&quot;: return_value, 359 } 360 } 361 }) 362 except Exception as e: 363 # Handle errors (including PermissionError) that occur while 364 # committing an action by reporting back to the sender. 365 log(&quot;warning&quot;, 366 f&quot;{self.id()} exception while committing action &#39;{message[&#39;action&#39;][&#39;name&#39;]}&#39;&quot;, e) 367 self.send({ 368 &quot;meta&quot;: { 369 &quot;parent_id&quot;: message_id 370 }, 371 &quot;to&quot;: message[&#39;from&#39;], 372 &quot;action&quot;: { 373 &quot;name&quot;: _RESPONSE_ACTION_NAME, 374 &quot;args&quot;: { 375 &quot;error&quot;: f&quot;{e.__class__.__name__}: {e}&quot; 376 } 377 } 378 }) 379 380 def __commit(self, message: dict): 381 &quot;&quot;&quot; 382 Invokes the action method 383 384 Args: 385 message: The incoming message specifying the action 386 387 Raises: 388 AttributeError: If the action method is not found 389 PermissionError: If the action is not permitted 390 &quot;&quot;&quot; 391 try: 392 # Check if the action method exists 393 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 394 except KeyError: 395 # the action was not found 396 if message[&#39;to&#39;] == &#39;*&#39;: 397 return # broadcasts will not raise an error in this situation 398 else: 399 raise AttributeError( 400 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 401 402 # Check if the action is permitted 403 if not self.__permitted(message): 404 raise PermissionError( 405 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 406 407 self.before_action(message) 408 409 return_value = None 410 error = None 411 try: 412 # Invoke the action method 413 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 414 except Exception as e: 415 error = e 416 raise 417 finally: 418 self.after_action(message, return_value, error) 419 return return_value 420 421 def __permitted(self, message: dict) -&gt; bool: 422 &quot;&quot;&quot; 423 Checks whether the message&#39;s action is allowed 424 &quot;&quot;&quot; 425 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 426 policy = action_method.action_properties[&quot;access_policy&quot;] 427 if policy == ACCESS_PERMITTED: 428 return True 429 elif policy == ACCESS_DENIED: 430 return False 431 elif policy == ACCESS_REQUESTED: 432 return self.request_permission(message) 433 else: 434 raise Exception( 435 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 436 437 def __action_methods(self) -&gt; dict: 438 instance_methods = inspect.getmembers(self, inspect.ismethod) 439 action_methods = { 440 method_name: method 441 for method_name, method in instance_methods 442 if hasattr(method, &quot;action_properties&quot;) 443 } 444 return action_methods 445 446 def __action_method(self, action_name: str): 447 &quot;&quot;&quot; 448 Returns the method for the given action name. 449 &quot;&quot;&quot; 450 action_methods = self.__action_methods() 451 return action_methods[action_name] 452 453 def _find_message(self, message_id: str) -&gt; Message: 454 &quot;&quot;&quot; 455 Returns a message from the log with the given ID. 456 457 Args: 458 message_id: The ID of the message 459 460 Returns: 461 The message or None if not found 462 &quot;&quot;&quot; 463 for message in self._message_log: 464 if message[&quot;meta&quot;][&quot;id&quot;] == message_id: 465 return message 466 467 def current_message(self) -&gt; Message: 468 &quot;&quot;&quot; 469 Returns the full incoming message which invokes the current action. 470 471 This method may be called within an action or action related callback to 472 retrieve the current message, for example to determine the sender or 473 inspect other details. 474 475 Returns: 476 The current message 477 &quot;&quot;&quot; 478 return self.__thread_local_current_message.value 479 480 def parent_message(self, message: Message = None) -&gt; Message: 481 &quot;&quot;&quot; 482 Returns the message that the given message is responding to, if any. 483 484 Args: 485 message: The message to get the parent message of. Defaults to the 486 current message. 487 488 Returns: 489 The parent message or None 490 &quot;&quot;&quot; 491 if message is None: 492 message = self.current_message() 493 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 494 if parent_id is not None: 495 return self._find_message(parent_id) 496 497 @action 498 def help(self, action_name: str = None) -&gt; dict: 499 &quot;&quot;&quot; 500 Returns a list of actions on this agent. 501 502 If action_name is passed, returns a list with only that action. 503 If no action_name is passed, returns all actions. 504 505 Args: 506 action_name: (Optional) The name of an action to request help for 507 508 Returns: 509 A dictionary of actions 510 &quot;&quot;&quot; 511 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME] 512 help_list = { 513 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 514 for method in self.__action_methods().values() 515 if action_name is None 516 and method.action_properties[&quot;name&quot;] not in special_actions 517 or method.action_properties[&quot;name&quot;] == action_name 518 } 519 return help_list 520 521 def handle_action_value(self, value): 522 &quot;&quot;&quot; 523 Receives a return value from a previous action. 524 525 This method receives return values from actions invoked by the send() 526 method. It is not called when using the request() method, which returns 527 the value directly. 528 529 To inspect the full response message carrying this value, use 530 current_message(). To inspect the message which returned the value, use 531 parent_message(). 532 533 Args: 534 value: 535 The return value 536 &quot;&quot;&quot; 537 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 538 self._issued_handle_action_value_warning = True 539 log(&quot;warning&quot;, 540 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 541 542 def handle_action_error(self, error: ActionError): 543 &quot;&quot;&quot; 544 Receives an error from a previous action. 545 546 This method receives errors from actions invoked by the send() method. 547 It is not called when using the request() method, which raises an error 548 directly. 549 550 To inspect the full response message carrying this error, use 551 current_message(). To inspect the message which caused the error, use 552 parent_message(). 553 554 Args: 555 error: The error 556 &quot;&quot;&quot; 557 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 558 self._issued_handle_action_error_warning = True 559 log(&quot;warning&quot;, 560 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 561 562 def after_add(self): 563 &quot;&quot;&quot; 564 Called after the agent is added to a space, but before it begins 565 processing incoming messages. 566 567 The agent may send messages during this callback using the send() 568 method, but may not use the request() method since it relies on 569 processing incoming messages. 570 &quot;&quot;&quot; 571 572 def before_remove(self): 573 &quot;&quot;&quot; 574 Called before the agent is removed from a space, after it has finished 575 processing incoming messages. 576 577 The agent may send final messages during this callback using the send() 578 method, but may not use the request() method since it relies on 579 processing incoming messages. 580 &quot;&quot;&quot; 581 582 def before_action(self, message: dict): 583 &quot;&quot;&quot; 584 Called before every action. 585 586 This method will only be called if the action exists and is permitted. 587 588 Args: 589 message: The received message that contains the action 590 &quot;&quot;&quot; 591 592 def after_action(self, message: dict, return_value: str, error: str): 593 &quot;&quot;&quot; 594 Called after every action, regardless of whether an error occurred. 595 596 Args: 597 message: The message which invoked the action 598 return_value: The return value from the action 599 error: The error from the action if any 600 &quot;&quot;&quot; 601 602 def request_permission(self, proposed_message: dict) -&gt; bool: 603 &quot;&quot;&quot; 604 Receives a proposed action message and presents it to the agent for 605 review. 606 607 Args: 608 proposed_message: The proposed action message 609 610 Returns: 611 True if access should be permitted 612 &quot;&quot;&quot; 613 raise NotImplementedError( 614 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . ACCESS_PERMITTED = &#39;ACCESS_PERMITTED&#39; ACCESS_DENIED = &#39;ACCESS_DENIED&#39; ACCESS_REQUESTED = &#39;ACCESS_REQUESTED&#39; def action(*args, **kwargs): View Source 113def action(*args, **kwargs): 114 &quot;&quot;&quot; 115 Declares instance methods as actions making them accessible to other agents. 116 117 Keyword arguments: 118 name: The name of the action. Defaults to the name of the method. 119 help: The help object. Defaults to a generated object. 120 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 121 &quot;&quot;&quot; 122 def decorator(method): 123 action_name = kwargs.get(&quot;name&quot;, method.__name__) 124 if action_name == _RESPONSE_ACTION_NAME: 125 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 126 method.action_properties = { 127 &quot;name&quot;: method.__name__, 128 &quot;help&quot;: _generate_help(method), 129 &quot;access_policy&quot;: ACCESS_PERMITTED, 130 **kwargs} 131 return method 132 133 if len(args) == 1 and callable(args[0]) and not kwargs: 134 return decorator(args[0]) # The decorator was used without parentheses 135 else: 136 return decorator # The decorator was used with parentheses . Declares instance methods as actions making them accessible to other agents. Keyword arguments: . name: The name of the action. Defaults to the name of the method. help: The help object. Defaults to a generated object. access_policy: The access policy. Defaults to ACCESS_PERMITTED. class ActionError(builtins.Exception): View Source 162class ActionError(Exception): 163 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; . Raised from the request() method if the action responds with an error . Inherited Members . builtins.Exception Exception builtins.BaseException with_traceback args class Agent: View Source 166class Agent(): 167 &quot;&quot;&quot; 168 An Actor that may represent an AI agent, computing system, or human user 169 &quot;&quot;&quot; 170 171 def __init__(self, 172 id: str, 173 outbound_queue: _QueueProtocol, 174 receive_own_broadcasts: bool = True): 175 &quot;&quot;&quot; 176 Initializes an Agent. 177 178 This constructor is not meant to be called directly. It is invoked by 179 the Space class when adding an agent. 180 181 Subclasses should call super().__init__() in their constructor. 182 183 Args: 184 id: The id of the agent 185 outbound_queue: The outgoing queue for sending messages 186 receive_own_broadcasts: 187 Whether the agent will receive its own broadcasts. Defaults to 188 True 189 &quot;&quot;&quot; 190 if len(id) &lt; 1 or len(id) &gt; 255: 191 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 192 if re.match(r&quot;^amq\\.&quot;, id): 193 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 194 if id == &quot;*&quot;: 195 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 196 if outbound_queue is None: 197 raise ValueError(&quot;outbound_queue must be provided&quot;) 198 self._id: str = id 199 self._outbound_queue: _QueueProtocol = outbound_queue 200 self._receive_own_broadcasts: bool = receive_own_broadcasts 201 self._is_processing: bool = False # set by the Space 202 self._message_log: List[Message] = [] 203 self._message_log_lock = threading.Lock() 204 self._pending_requests: Dict[str, Message] = {} 205 self._pending_requests_lock = threading.Lock() 206 self.__thread_local_current_message = threading.local() 207 self.__thread_local_current_message.value: Message = None 208 209 def id(self) -&gt; str: 210 return self._id 211 212 def send(self, message: dict) -&gt; str: 213 &quot;&quot;&quot; 214 Sends (out) a message from this agent. 215 216 Args: 217 message: The message 218 219 Returns: 220 The id of the sent message 221 &quot;&quot;&quot; 222 message[&quot;meta&quot;] = { 223 &quot;id&quot;: uuid.uuid4().__str__(), 224 **message.get(&quot;meta&quot;, {}), 225 } 226 message[&quot;from&quot;] = self.id() 227 log(&quot;info&quot;, f&quot;{self.id()} sending message&quot;, message) 228 with self._message_log_lock: 229 self._message_log.append(message) 230 self._outbound_queue.put(message) 231 return message[&quot;meta&quot;][&quot;id&quot;] 232 233 def request(self, message: dict, timeout: float = 3) -&gt; object: 234 &quot;&quot;&quot; 235 Synchronously sends a message then waits for and returns the return 236 value of the invoked action. 237 238 This method allows you to call an action synchronously like a function 239 and receive its return value in python. If the action raises an 240 exception an ActionError will be raised containing the error message. 241 242 Args: 243 message: The message to send 244 timeout: 245 The timeout in seconds to wait for the returned value. 246 Defaults to 3 seconds. 247 248 Returns: 249 object: The return value of the action. 250 251 Raises: 252 TimeoutError: If the timeout is reached 253 ActionError: If the action raised an exception 254 RuntimeError: 255 If called before the agent is processing incoming messages 256 &quot;&quot;&quot; 257 if not self._is_processing: 258 raise RuntimeError( 259 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 260 261 # Send and mark the request as pending 262 request_id = self.send(message) 263 pending = object() 264 with self._pending_requests_lock: 265 self._pending_requests[request_id] = pending 266 267 # Wait for response 268 start_time = time.time() 269 while self._pending_requests[request_id] == pending: 270 time.sleep(0.001) 271 if time.time() - start_time &gt; timeout: 272 raise TimeoutError 273 274 with self._pending_requests_lock: 275 response_message = self._pending_requests.pop(request_id) 276 277 # Raise error or return value from response 278 if &quot;error&quot; in response_message[&quot;action&quot;][&quot;args&quot;]: 279 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 280 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 281 282 def _receive(self, message: dict): 283 &quot;&quot;&quot; 284 Receives and handles an incoming message. 285 286 Args: 287 message: The incoming message 288 &quot;&quot;&quot; 289 # Ignore own broadcasts if _receive_own_broadcasts is false 290 if not self._receive_own_broadcasts \\ 291 and message[&#39;from&#39;] == self.id() \\ 292 and message[&#39;to&#39;] == &#39;*&#39;: 293 return 294 295 log(&quot;debug&quot;, f&quot;{self.id()} received message&quot;, message) 296 297 # Record the received message before handling 298 with self._message_log_lock: 299 self._message_log.append(message) 300 301 # Handle incoming responses 302 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 303 parent_id = message[&quot;meta&quot;][&quot;parent_id&quot;] 304 if parent_id in self._pending_requests.keys(): 305 # This was a response to a request() 306 self._pending_requests[parent_id] = message 307 # From here the request() method will pick up the response in 308 # the existing thread 309 else: 310 # This was a response to a send() 311 if &quot;value&quot; in message[&quot;action&quot;][&quot;args&quot;]: 312 handler_callback = self.handle_action_value 313 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 314 elif &quot;error&quot; in message[&quot;action&quot;][&quot;args&quot;]: 315 handler_callback = self.handle_action_error 316 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 317 else: 318 raise RuntimeError(&quot;Unknown action response&quot;) 319 320 # Spawn a thread to handle the response 321 def __process_response(arg, current_message): 322 log(&quot;debug&quot;, f&quot;{self.id()} processing response&quot;, message) 323 self.__thread_local_current_message.value = current_message 324 handler_callback(arg) 325 326 threading.Thread( 327 target=__process_response, 328 args=(arg, message, ), 329 daemon=True, 330 ).start() 331 332 # Handle all other messages 333 else: 334 # Spawn a thread to process the message. This means that messages 335 # are processed concurrently, but may be processed out of order. 336 threading.Thread( 337 target=self.__process, args=(message,), daemon=True).start() 338 339 def __process(self, message: dict): 340 &quot;&quot;&quot; 341 Top level method within the action processing thread. 342 &quot;&quot;&quot; 343 self.__thread_local_current_message.value = message 344 message_id = message[&quot;meta&quot;][&quot;id&quot;] 345 try: 346 # Commit the action 347 log(&quot;debug&quot;, f&quot;{self.id()} committing action&quot;, message) 348 return_value = self.__commit(message) 349 350 # Send the return value 351 self.send({ 352 &quot;meta&quot;: { 353 &quot;parent_id&quot;: message_id 354 }, 355 &quot;to&quot;: message[&#39;from&#39;], 356 &quot;action&quot;: { 357 &quot;name&quot;: _RESPONSE_ACTION_NAME, 358 &quot;args&quot;: { 359 &quot;value&quot;: return_value, 360 } 361 } 362 }) 363 except Exception as e: 364 # Handle errors (including PermissionError) that occur while 365 # committing an action by reporting back to the sender. 366 log(&quot;warning&quot;, 367 f&quot;{self.id()} exception while committing action &#39;{message[&#39;action&#39;][&#39;name&#39;]}&#39;&quot;, e) 368 self.send({ 369 &quot;meta&quot;: { 370 &quot;parent_id&quot;: message_id 371 }, 372 &quot;to&quot;: message[&#39;from&#39;], 373 &quot;action&quot;: { 374 &quot;name&quot;: _RESPONSE_ACTION_NAME, 375 &quot;args&quot;: { 376 &quot;error&quot;: f&quot;{e.__class__.__name__}: {e}&quot; 377 } 378 } 379 }) 380 381 def __commit(self, message: dict): 382 &quot;&quot;&quot; 383 Invokes the action method 384 385 Args: 386 message: The incoming message specifying the action 387 388 Raises: 389 AttributeError: If the action method is not found 390 PermissionError: If the action is not permitted 391 &quot;&quot;&quot; 392 try: 393 # Check if the action method exists 394 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 395 except KeyError: 396 # the action was not found 397 if message[&#39;to&#39;] == &#39;*&#39;: 398 return # broadcasts will not raise an error in this situation 399 else: 400 raise AttributeError( 401 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 402 403 # Check if the action is permitted 404 if not self.__permitted(message): 405 raise PermissionError( 406 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 407 408 self.before_action(message) 409 410 return_value = None 411 error = None 412 try: 413 # Invoke the action method 414 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 415 except Exception as e: 416 error = e 417 raise 418 finally: 419 self.after_action(message, return_value, error) 420 return return_value 421 422 def __permitted(self, message: dict) -&gt; bool: 423 &quot;&quot;&quot; 424 Checks whether the message&#39;s action is allowed 425 &quot;&quot;&quot; 426 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 427 policy = action_method.action_properties[&quot;access_policy&quot;] 428 if policy == ACCESS_PERMITTED: 429 return True 430 elif policy == ACCESS_DENIED: 431 return False 432 elif policy == ACCESS_REQUESTED: 433 return self.request_permission(message) 434 else: 435 raise Exception( 436 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 437 438 def __action_methods(self) -&gt; dict: 439 instance_methods = inspect.getmembers(self, inspect.ismethod) 440 action_methods = { 441 method_name: method 442 for method_name, method in instance_methods 443 if hasattr(method, &quot;action_properties&quot;) 444 } 445 return action_methods 446 447 def __action_method(self, action_name: str): 448 &quot;&quot;&quot; 449 Returns the method for the given action name. 450 &quot;&quot;&quot; 451 action_methods = self.__action_methods() 452 return action_methods[action_name] 453 454 def _find_message(self, message_id: str) -&gt; Message: 455 &quot;&quot;&quot; 456 Returns a message from the log with the given ID. 457 458 Args: 459 message_id: The ID of the message 460 461 Returns: 462 The message or None if not found 463 &quot;&quot;&quot; 464 for message in self._message_log: 465 if message[&quot;meta&quot;][&quot;id&quot;] == message_id: 466 return message 467 468 def current_message(self) -&gt; Message: 469 &quot;&quot;&quot; 470 Returns the full incoming message which invokes the current action. 471 472 This method may be called within an action or action related callback to 473 retrieve the current message, for example to determine the sender or 474 inspect other details. 475 476 Returns: 477 The current message 478 &quot;&quot;&quot; 479 return self.__thread_local_current_message.value 480 481 def parent_message(self, message: Message = None) -&gt; Message: 482 &quot;&quot;&quot; 483 Returns the message that the given message is responding to, if any. 484 485 Args: 486 message: The message to get the parent message of. Defaults to the 487 current message. 488 489 Returns: 490 The parent message or None 491 &quot;&quot;&quot; 492 if message is None: 493 message = self.current_message() 494 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 495 if parent_id is not None: 496 return self._find_message(parent_id) 497 498 @action 499 def help(self, action_name: str = None) -&gt; dict: 500 &quot;&quot;&quot; 501 Returns a list of actions on this agent. 502 503 If action_name is passed, returns a list with only that action. 504 If no action_name is passed, returns all actions. 505 506 Args: 507 action_name: (Optional) The name of an action to request help for 508 509 Returns: 510 A dictionary of actions 511 &quot;&quot;&quot; 512 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME] 513 help_list = { 514 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 515 for method in self.__action_methods().values() 516 if action_name is None 517 and method.action_properties[&quot;name&quot;] not in special_actions 518 or method.action_properties[&quot;name&quot;] == action_name 519 } 520 return help_list 521 522 def handle_action_value(self, value): 523 &quot;&quot;&quot; 524 Receives a return value from a previous action. 525 526 This method receives return values from actions invoked by the send() 527 method. It is not called when using the request() method, which returns 528 the value directly. 529 530 To inspect the full response message carrying this value, use 531 current_message(). To inspect the message which returned the value, use 532 parent_message(). 533 534 Args: 535 value: 536 The return value 537 &quot;&quot;&quot; 538 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 539 self._issued_handle_action_value_warning = True 540 log(&quot;warning&quot;, 541 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 542 543 def handle_action_error(self, error: ActionError): 544 &quot;&quot;&quot; 545 Receives an error from a previous action. 546 547 This method receives errors from actions invoked by the send() method. 548 It is not called when using the request() method, which raises an error 549 directly. 550 551 To inspect the full response message carrying this error, use 552 current_message(). To inspect the message which caused the error, use 553 parent_message(). 554 555 Args: 556 error: The error 557 &quot;&quot;&quot; 558 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 559 self._issued_handle_action_error_warning = True 560 log(&quot;warning&quot;, 561 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 562 563 def after_add(self): 564 &quot;&quot;&quot; 565 Called after the agent is added to a space, but before it begins 566 processing incoming messages. 567 568 The agent may send messages during this callback using the send() 569 method, but may not use the request() method since it relies on 570 processing incoming messages. 571 &quot;&quot;&quot; 572 573 def before_remove(self): 574 &quot;&quot;&quot; 575 Called before the agent is removed from a space, after it has finished 576 processing incoming messages. 577 578 The agent may send final messages during this callback using the send() 579 method, but may not use the request() method since it relies on 580 processing incoming messages. 581 &quot;&quot;&quot; 582 583 def before_action(self, message: dict): 584 &quot;&quot;&quot; 585 Called before every action. 586 587 This method will only be called if the action exists and is permitted. 588 589 Args: 590 message: The received message that contains the action 591 &quot;&quot;&quot; 592 593 def after_action(self, message: dict, return_value: str, error: str): 594 &quot;&quot;&quot; 595 Called after every action, regardless of whether an error occurred. 596 597 Args: 598 message: The message which invoked the action 599 return_value: The return value from the action 600 error: The error from the action if any 601 &quot;&quot;&quot; 602 603 def request_permission(self, proposed_message: dict) -&gt; bool: 604 &quot;&quot;&quot; 605 Receives a proposed action message and presents it to the agent for 606 review. 607 608 Args: 609 proposed_message: The proposed action message 610 611 Returns: 612 True if access should be permitted 613 &quot;&quot;&quot; 614 raise NotImplementedError( 615 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . An Actor that may represent an AI agent, computing system, or human user . Agent( id: str, outbound_queue: agency.agent._QueueProtocol, receive_own_broadcasts: bool = True) View Source 171 def __init__(self, 172 id: str, 173 outbound_queue: _QueueProtocol, 174 receive_own_broadcasts: bool = True): 175 &quot;&quot;&quot; 176 Initializes an Agent. 177 178 This constructor is not meant to be called directly. It is invoked by 179 the Space class when adding an agent. 180 181 Subclasses should call super().__init__() in their constructor. 182 183 Args: 184 id: The id of the agent 185 outbound_queue: The outgoing queue for sending messages 186 receive_own_broadcasts: 187 Whether the agent will receive its own broadcasts. Defaults to 188 True 189 &quot;&quot;&quot; 190 if len(id) &lt; 1 or len(id) &gt; 255: 191 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 192 if re.match(r&quot;^amq\\.&quot;, id): 193 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 194 if id == &quot;*&quot;: 195 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 196 if outbound_queue is None: 197 raise ValueError(&quot;outbound_queue must be provided&quot;) 198 self._id: str = id 199 self._outbound_queue: _QueueProtocol = outbound_queue 200 self._receive_own_broadcasts: bool = receive_own_broadcasts 201 self._is_processing: bool = False # set by the Space 202 self._message_log: List[Message] = [] 203 self._message_log_lock = threading.Lock() 204 self._pending_requests: Dict[str, Message] = {} 205 self._pending_requests_lock = threading.Lock() 206 self.__thread_local_current_message = threading.local() 207 self.__thread_local_current_message.value: Message = None . Initializes an Agent. This constructor is not meant to be called directly. It is invoked by the Space class when adding an agent. Subclasses should call super().__init__() in their constructor. Arguments: . | id: The id of the agent | outbound_queue: The outgoing queue for sending messages | receive_own_broadcasts: Whether the agent will receive its own broadcasts. Defaults to True | . def id(self) -> str: View Source 209 def id(self) -&gt; str: 210 return self._id . def send(self, message: dict) -> str: View Source 212 def send(self, message: dict) -&gt; str: 213 &quot;&quot;&quot; 214 Sends (out) a message from this agent. 215 216 Args: 217 message: The message 218 219 Returns: 220 The id of the sent message 221 &quot;&quot;&quot; 222 message[&quot;meta&quot;] = { 223 &quot;id&quot;: uuid.uuid4().__str__(), 224 **message.get(&quot;meta&quot;, {}), 225 } 226 message[&quot;from&quot;] = self.id() 227 log(&quot;info&quot;, f&quot;{self.id()} sending message&quot;, message) 228 with self._message_log_lock: 229 self._message_log.append(message) 230 self._outbound_queue.put(message) 231 return message[&quot;meta&quot;][&quot;id&quot;] . Sends (out) a message from this agent. Arguments: . | message: The message | . Returns: . The id of the sent message . def request(self, message: dict, timeout: float = 3) -> object: View Source 233 def request(self, message: dict, timeout: float = 3) -&gt; object: 234 &quot;&quot;&quot; 235 Synchronously sends a message then waits for and returns the return 236 value of the invoked action. 237 238 This method allows you to call an action synchronously like a function 239 and receive its return value in python. If the action raises an 240 exception an ActionError will be raised containing the error message. 241 242 Args: 243 message: The message to send 244 timeout: 245 The timeout in seconds to wait for the returned value. 246 Defaults to 3 seconds. 247 248 Returns: 249 object: The return value of the action. 250 251 Raises: 252 TimeoutError: If the timeout is reached 253 ActionError: If the action raised an exception 254 RuntimeError: 255 If called before the agent is processing incoming messages 256 &quot;&quot;&quot; 257 if not self._is_processing: 258 raise RuntimeError( 259 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 260 261 # Send and mark the request as pending 262 request_id = self.send(message) 263 pending = object() 264 with self._pending_requests_lock: 265 self._pending_requests[request_id] = pending 266 267 # Wait for response 268 start_time = time.time() 269 while self._pending_requests[request_id] == pending: 270 time.sleep(0.001) 271 if time.time() - start_time &gt; timeout: 272 raise TimeoutError 273 274 with self._pending_requests_lock: 275 response_message = self._pending_requests.pop(request_id) 276 277 # Raise error or return value from response 278 if &quot;error&quot; in response_message[&quot;action&quot;][&quot;args&quot;]: 279 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 280 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] . Synchronously sends a message then waits for and returns the return value of the invoked action. This method allows you to call an action synchronously like a function and receive its return value in python. If the action raises an exception an ActionError will be raised containing the error message. Arguments: . | message: The message to send | timeout: The timeout in seconds to wait for the returned value. Defaults to 3 seconds. | . Returns: . object: The return value of the action. Raises: . | TimeoutError: If the timeout is reached | ActionError: If the action raised an exception | RuntimeError: If called before the agent is processing incoming messages | . def current_message(self) -> agency.schema.Message: View Source 468 def current_message(self) -&gt; Message: 469 &quot;&quot;&quot; 470 Returns the full incoming message which invokes the current action. 471 472 This method may be called within an action or action related callback to 473 retrieve the current message, for example to determine the sender or 474 inspect other details. 475 476 Returns: 477 The current message 478 &quot;&quot;&quot; 479 return self.__thread_local_current_message.value . Returns the full incoming message which invokes the current action. This method may be called within an action or action related callback to retrieve the current message, for example to determine the sender or inspect other details. Returns: . The current message . def parent_message(self, message: agency.schema.Message = None) -> agency.schema.Message: View Source 481 def parent_message(self, message: Message = None) -&gt; Message: 482 &quot;&quot;&quot; 483 Returns the message that the given message is responding to, if any. 484 485 Args: 486 message: The message to get the parent message of. Defaults to the 487 current message. 488 489 Returns: 490 The parent message or None 491 &quot;&quot;&quot; 492 if message is None: 493 message = self.current_message() 494 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 495 if parent_id is not None: 496 return self._find_message(parent_id) . Returns the message that the given message is responding to, if any. Arguments: . | message: The message to get the parent message of. Defaults to the | current message. | . Returns: . The parent message or None . @action def help(self, action_name: str = None) -> dict: View Source 498 @action 499 def help(self, action_name: str = None) -&gt; dict: 500 &quot;&quot;&quot; 501 Returns a list of actions on this agent. 502 503 If action_name is passed, returns a list with only that action. 504 If no action_name is passed, returns all actions. 505 506 Args: 507 action_name: (Optional) The name of an action to request help for 508 509 Returns: 510 A dictionary of actions 511 &quot;&quot;&quot; 512 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME] 513 help_list = { 514 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 515 for method in self.__action_methods().values() 516 if action_name is None 517 and method.action_properties[&quot;name&quot;] not in special_actions 518 or method.action_properties[&quot;name&quot;] == action_name 519 } 520 return help_list . Returns a list of actions on this agent. If action_name is passed, returns a list with only that action. If no action_name is passed, returns all actions. Arguments: . | action_name: (Optional) The name of an action to request help for | . Returns: . A dictionary of actions . def handle_action_value(self, value): View Source 522 def handle_action_value(self, value): 523 &quot;&quot;&quot; 524 Receives a return value from a previous action. 525 526 This method receives return values from actions invoked by the send() 527 method. It is not called when using the request() method, which returns 528 the value directly. 529 530 To inspect the full response message carrying this value, use 531 current_message(). To inspect the message which returned the value, use 532 parent_message(). 533 534 Args: 535 value: 536 The return value 537 &quot;&quot;&quot; 538 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 539 self._issued_handle_action_value_warning = True 540 log(&quot;warning&quot;, 541 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) . Receives a return value from a previous action. This method receives return values from actions invoked by the send() method. It is not called when using the request() method, which returns the value directly. To inspect the full response message carrying this value, use current_message(). To inspect the message which returned the value, use parent_message(). Arguments: . | value: The return value | . def handle_action_error(self, error: ActionError): View Source 543 def handle_action_error(self, error: ActionError): 544 &quot;&quot;&quot; 545 Receives an error from a previous action. 546 547 This method receives errors from actions invoked by the send() method. 548 It is not called when using the request() method, which raises an error 549 directly. 550 551 To inspect the full response message carrying this error, use 552 current_message(). To inspect the message which caused the error, use 553 parent_message(). 554 555 Args: 556 error: The error 557 &quot;&quot;&quot; 558 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 559 self._issued_handle_action_error_warning = True 560 log(&quot;warning&quot;, 561 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) . Receives an error from a previous action. This method receives errors from actions invoked by the send() method. It is not called when using the request() method, which raises an error directly. To inspect the full response message carrying this error, use current_message(). To inspect the message which caused the error, use parent_message(). Arguments: . | error: The error | . def after_add(self): View Source 563 def after_add(self): 564 &quot;&quot;&quot; 565 Called after the agent is added to a space, but before it begins 566 processing incoming messages. 567 568 The agent may send messages during this callback using the send() 569 method, but may not use the request() method since it relies on 570 processing incoming messages. 571 &quot;&quot;&quot; . Called after the agent is added to a space, but before it begins processing incoming messages. The agent may send messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_remove(self): View Source 573 def before_remove(self): 574 &quot;&quot;&quot; 575 Called before the agent is removed from a space, after it has finished 576 processing incoming messages. 577 578 The agent may send final messages during this callback using the send() 579 method, but may not use the request() method since it relies on 580 processing incoming messages. 581 &quot;&quot;&quot; . Called before the agent is removed from a space, after it has finished processing incoming messages. The agent may send final messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_action(self, message: dict): View Source 583 def before_action(self, message: dict): 584 &quot;&quot;&quot; 585 Called before every action. 586 587 This method will only be called if the action exists and is permitted. 588 589 Args: 590 message: The received message that contains the action 591 &quot;&quot;&quot; . Called before every action. This method will only be called if the action exists and is permitted. Arguments: . | message: The received message that contains the action | . def after_action(self, message: dict, return_value: str, error: str): View Source 593 def after_action(self, message: dict, return_value: str, error: str): 594 &quot;&quot;&quot; 595 Called after every action, regardless of whether an error occurred. 596 597 Args: 598 message: The message which invoked the action 599 return_value: The return value from the action 600 error: The error from the action if any 601 &quot;&quot;&quot; . Called after every action, regardless of whether an error occurred. Arguments: . | message: The message which invoked the action | return_value: The return value from the action | error: The error from the action if any | . def request_permission(self, proposed_message: dict) -> bool: View Source 603 def request_permission(self, proposed_message: dict) -&gt; bool: 604 &quot;&quot;&quot; 605 Receives a proposed action message and presents it to the agent for 606 review. 607 608 Args: 609 proposed_message: The proposed action message 610 611 Returns: 612 True if access should be permitted 613 &quot;&quot;&quot; 614 raise NotImplementedError( 615 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . Receives a proposed action message and presents it to the agent for review. Arguments: . | proposed_message: The proposed action message | . Returns: . True if access should be permitted . ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"25": {
    "doc": "agency.agent",
    "title": "agency.agent",
    "content": " ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"26": {
    "doc": "agency.logger",
    "title": "\nagency.logger    ",
    "content": "View Source 1import json 2import logging 3import os 4import traceback 5 6import colorlog 7from colorlog import escape_codes 8from pygments import highlight 9from pygments.formatters import Terminal256Formatter 10from pygments.lexers import get_lexer_by_name 11 12_LOGLEVELS = { 13 &#39;CRITICAL&#39;: 50, 14 &#39;ERROR&#39;: 40, 15 &#39;WARNING&#39;: 30, 16 &#39;INFO&#39;: 20, 17 &#39;DEBUG&#39;: 10, 18 &#39;NOTSET&#39;: 0 19} 20 21_env_loglevel = os.environ.get(&#39;LOGLEVEL&#39;, &#39;WARNING&#39;).upper() 22_LOGLEVEL = _LOGLEVELS[_env_loglevel] 23_LOGFORMAT = &#39;%(asctime_color)s%(asctime)s%(reset_color)s - %(levelname_color)s%(levelname)s%(reset_color)s - %(message_color)s%(message)s%(reset_color)s%(object_color)s%(object)s%(reset_color)s&#39; 24_LOG_PYGMENTS_STYLE = os.environ.get(&#39;LOG_PYGMENTS_STYLE&#39;, &#39;monokai&#39;) 25 26 27class CustomColoredFormatter(colorlog.ColoredFormatter): 28 def format(self, record): 29 record.reset_color = escape_codes.escape_codes[&#39;reset&#39;] 30 record.asctime_color = escape_codes.escape_codes[&#39;light_black&#39;] 31 record.levelname_color = escape_codes.escape_codes[self.log_colors[record.levelname]] 32 record.message_color = escape_codes.escape_codes[&#39;reset&#39;] 33 record.object_color = escape_codes.escape_codes[&#39;reset&#39;] 34 35 return super().format(record) 36 37 38_logger = logging.getLogger(&quot;agency&quot;) 39_logger.setLevel(_LOGLEVEL) 40_handler = logging.StreamHandler() 41_handler.setLevel(_LOGLEVEL) 42 43_formatter = CustomColoredFormatter( 44 _LOGFORMAT, 45 log_colors={ 46 &#39;CRITICAL&#39;: &#39;bold_red&#39;, 47 &#39;ERROR&#39;: &#39;red&#39;, 48 &#39;WARNING&#39;: &#39;yellow&#39;, 49 &#39;INFO&#39;: &#39;green&#39;, 50 &#39;DEBUG&#39;: &#39;cyan&#39;, 51 } 52) 53 54_handler.setFormatter(_formatter) 55_logger.addHandler(_handler) 56 57 58class _CustomEncoder(json.JSONEncoder): 59 def default(self, obj): 60 try: 61 return super().default(obj) 62 except TypeError: 63 return str(obj) 64 65 66def log(level: str, message: str, object=None): 67 pretty_object: str = &quot;&quot; 68 if object != None: 69 try: 70 if isinstance(object, Exception): 71 pretty_object = &quot;\\n&quot; + &quot;&quot;.join(traceback.format_exception( 72 etype=type(object), value=object, tb=object.__traceback__)) 73 else: 74 json_str = json.dumps(object, indent=2, cls=_CustomEncoder) 75 pretty_object = &quot;\\n&quot; + \\ 76 highlight(json_str, get_lexer_by_name(&#39;json&#39;), 77 Terminal256Formatter(style=_LOG_PYGMENTS_STYLE)) 78 except: 79 pass 80 81 numeric_level = _LOGLEVELS.get(level.upper()) 82 if numeric_level is not None: 83 _logger.log(numeric_level, message, extra={&#39;object&#39;: pretty_object}) 84 else: 85 raise ValueError(f&quot;Invalid log level: {level}&quot;) . class CustomColoredFormatter(colorlog.formatter.ColoredFormatter): View Source 28class CustomColoredFormatter(colorlog.ColoredFormatter): 29 def format(self, record): 30 record.reset_color = escape_codes.escape_codes[&#39;reset&#39;] 31 record.asctime_color = escape_codes.escape_codes[&#39;light_black&#39;] 32 record.levelname_color = escape_codes.escape_codes[self.log_colors[record.levelname]] 33 record.message_color = escape_codes.escape_codes[&#39;reset&#39;] 34 record.object_color = escape_codes.escape_codes[&#39;reset&#39;] 35 36 return super().format(record) . A formatter that allows colors to be placed in the format string. Intended to help in creating more readable logging output. def format(self, record): View Source 29 def format(self, record): 30 record.reset_color = escape_codes.escape_codes[&#39;reset&#39;] 31 record.asctime_color = escape_codes.escape_codes[&#39;light_black&#39;] 32 record.levelname_color = escape_codes.escape_codes[self.log_colors[record.levelname]] 33 record.message_color = escape_codes.escape_codes[&#39;reset&#39;] 34 record.object_color = escape_codes.escape_codes[&#39;reset&#39;] 35 36 return super().format(record) . Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Inherited Members . colorlog.formatter.ColoredFormatter ColoredFormatter log_colors secondary_log_colors reset stream no_color force_color formatMessage logging.Formatter converter datefmt default_time_format default_msec_format formatTime formatException usesTime formatStack def log(level: str, message: str, object=None): View Source 67def log(level: str, message: str, object=None): 68 pretty_object: str = &quot;&quot; 69 if object != None: 70 try: 71 if isinstance(object, Exception): 72 pretty_object = &quot;\\n&quot; + &quot;&quot;.join(traceback.format_exception( 73 etype=type(object), value=object, tb=object.__traceback__)) 74 else: 75 json_str = json.dumps(object, indent=2, cls=_CustomEncoder) 76 pretty_object = &quot;\\n&quot; + \\ 77 highlight(json_str, get_lexer_by_name(&#39;json&#39;), 78 Terminal256Formatter(style=_LOG_PYGMENTS_STYLE)) 79 except: 80 pass 81 82 numeric_level = _LOGLEVELS.get(level.upper()) 83 if numeric_level is not None: 84 _logger.log(numeric_level, message, extra={&#39;object&#39;: pretty_object}) 85 else: 86 raise ValueError(f&quot;Invalid log level: {level}&quot;) . ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"27": {
    "doc": "agency.logger",
    "title": "agency.logger",
    "content": " ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"28": {
    "doc": "agency.schema",
    "title": "\nagency.schema    ",
    "content": "View Source 1from pydantic import BaseModel, Field 2from typing import Dict, Optional 3 4 5class Meta(BaseModel): 6 &quot;&quot;&quot;A dictionary field for storing metadata about the message&quot;&quot;&quot; 7 8 class Config: 9 extra = &quot;allow&quot; 10 validate_assignment = True 11 12 id: str = Field( 13 ..., 14 description=&quot;The id of the message.&quot; 15 ) 16 17 parent_id: Optional[str] = Field( 18 None, 19 description=&quot;The id of the previous message that generated this message.&quot; 20 ) 21 22 23class Action(BaseModel): 24 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 25 26 class Config: 27 extra = &quot;forbid&quot; 28 validate_assignment = True 29 30 name: str = Field( 31 ..., 32 description=&quot;The name of the action.&quot; 33 ) 34 35 args: Optional[Dict] = Field( 36 None, 37 description=&quot;The arguments for the action.&quot; 38 ) 39 40 41class Message(BaseModel): 42 &quot;&quot;&quot;Schema for a message&quot;&quot;&quot; 43 44 class Config: 45 extra = &quot;forbid&quot; 46 validate_assignment = True 47 48 meta: Meta 49 50 from_: str = Field( 51 ..., 52 alias=&quot;from&quot;, 53 description=&quot;The id of the sender.&quot; 54 ) 55 56 to: str = Field( 57 ..., 58 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 59 ) 60 61 action: Action 62 63 64def validate_message(message: Message) -&gt; Message: 65 &quot;&quot;&quot; 66 Validate and return a message 67 68 Args: 69 message: The message 70 71 Returns: 72 The validated message 73 74 Raises: 75 ValueError: If the message is invalid 76 &quot;&quot;&quot; 77 try: 78 return Message(**message).dict(by_alias=True, exclude_unset=True) 79 except TypeError as e: 80 raise ValueError(str(e)) . class Meta(pydantic.main.BaseModel): View Source 6class Meta(BaseModel): 7 &quot;&quot;&quot;A dictionary field for storing metadata about the message&quot;&quot;&quot; 8 9 class Config: 10 extra = &quot;allow&quot; 11 validate_assignment = True 12 13 id: str = Field( 14 ..., 15 description=&quot;The id of the message.&quot; 16 ) 17 18 parent_id: Optional[str] = Field( 19 None, 20 description=&quot;The id of the previous message that generated this message.&quot; 21 ) . A dictionary field for storing metadata about the message . id: str parent_id: Optional[str] Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Meta.Config: View Source 9 class Config: 10 extra = &quot;allow&quot; 11 validate_assignment = True . extra = &#39;allow&#39; validate_assignment = True class Action(pydantic.main.BaseModel): View Source 24class Action(BaseModel): 25 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 26 27 class Config: 28 extra = &quot;forbid&quot; 29 validate_assignment = True 30 31 name: str = Field( 32 ..., 33 description=&quot;The name of the action.&quot; 34 ) 35 36 args: Optional[Dict] = Field( 37 None, 38 description=&quot;The arguments for the action.&quot; 39 ) . Schema for an action . name: str args: Optional[Dict] Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Action.Config: View Source 27 class Config: 28 extra = &quot;forbid&quot; 29 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True class Message(pydantic.main.BaseModel): View Source 42class Message(BaseModel): 43 &quot;&quot;&quot;Schema for a message&quot;&quot;&quot; 44 45 class Config: 46 extra = &quot;forbid&quot; 47 validate_assignment = True 48 49 meta: Meta 50 51 from_: str = Field( 52 ..., 53 alias=&quot;from&quot;, 54 description=&quot;The id of the sender.&quot; 55 ) 56 57 to: str = Field( 58 ..., 59 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 60 ) 61 62 action: Action . Schema for a message . meta: Meta from_: str to: str action: Action Inherited Members . pydantic.main.BaseModel BaseModel dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Message.Config: View Source 45 class Config: 46 extra = &quot;forbid&quot; 47 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True def validate_message(message: Message) -> Message: View Source 65def validate_message(message: Message) -&gt; Message: 66 &quot;&quot;&quot; 67 Validate and return a message 68 69 Args: 70 message: The message 71 72 Returns: 73 The validated message 74 75 Raises: 76 ValueError: If the message is invalid 77 &quot;&quot;&quot; 78 try: 79 return Message(**message).dict(by_alias=True, exclude_unset=True) 80 except TypeError as e: 81 raise ValueError(str(e)) . Validate and return a message . Arguments: . | message: The message | . Returns: . The validated message . Raises: . | ValueError: If the message is invalid | . ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"29": {
    "doc": "agency.schema",
    "title": "agency.schema",
    "content": " ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"30": {
    "doc": "agency.space",
    "title": "\nagency.space    ",
    "content": "View Source 1from abc import ABC, ABCMeta, abstractmethod 2from typing import Type 3from agency.agent import Agent 4 5 6class Space(ABC, metaclass=ABCMeta): 7 &quot;&quot;&quot; 8 Space implementations are responsible for 9 - Managing the lifecycle of agent instances 10 - Ensuring communication between agents 11 &quot;&quot;&quot; 12 13 @abstractmethod 14 def add(self, agent_type: Type[Agent], agent_id: str, **kwargs): 15 &quot;&quot;&quot; 16 Adds an agent to the space allowing it to communicate. 17 18 Keyword arguments are passed to the agent&#39;s constructor. 19 20 Args: 21 agent_type: The type of agent to add 22 agent_id: The id of the agent to add 23 24 Raises: 25 ValueError: If the agent ID is already in use 26 &quot;&quot;&quot; 27 28 @abstractmethod 29 def remove(self, agent_id: str): 30 &quot;&quot;&quot; 31 Removes an agent from the space by id. 32 33 This method cannot remove an agent instance added from a different space 34 instance. In other words, a space instance cannot remove an agent that 35 it did not add. 36 37 Args: 38 agent_id: The id of the agent to remove 39 40 Raises: 41 ValueError: If the agent is not present in the space 42 &quot;&quot;&quot; 43 44 @abstractmethod 45 def remove_all(self): 46 &quot;&quot;&quot; 47 Removes all agents added through this space instance. 48 &quot;&quot;&quot; . class Space(abc.ABC): View Source 7class Space(ABC, metaclass=ABCMeta): 8 &quot;&quot;&quot; 9 Space implementations are responsible for 10 - Managing the lifecycle of agent instances 11 - Ensuring communication between agents 12 &quot;&quot;&quot; 13 14 @abstractmethod 15 def add(self, agent_type: Type[Agent], agent_id: str, **kwargs): 16 &quot;&quot;&quot; 17 Adds an agent to the space allowing it to communicate. 18 19 Keyword arguments are passed to the agent&#39;s constructor. 20 21 Args: 22 agent_type: The type of agent to add 23 agent_id: The id of the agent to add 24 25 Raises: 26 ValueError: If the agent ID is already in use 27 &quot;&quot;&quot; 28 29 @abstractmethod 30 def remove(self, agent_id: str): 31 &quot;&quot;&quot; 32 Removes an agent from the space by id. 33 34 This method cannot remove an agent instance added from a different space 35 instance. In other words, a space instance cannot remove an agent that 36 it did not add. 37 38 Args: 39 agent_id: The id of the agent to remove 40 41 Raises: 42 ValueError: If the agent is not present in the space 43 &quot;&quot;&quot; 44 45 @abstractmethod 46 def remove_all(self): 47 &quot;&quot;&quot; 48 Removes all agents added through this space instance. 49 &quot;&quot;&quot; . Space implementations are responsible for . | Managing the lifecycle of agent instances | Ensuring communication between agents | . @abstractmethod def add(self, agent_type: Type[agency.agent.Agent], agent_id: str, **kwargs): View Source 14 @abstractmethod 15 def add(self, agent_type: Type[Agent], agent_id: str, **kwargs): 16 &quot;&quot;&quot; 17 Adds an agent to the space allowing it to communicate. 18 19 Keyword arguments are passed to the agent&#39;s constructor. 20 21 Args: 22 agent_type: The type of agent to add 23 agent_id: The id of the agent to add 24 25 Raises: 26 ValueError: If the agent ID is already in use 27 &quot;&quot;&quot; . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . @abstractmethod def remove(self, agent_id: str): View Source 29 @abstractmethod 30 def remove(self, agent_id: str): 31 &quot;&quot;&quot; 32 Removes an agent from the space by id. 33 34 This method cannot remove an agent instance added from a different space 35 instance. In other words, a space instance cannot remove an agent that 36 it did not add. 37 38 Args: 39 agent_id: The id of the agent to remove 40 41 Raises: 42 ValueError: If the agent is not present in the space 43 &quot;&quot;&quot; . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . @abstractmethod def remove_all(self): View Source 45 @abstractmethod 46 def remove_all(self): 47 &quot;&quot;&quot; 48 Removes all agents added through this space instance. 49 &quot;&quot;&quot; . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"31": {
    "doc": "agency.space",
    "title": "agency.space",
    "content": " ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"32": {
    "doc": "agency.spaces",
    "title": "\nagency.spaces    ",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"33": {
    "doc": "agency.spaces",
    "title": "Submodules",
    "content": ". | amqp_space | multiprocess_space | thread_space | . ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"34": {
    "doc": "agency.spaces",
    "title": "agency.spaces",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"35": {
    "doc": "agency.spaces.amqp_space",
    "title": "\nagency.spaces.amqp_space    ",
    "content": "View Source 1import json 2import multiprocessing 3import os 4import queue 5import socket 6import threading 7import time 8import traceback 9from dataclasses import dataclass 10from multiprocessing import Event, Process 11from typing import Dict, Type 12 13from amqp import ResourceLocked 14from kombu import Connection, Exchange, Queue 15 16from agency.agent import Agent 17from agency.logger import log 18from agency.schema import Message, validate_message 19from agency.space import Space 20 21 22class _AgentAMQPProcess(): 23 def __init__( 24 self, 25 agent_type: Type[Agent], 26 agent_id: str, 27 agent_kwargs: Dict, 28 kombu_connection_options: Dict, 29 exchange_name: str, 30 outbound_queue: multiprocessing.Queue, 31 ): 32 self.agent_type: Type[Agent] = agent_type 33 self.agent_id: str = agent_id 34 self.agent_kwargs: Dict = agent_kwargs 35 self.kombu_connection_options: Dict = kombu_connection_options 36 self.exchange_name: str = exchange_name 37 self.outbound_queue: multiprocessing.Queue = outbound_queue 38 39 def start(self): 40 self.__started = Event() 41 self.__stopping = Event() 42 error_queue = multiprocessing.Queue() 43 self.__process = Process( 44 target=self._process, 45 args=( 46 self.agent_type, 47 self.agent_id, 48 self.agent_kwargs, 49 self.kombu_connection_options, 50 self.exchange_name, 51 self.outbound_queue, 52 self.__started, 53 self.__stopping, 54 error_queue, 55 ) 56 ) 57 self.__process.start() 58 59 if not self.__started.wait(timeout=10): 60 self.stop() 61 try: 62 error = error_queue.get(block=False) 63 raise error 64 except queue.Empty: 65 raise Exception(&quot;Process could not be started.&quot;) 66 67 def stop(self): 68 self.__stopping.set() 69 if self.__process.is_alive(): 70 self.__process.join(timeout=10) 71 if self.__process.is_alive(): 72 raise Exception(&quot;Process could not be stopped.&quot;) 73 74 def _process(self, 75 agent_type, 76 agent_id, 77 agent_kwargs, 78 kombu_connection_options, 79 exchange_name, 80 outbound_queue, 81 started, 82 stopping, 83 error_queue): 84 85 try: 86 # Create a connection and Exchange 87 exchange: Exchange = Exchange( 88 exchange_name, 89 type=&#39;topic&#39;, 90 durable=False, 91 ) 92 connection = Connection(**kombu_connection_options) 93 connection.connect() 94 if not connection.connected: 95 raise ConnectionError(&quot;Unable to connect to AMQP server&quot;) 96 97 # Create a queue for direct messages 98 direct_queue = Queue( 99 f&quot;{agent_id}-direct&quot;, 100 exchange=exchange, 101 routing_key=agent_id, 102 exclusive=True, 103 ) 104 direct_queue(connection.channel()).declare() 105 106 # Create a separate broadcast queue 107 broadcast_queue = Queue( 108 f&quot;{agent_id}-broadcast&quot;, 109 exchange=exchange, 110 routing_key=AMQPSpace._BROADCAST_KEY, 111 exclusive=True, 112 ) 113 broadcast_queue(connection.channel()).declare() 114 115 # Define callback for incoming messages 116 def _on_message(body, message): 117 message.ack() 118 message_data = json.loads(body) 119 if message_data[&#39;to&#39;] == &#39;*&#39; or message_data[&#39;to&#39;] == agent.id(): 120 agent._receive(message_data) 121 122 # Consume from direct and broadcast queues 123 consumer = connection.Consumer( 124 [direct_queue, broadcast_queue], 125 callbacks=[_on_message], 126 ) 127 128 # Start the consumer 129 consumer.consume() 130 131 # Create agent 132 agent: Agent = agent_type( 133 agent_id, 134 outbound_queue=outbound_queue, 135 **agent_kwargs, 136 ) 137 138 # Start loop 139 agent.after_add() 140 log(&quot;info&quot;, f&quot;{agent.id()} added to space&quot;) 141 agent._is_processing = True 142 started.set() 143 while not stopping.is_set(): 144 time.sleep(0.001) 145 connection.heartbeat_check() # sends heartbeat if necessary 146 try: 147 connection.drain_events(timeout=0.001) 148 except socket.timeout: 149 pass 150 except ResourceLocked: 151 error_queue.put( 152 ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;)) 153 except KeyboardInterrupt: 154 pass 155 except Exception as e: 156 log(&quot;error&quot;, f&quot;{agent_id} process failed with exception&quot;, 157 traceback.format_exc()) 158 error_queue.put(e) 159 finally: 160 agent._is_processing = False 161 agent.before_remove() 162 connection.release() 163 log(&quot;info&quot;, f&quot;{agent.id()} removed from space&quot;) 164 165 166@dataclass 167class AMQPOptions: 168 &quot;&quot;&quot; 169 A class that defines AMQP connection options 170 &quot;&quot;&quot; 171 hostname: str = &#39;localhost&#39; 172 port: int = &#39;5672&#39; 173 username: str = &#39;guest&#39; 174 password: str = &#39;guest&#39; 175 virtual_host: str = &#39;/&#39; 176 use_ssl: bool = False 177 heartbeat: float = 60 178 179 180class AMQPSpace(Space): 181 &quot;&quot;&quot; 182 A Space that uses AMQP for message delivery. 183 184 This Space type is useful for distributing agents across multiple hosts. 185 186 AMQPSpace uses multiprocessing for parallelism when multiple agents are 187 added to the same instance. 188 &quot;&quot;&quot; 189 190 _BROADCAST_KEY = &quot;__broadcast__&quot; 191 192 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 193 if amqp_options is None: 194 amqp_options = self.__default_amqp_options() 195 self.__kombu_connection_options = { 196 &#39;hostname&#39;: amqp_options.hostname, 197 &#39;port&#39;: amqp_options.port, 198 &#39;userid&#39;: amqp_options.username, 199 &#39;password&#39;: amqp_options.password, 200 &#39;virtual_host&#39;: amqp_options.virtual_host, 201 &#39;ssl&#39;: amqp_options.use_ssl, 202 &#39;heartbeat&#39;: amqp_options.heartbeat, 203 } 204 self.__exchange_name: str = exchange_name 205 self.__exchange: Exchange = Exchange( 206 self.__exchange_name, 207 type=&#39;topic&#39;, 208 durable=False, 209 ) 210 self.__agent_processes: Dict[str, _AgentAMQPProcess] = {} 211 router_thread = threading.Thread( 212 target=self.__router_thread, daemon=True) 213 router_thread.start() 214 215 def __router_thread(self): 216 &quot;&quot;&quot;Processes and routes outbound messages for all agents&quot;&quot;&quot; 217 while True: 218 time.sleep(0.001) 219 for agent_process in list(self.__agent_processes.values()): 220 outbound_queue = agent_process.outbound_queue 221 try: 222 # process one message per agent per loop 223 message = outbound_queue.get(block=False) 224 self._route(message) 225 except queue.Empty: 226 pass 227 228 def _route(self, message: Message): 229 message = validate_message(message) 230 231 if message[&#39;to&#39;] == &#39;*&#39;: 232 # broadcast 233 routing_key = self._BROADCAST_KEY 234 else: 235 # point to point 236 routing_key = message[&#39;to&#39;] 237 238 with Connection(**self.__kombu_connection_options) as connection: 239 with connection.Producer(serializer=&quot;json&quot;) as producer: 240 producer.publish( 241 json.dumps(message), 242 exchange=self.__exchange, 243 routing_key=routing_key) 244 245 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 246 try: 247 self.__agent_processes[agent_id] = _AgentAMQPProcess( 248 agent_type=agent_type, 249 agent_id=agent_id, 250 agent_kwargs=agent_kwargs, 251 kombu_connection_options=self.__kombu_connection_options, 252 exchange_name=self.__exchange_name, 253 outbound_queue=multiprocessing.Queue(), 254 ) 255 self.__agent_processes[agent_id].start() 256 257 except: 258 # clean up if an error occurs 259 self.remove(agent_id) 260 raise 261 262 def remove(self, agent_id: str): 263 agent_process = self.__agent_processes[agent_id] 264 agent_process.stop() 265 del self.__agent_processes[agent_id] 266 267 def remove_all(self): 268 agent_ids = list(self.__agent_processes.keys()) 269 for agent_id in agent_ids: 270 self.remove(agent_id) 271 272 def __default_amqp_options(self) -&gt; AMQPOptions: 273 &quot;&quot;&quot; 274 Returns a default AMQPOptions object configurable from environment 275 variables. 276 &quot;&quot;&quot; 277 return AMQPOptions( 278 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 279 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 280 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 281 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 282 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 283 use_ssl=False, 284 heartbeat=60, 285 ) . @dataclass class AMQPOptions: View Source 167@dataclass 168class AMQPOptions: 169 &quot;&quot;&quot; 170 A class that defines AMQP connection options 171 &quot;&quot;&quot; 172 hostname: str = &#39;localhost&#39; 173 port: int = &#39;5672&#39; 174 username: str = &#39;guest&#39; 175 password: str = &#39;guest&#39; 176 virtual_host: str = &#39;/&#39; 177 use_ssl: bool = False 178 heartbeat: float = 60 . A class that defines AMQP connection options . AMQPOptions( hostname: str = &#39;localhost&#39;, port: int = &#39;5672&#39;, username: str = &#39;guest&#39;, password: str = &#39;guest&#39;, virtual_host: str = &#39;/&#39;, use_ssl: bool = False, heartbeat: float = 60) hostname: str = &#39;localhost&#39; port: int = &#39;5672&#39; username: str = &#39;guest&#39; password: str = &#39;guest&#39; virtual_host: str = &#39;/&#39; use_ssl: bool = False heartbeat: float = 60 class AMQPSpace(agency.space.Space): View Source 181class AMQPSpace(Space): 182 &quot;&quot;&quot; 183 A Space that uses AMQP for message delivery. 184 185 This Space type is useful for distributing agents across multiple hosts. 186 187 AMQPSpace uses multiprocessing for parallelism when multiple agents are 188 added to the same instance. 189 &quot;&quot;&quot; 190 191 _BROADCAST_KEY = &quot;__broadcast__&quot; 192 193 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 194 if amqp_options is None: 195 amqp_options = self.__default_amqp_options() 196 self.__kombu_connection_options = { 197 &#39;hostname&#39;: amqp_options.hostname, 198 &#39;port&#39;: amqp_options.port, 199 &#39;userid&#39;: amqp_options.username, 200 &#39;password&#39;: amqp_options.password, 201 &#39;virtual_host&#39;: amqp_options.virtual_host, 202 &#39;ssl&#39;: amqp_options.use_ssl, 203 &#39;heartbeat&#39;: amqp_options.heartbeat, 204 } 205 self.__exchange_name: str = exchange_name 206 self.__exchange: Exchange = Exchange( 207 self.__exchange_name, 208 type=&#39;topic&#39;, 209 durable=False, 210 ) 211 self.__agent_processes: Dict[str, _AgentAMQPProcess] = {} 212 router_thread = threading.Thread( 213 target=self.__router_thread, daemon=True) 214 router_thread.start() 215 216 def __router_thread(self): 217 &quot;&quot;&quot;Processes and routes outbound messages for all agents&quot;&quot;&quot; 218 while True: 219 time.sleep(0.001) 220 for agent_process in list(self.__agent_processes.values()): 221 outbound_queue = agent_process.outbound_queue 222 try: 223 # process one message per agent per loop 224 message = outbound_queue.get(block=False) 225 self._route(message) 226 except queue.Empty: 227 pass 228 229 def _route(self, message: Message): 230 message = validate_message(message) 231 232 if message[&#39;to&#39;] == &#39;*&#39;: 233 # broadcast 234 routing_key = self._BROADCAST_KEY 235 else: 236 # point to point 237 routing_key = message[&#39;to&#39;] 238 239 with Connection(**self.__kombu_connection_options) as connection: 240 with connection.Producer(serializer=&quot;json&quot;) as producer: 241 producer.publish( 242 json.dumps(message), 243 exchange=self.__exchange, 244 routing_key=routing_key) 245 246 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 247 try: 248 self.__agent_processes[agent_id] = _AgentAMQPProcess( 249 agent_type=agent_type, 250 agent_id=agent_id, 251 agent_kwargs=agent_kwargs, 252 kombu_connection_options=self.__kombu_connection_options, 253 exchange_name=self.__exchange_name, 254 outbound_queue=multiprocessing.Queue(), 255 ) 256 self.__agent_processes[agent_id].start() 257 258 except: 259 # clean up if an error occurs 260 self.remove(agent_id) 261 raise 262 263 def remove(self, agent_id: str): 264 agent_process = self.__agent_processes[agent_id] 265 agent_process.stop() 266 del self.__agent_processes[agent_id] 267 268 def remove_all(self): 269 agent_ids = list(self.__agent_processes.keys()) 270 for agent_id in agent_ids: 271 self.remove(agent_id) 272 273 def __default_amqp_options(self) -&gt; AMQPOptions: 274 &quot;&quot;&quot; 275 Returns a default AMQPOptions object configurable from environment 276 variables. 277 &quot;&quot;&quot; 278 return AMQPOptions( 279 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 280 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 281 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 282 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 283 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 284 use_ssl=False, 285 heartbeat=60, 286 ) . A Space that uses AMQP for message delivery. This Space type is useful for distributing agents across multiple hosts. AMQPSpace uses multiprocessing for parallelism when multiple agents are added to the same instance. AMQPSpace( amqp_options: AMQPOptions = None, exchange_name: str = &#39;agency&#39;) View Source 193 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 194 if amqp_options is None: 195 amqp_options = self.__default_amqp_options() 196 self.__kombu_connection_options = { 197 &#39;hostname&#39;: amqp_options.hostname, 198 &#39;port&#39;: amqp_options.port, 199 &#39;userid&#39;: amqp_options.username, 200 &#39;password&#39;: amqp_options.password, 201 &#39;virtual_host&#39;: amqp_options.virtual_host, 202 &#39;ssl&#39;: amqp_options.use_ssl, 203 &#39;heartbeat&#39;: amqp_options.heartbeat, 204 } 205 self.__exchange_name: str = exchange_name 206 self.__exchange: Exchange = Exchange( 207 self.__exchange_name, 208 type=&#39;topic&#39;, 209 durable=False, 210 ) 211 self.__agent_processes: Dict[str, _AgentAMQPProcess] = {} 212 router_thread = threading.Thread( 213 target=self.__router_thread, daemon=True) 214 router_thread.start() . def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, **agent_kwargs) -> agency.agent.Agent: View Source 246 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 247 try: 248 self.__agent_processes[agent_id] = _AgentAMQPProcess( 249 agent_type=agent_type, 250 agent_id=agent_id, 251 agent_kwargs=agent_kwargs, 252 kombu_connection_options=self.__kombu_connection_options, 253 exchange_name=self.__exchange_name, 254 outbound_queue=multiprocessing.Queue(), 255 ) 256 self.__agent_processes[agent_id].start() 257 258 except: 259 # clean up if an error occurs 260 self.remove(agent_id) 261 raise . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 263 def remove(self, agent_id: str): 264 agent_process = self.__agent_processes[agent_id] 265 agent_process.stop() 266 del self.__agent_processes[agent_id] . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def remove_all(self): View Source 268 def remove_all(self): 269 agent_ids = list(self.__agent_processes.keys()) 270 for agent_id in agent_ids: 271 self.remove(agent_id) . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"36": {
    "doc": "agency.spaces.amqp_space",
    "title": "agency.spaces.amqp_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"37": {
    "doc": "agency.spaces.multiprocess_space",
    "title": "\nagency.spaces.multiprocess_space    ",
    "content": "View Source 1import multiprocessing 2import queue 3import threading 4import time 5import traceback 6from multiprocessing import Event, Process 7from typing import Dict, Type 8 9from agency.agent import Agent, _QueueProtocol 10from agency.logger import log 11from agency.schema import Message, validate_message 12from agency.space import Space 13 14 15class _AgentProcess(): 16 def __init__( 17 self, 18 agent_type: Type[Agent], 19 agent_id: str, 20 agent_kwargs: Dict, 21 inbound_queue: _QueueProtocol, 22 outbound_queue: _QueueProtocol): 23 self.agent_type: Type[Agent] = agent_type 24 self.agent_id: str = agent_id 25 self.agent_kwargs: Dict = agent_kwargs 26 self.inbound_queue: _QueueProtocol = inbound_queue 27 self.outbound_queue: _QueueProtocol = outbound_queue 28 29 def start(self): 30 self.started = Event() 31 self.stopping = Event() 32 error_queue = multiprocessing.Queue() 33 self.process = Process( 34 target=self._process, 35 args=( 36 self.agent_type, 37 self.agent_id, 38 self.agent_kwargs, 39 self.inbound_queue, 40 self.outbound_queue, 41 self.started, 42 self.stopping, 43 error_queue, 44 ) 45 ) 46 self.process.start() 47 48 if not self.started.wait(timeout=10): 49 # it couldn&#39;t start, force stop the process and raise an exception 50 self.stop() 51 try: 52 error = error_queue.get(block=False) 53 raise error 54 except queue.Empty: 55 raise Exception(&quot;Process could not be started.&quot;) 56 57 def stop(self): 58 self.stopping.set() 59 if self.process.is_alive(): 60 self.process.join(timeout=10) 61 if self.process.is_alive(): 62 raise Exception(&quot;Process could not be stopped.&quot;) 63 64 def _process(self, 65 agent_type, 66 agent_id, 67 agent_kwargs, 68 inbound_queue, 69 outbound_queue, 70 started, 71 stopping, 72 error_queue): 73 try: 74 agent: Agent = agent_type( 75 agent_id, 76 outbound_queue=outbound_queue, 77 **agent_kwargs, 78 ) 79 agent.after_add() 80 log(&quot;info&quot;, f&quot;{agent.id()} added to space&quot;) 81 agent._is_processing = True 82 started.set() 83 while not stopping.is_set(): 84 time.sleep(0.001) 85 try: 86 message = inbound_queue.get(block=False) 87 agent._receive(message) 88 except queue.Empty: 89 pass 90 except KeyboardInterrupt: 91 pass 92 except Exception as e: 93 log(&quot;error&quot;, f&quot;{agent.id()} process failed with exception&quot;, traceback.format_exc()) 94 error_queue.put(e) 95 finally: 96 agent._is_processing = False 97 agent.before_remove() 98 log(&quot;info&quot;, f&quot;{agent.id()} removed from space&quot;) 99 100 101class MultiprocessSpace(Space): 102 &quot;&quot;&quot; 103 A Space implementation that uses the multiprocessing module. 104 105 This Space type is recommended in most cases over ThreadSpace for single 106 host systems since it offers better parallelism. 107 &quot;&quot;&quot; 108 109 def __init__(self): 110 self.__agent_processes: Dict[str, _AgentProcess] = {} 111 router_thread = threading.Thread( 112 target=self.__router_thread, daemon=True) 113 router_thread.start() 114 115 def __router_thread(self): 116 &quot;&quot;&quot; 117 Processes and routes outbound messages for all agents 118 &quot;&quot;&quot; 119 while True: 120 time.sleep(0.001) 121 for agent_process in list(self.__agent_processes.values()): 122 outbound_queue = agent_process.outbound_queue 123 try: 124 # process one message per agent per loop 125 message = outbound_queue.get(block=False) 126 self._route(message) 127 except queue.Empty: 128 pass 129 130 def _route(self, message: Message): 131 message = validate_message(message) 132 recipient_processes = [ 133 agent_process 134 for agent_process in list(self.__agent_processes.values()) 135 if message[&quot;to&quot;] == agent_process.agent_id or message[&quot;to&quot;] == &quot;*&quot; 136 ] 137 for recipient_process in recipient_processes: 138 recipient_process.inbound_queue.put(message) 139 140 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 141 if agent_id in self.__agent_processes.keys(): 142 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 143 144 try: 145 self.__agent_processes[agent_id] = _AgentProcess( 146 agent_type=agent_type, 147 agent_id=agent_id, 148 agent_kwargs=agent_kwargs, 149 inbound_queue=multiprocessing.Queue(), 150 outbound_queue=multiprocessing.Queue(), 151 ) 152 self.__agent_processes[agent_id].start() 153 except: 154 # clean up if an error occurs 155 self.remove(agent_id) 156 raise 157 158 def remove(self, agent_id: str): 159 agent_process = self.__agent_processes[agent_id] 160 agent_process.stop() 161 del self.__agent_processes[agent_id] 162 163 def remove_all(self): 164 agent_ids = list(self.__agent_processes.keys()) 165 for agent_id in agent_ids: 166 self.remove(agent_id) . class MultiprocessSpace(agency.space.Space): View Source 102class MultiprocessSpace(Space): 103 &quot;&quot;&quot; 104 A Space implementation that uses the multiprocessing module. 105 106 This Space type is recommended in most cases over ThreadSpace for single 107 host systems since it offers better parallelism. 108 &quot;&quot;&quot; 109 110 def __init__(self): 111 self.__agent_processes: Dict[str, _AgentProcess] = {} 112 router_thread = threading.Thread( 113 target=self.__router_thread, daemon=True) 114 router_thread.start() 115 116 def __router_thread(self): 117 &quot;&quot;&quot; 118 Processes and routes outbound messages for all agents 119 &quot;&quot;&quot; 120 while True: 121 time.sleep(0.001) 122 for agent_process in list(self.__agent_processes.values()): 123 outbound_queue = agent_process.outbound_queue 124 try: 125 # process one message per agent per loop 126 message = outbound_queue.get(block=False) 127 self._route(message) 128 except queue.Empty: 129 pass 130 131 def _route(self, message: Message): 132 message = validate_message(message) 133 recipient_processes = [ 134 agent_process 135 for agent_process in list(self.__agent_processes.values()) 136 if message[&quot;to&quot;] == agent_process.agent_id or message[&quot;to&quot;] == &quot;*&quot; 137 ] 138 for recipient_process in recipient_processes: 139 recipient_process.inbound_queue.put(message) 140 141 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 142 if agent_id in self.__agent_processes.keys(): 143 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 144 145 try: 146 self.__agent_processes[agent_id] = _AgentProcess( 147 agent_type=agent_type, 148 agent_id=agent_id, 149 agent_kwargs=agent_kwargs, 150 inbound_queue=multiprocessing.Queue(), 151 outbound_queue=multiprocessing.Queue(), 152 ) 153 self.__agent_processes[agent_id].start() 154 except: 155 # clean up if an error occurs 156 self.remove(agent_id) 157 raise 158 159 def remove(self, agent_id: str): 160 agent_process = self.__agent_processes[agent_id] 161 agent_process.stop() 162 del self.__agent_processes[agent_id] 163 164 def remove_all(self): 165 agent_ids = list(self.__agent_processes.keys()) 166 for agent_id in agent_ids: 167 self.remove(agent_id) . A Space implementation that uses the multiprocessing module. This Space type is recommended in most cases over ThreadSpace for single host systems since it offers better parallelism. def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, **agent_kwargs) -> agency.agent.Agent: View Source 141 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs) -&gt; Agent: 142 if agent_id in self.__agent_processes.keys(): 143 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 144 145 try: 146 self.__agent_processes[agent_id] = _AgentProcess( 147 agent_type=agent_type, 148 agent_id=agent_id, 149 agent_kwargs=agent_kwargs, 150 inbound_queue=multiprocessing.Queue(), 151 outbound_queue=multiprocessing.Queue(), 152 ) 153 self.__agent_processes[agent_id].start() 154 except: 155 # clean up if an error occurs 156 self.remove(agent_id) 157 raise . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 159 def remove(self, agent_id: str): 160 agent_process = self.__agent_processes[agent_id] 161 agent_process.stop() 162 del self.__agent_processes[agent_id] . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def remove_all(self): View Source 164 def remove_all(self): 165 agent_ids = list(self.__agent_processes.keys()) 166 for agent_id in agent_ids: 167 self.remove(agent_id) . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/spaces/multiprocess_space.html",
    
    "relUrl": "/api_docs/agency/spaces/multiprocess_space.html"
  },"38": {
    "doc": "agency.spaces.multiprocess_space",
    "title": "agency.spaces.multiprocess_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/multiprocess_space.html",
    
    "relUrl": "/api_docs/agency/spaces/multiprocess_space.html"
  },"39": {
    "doc": "agency.spaces.thread_space",
    "title": "\nagency.spaces.thread_space    ",
    "content": "View Source 1import queue 2import threading 3import time 4import traceback 5from typing import Dict, Type 6 7from agency.agent import Agent, _QueueProtocol 8from agency.logger import log 9from agency.schema import Message, validate_message 10from agency.space import Space 11 12 13class _AgentThread(): 14 def __init__( 15 self, 16 agent_type: Type[Agent], 17 agent_id: str, 18 agent_kwargs: Dict, 19 inbound_queue: _QueueProtocol, 20 outbound_queue: _QueueProtocol): 21 self.agent_type: Type[Agent] = agent_type 22 self.agent_id: str = agent_id 23 self.agent_kwargs: Dict = agent_kwargs 24 self.inbound_queue: _QueueProtocol = inbound_queue 25 self.outbound_queue: _QueueProtocol = outbound_queue 26 self.__started = threading.Event() 27 self.__stopping = threading.Event() 28 29 def start(self): 30 def _thread(exception_info): 31 try: 32 agent = self.agent_type( 33 self.agent_id, 34 outbound_queue=self.outbound_queue, 35 **self.agent_kwargs, 36 ) 37 agent.after_add() 38 log(&quot;info&quot;, f&quot;{agent.id()} added to space&quot;) 39 agent._is_processing = True 40 self.__started.set() 41 while not self.__stopping.is_set(): 42 time.sleep(0.001) 43 try: 44 message = self.inbound_queue.get(block=False) 45 agent._receive(message) 46 except queue.Empty: 47 pass 48 except KeyboardInterrupt: 49 pass 50 except Exception as e: 51 log(&quot;error&quot;, f&quot;{self.agent_id} thread failed with exception&quot;, traceback.format_exc()) 52 exception_info[&quot;exception&quot;] = e 53 finally: 54 agent._is_processing = False 55 agent.before_remove() 56 log(&quot;info&quot;, f&quot;{agent.id()} removed from space&quot;) 57 58 exception_info = {&quot;exception&quot;: None} 59 self.__thread = threading.Thread( 60 target=_thread, args=(exception_info,), daemon=True) 61 self.__thread.start() 62 63 if not self.__started.wait(timeout=10): 64 # it couldn&#39;t start clean up and raise an exception 65 self.stop() 66 if exception_info[&quot;exception&quot;] is not None: 67 raise exception_info[&quot;exception&quot;] 68 else: 69 raise Exception(&quot;Thread could not be started.&quot;) 70 71 def stop(self): 72 self.__stopping.set() 73 self.__thread.join(timeout=10) 74 if self.__thread.is_alive(): 75 raise Exception(&quot;Thread could not be stopped.&quot;) 76 77 78class ThreadSpace(Space): 79 &quot;&quot;&quot; 80 A Space implementation that uses the threading module. 81 82 This Space type is recommended for testing or simple applications. 83 &quot;&quot;&quot; 84 85 def __init__(self): 86 self.__agent_threads: Dict[str, _AgentThread] = {} 87 router_thread = threading.Thread( 88 target=self.__router_thread, daemon=True) 89 router_thread.start() 90 91 def __router_thread(self): 92 &quot;&quot;&quot; 93 Processes and routes outbound messages for all agents 94 &quot;&quot;&quot; 95 while True: 96 time.sleep(0.001) 97 for agent_thread in list(self.__agent_threads.values()): 98 outbound_queue = agent_thread.outbound_queue 99 try: 100 # process one message per agent per loop 101 message = outbound_queue.get(block=False) 102 self._route(message) 103 except queue.Empty: 104 pass 105 106 def _route(self, message: Message): 107 message = validate_message(message) 108 recipient_threads = [ 109 agent_thread 110 for agent_thread in list(self.__agent_threads.values()) 111 if message[&quot;to&quot;] == agent_thread.agent_id or message[&quot;to&quot;] == &quot;*&quot; 112 ] 113 for recipient_thread in recipient_threads: 114 recipient_thread.inbound_queue.put(message) 115 116 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs): 117 if agent_id in self.__agent_threads.keys(): 118 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 119 120 try: 121 self.__agent_threads[agent_id] = _AgentThread( 122 agent_type=agent_type, 123 agent_id=agent_id, 124 agent_kwargs=agent_kwargs, 125 inbound_queue=queue.Queue(), 126 outbound_queue=queue.Queue(), 127 ) 128 self.__agent_threads[agent_id].start() 129 130 except: 131 # clean up if an error occurs 132 self.remove(agent_id) 133 raise 134 135 def remove(self, agent_id: str): 136 agent_thread = self.__agent_threads[agent_id] 137 agent_thread.stop() 138 del self.__agent_threads[agent_id] 139 140 def remove_all(self): 141 agent_ids = list(self.__agent_threads.keys()) 142 for agent_id in agent_ids: 143 self.remove(agent_id) . class ThreadSpace(agency.space.Space): View Source 79class ThreadSpace(Space): 80 &quot;&quot;&quot; 81 A Space implementation that uses the threading module. 82 83 This Space type is recommended for testing or simple applications. 84 &quot;&quot;&quot; 85 86 def __init__(self): 87 self.__agent_threads: Dict[str, _AgentThread] = {} 88 router_thread = threading.Thread( 89 target=self.__router_thread, daemon=True) 90 router_thread.start() 91 92 def __router_thread(self): 93 &quot;&quot;&quot; 94 Processes and routes outbound messages for all agents 95 &quot;&quot;&quot; 96 while True: 97 time.sleep(0.001) 98 for agent_thread in list(self.__agent_threads.values()): 99 outbound_queue = agent_thread.outbound_queue 100 try: 101 # process one message per agent per loop 102 message = outbound_queue.get(block=False) 103 self._route(message) 104 except queue.Empty: 105 pass 106 107 def _route(self, message: Message): 108 message = validate_message(message) 109 recipient_threads = [ 110 agent_thread 111 for agent_thread in list(self.__agent_threads.values()) 112 if message[&quot;to&quot;] == agent_thread.agent_id or message[&quot;to&quot;] == &quot;*&quot; 113 ] 114 for recipient_thread in recipient_threads: 115 recipient_thread.inbound_queue.put(message) 116 117 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs): 118 if agent_id in self.__agent_threads.keys(): 119 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 120 121 try: 122 self.__agent_threads[agent_id] = _AgentThread( 123 agent_type=agent_type, 124 agent_id=agent_id, 125 agent_kwargs=agent_kwargs, 126 inbound_queue=queue.Queue(), 127 outbound_queue=queue.Queue(), 128 ) 129 self.__agent_threads[agent_id].start() 130 131 except: 132 # clean up if an error occurs 133 self.remove(agent_id) 134 raise 135 136 def remove(self, agent_id: str): 137 agent_thread = self.__agent_threads[agent_id] 138 agent_thread.stop() 139 del self.__agent_threads[agent_id] 140 141 def remove_all(self): 142 agent_ids = list(self.__agent_threads.keys()) 143 for agent_id in agent_ids: 144 self.remove(agent_id) . A Space implementation that uses the threading module. This Space type is recommended for testing or simple applications. def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, **agent_kwargs): View Source 117 def add(self, agent_type: Type[Agent], agent_id: str, **agent_kwargs): 118 if agent_id in self.__agent_threads.keys(): 119 raise ValueError(f&quot;Agent id already exists: &#39;{agent_id}&#39;&quot;) 120 121 try: 122 self.__agent_threads[agent_id] = _AgentThread( 123 agent_type=agent_type, 124 agent_id=agent_id, 125 agent_kwargs=agent_kwargs, 126 inbound_queue=queue.Queue(), 127 outbound_queue=queue.Queue(), 128 ) 129 self.__agent_threads[agent_id].start() 130 131 except: 132 # clean up if an error occurs 133 self.remove(agent_id) 134 raise . Adds an agent to the space allowing it to communicate. Keyword arguments are passed to the agent's constructor. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 136 def remove(self, agent_id: str): 137 agent_thread = self.__agent_threads[agent_id] 138 agent_thread.stop() 139 del self.__agent_threads[agent_id] . Removes an agent from the space by id. This method cannot remove an agent instance added from a different space instance. In other words, a space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def remove_all(self): View Source 141 def remove_all(self): 142 agent_ids = list(self.__agent_threads.keys()) 143 for agent_id in agent_ids: 144 self.remove(agent_id) . Removes all agents added through this space instance. ",
    "url": "/api_docs/agency/spaces/thread_space.html",
    
    "relUrl": "/api_docs/agency/spaces/thread_space.html"
  },"40": {
    "doc": "agency.spaces.thread_space",
    "title": "agency.spaces.thread_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/thread_space.html",
    
    "relUrl": "/api_docs/agency/spaces/thread_space.html"
  }
}
