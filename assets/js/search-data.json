{"0": {
    "doc": "Agent Callbacks",
    "title": "Agent Callbacks",
    "content": "The following list describes all available agent callbacks, with a link to their API documentation. Please see the API docs for more detailed descriptions of these callbacks. after_add . Called after an agent is added to a space, but before it begins processing messages. before_remove . Called before an agent is removed from a space and will no longer process more messages. handle_action_value . If an action method returns a value, this method will be called with the value. handle_action_error . Receives any error messages from an action invoked by the agent. before_action . Called before an action is attempted. after_action . Called after an action is attempted. request_permission . Called when an agent attempts to perform an action that requires permission. ",
    "url": "/articles/agent_callbacks",
    
    "relUrl": "/articles/agent_callbacks"
  },"1": {
    "doc": "Creating Spaces",
    "title": "Creating Spaces",
    "content": "A Space is where agents may communicate and interact with each other. Agents are instantiated within a space when added. Spaces define the underlying communication transport used for messaging. Agency currently implements two Space types: . | LocalSpace - which connects agents within the same application. | AMQPSpace - which connects agents across a network using an AMQP server. | . ",
    "url": "/articles/creating_spaces",
    
    "relUrl": "/articles/creating_spaces"
  },"2": {
    "doc": "Creating Spaces",
    "title": "Using LocalSpace",
    "content": "LocalSpace is the more basic of the two. It connects agents within the same python application using interprocess communication (IPC). Instantiating a LocalSpace, like other spaces, is as simple as: . space = LocalSpace() space.add(Host, \"Host\") ... The above example would instantiate the Host agent within the LocalSpace instance, allowing any other agents added to the space to communicate with it. ",
    "url": "/articles/creating_spaces#using-localspace",
    
    "relUrl": "/articles/creating_spaces#using-localspace"
  },"3": {
    "doc": "Creating Spaces",
    "title": "Using AMQPSpace",
    "content": "AMQPSpace may be used for building applications that allows agent communication across multiple hosts in a network. To run an AMQPSpace across multiple hosts, you would separate your agents into multiple applications. Each application would be configured to use the same AMQP server. For example, the following would separate the Host agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a host agent to the space space.add(Host, \"Host\") . And the following would separate the ChattyAI agent into its own application: . if __name__ == '__main__': # Create a space space = AMQPSpace() # Add a simple HF based chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") . Then you can run both applications at the same time, and the agents will be able to connect and communicate with each other over AMQP. This approach allows you to scale your agents beyond a single host. See the example application for a full working example. Configuring AMQP Connectivity . By default, the AMQPSpace class will read the following environment variables and will otherwise use default settings. AMQP_HOST AMQP_PORT AMQP_USERNAME AMQP_PASSWORD AMQP_VHOST . You may also customize the options if you provide your own AMQPOptions object when instantiating an AMQPSpace. For example: . space = AMQPSpace( amqp_options=AMQPOptions( hostname=\"localhost\", port=5672, username=\"guest\", password=\"guest\", virtual_host=\"/\", use_ssl=True, heartbeat=60)) . ",
    "url": "/articles/creating_spaces#using-amqpspace",
    
    "relUrl": "/articles/creating_spaces#using-amqpspace"
  },"4": {
    "doc": "Creating Spaces",
    "title": "Instantiating and Destroying Spaces",
    "content": "Space instances manage a number of resources during their lifetime. To destroy a Space, simply call its destroy method. This will clean up all resources used by the space, along with any agents within the space. Spaces also support the context manager syntax for convenience. For example: . with LocalSpace() as space: space.add(Host, \"Host\") ... This form will automatically clean up Space related resources upon exit of the with block. ",
    "url": "/articles/creating_spaces#instantiating-and-destroying-spaces",
    
    "relUrl": "/articles/creating_spaces#instantiating-and-destroying-spaces"
  },"5": {
    "doc": "Defining Actions",
    "title": "Defining Actions",
    "content": "The @action decorator is used to define actions on instance methods of the Agent class, and takes the following keyword arguments: . | name: The name of the action. Defaults to the method name | help: The description of the action. Defaults to an autogenerated object | access_policy: The access policy of the action. Defaults to ACCESS_PERMITTED | . ",
    "url": "/articles/defining_actions",
    
    "relUrl": "/articles/defining_actions"
  },"6": {
    "doc": "Defining Actions",
    "title": "Defining Action Help Information",
    "content": "Below is an example of the help information automatically generated by default from the @action decorator. It uses the docstring of the method, and its signature to generate the default help information. { \"shell_command\": { \"description\": \"Execute a shell command\", \"args\": { \"command\": { \"type\": \"string\" \"description\": \"The command to execute\" } }, \"returns\": { \"type\": \"string\" \"description\": \"The output of the command\" } }, ... } . This help object is supplied to other agents when requesting help. The following example shows how the help information above can be specified from a docstring that follows the Google style guide: . @action def shell_command(self, command: str) -&gt; str: \"\"\" Execute a shell command Args: command (str): The command to execute Returns: str: The output of the command \"\"\" . When generating help information, the action name is determined by the method name. Types are determined by looking at the docstring and the signature, with the signature type hint taking precedence. Action and argument descriptions are parsed from the docstring. Overriding Help Information . The default help data structure described above can be overridden by supplying a custom help object to the @action decorator. @action( help={ \"You\": \"can define\", \"any\": { \"structure\": [\"you\", \"want\", \"here.\"] } } ) def say(self, content: str): . When a custom help object is provided, it overrides the generated object entirely. You can use this to experiment with different help information schemas. ",
    "url": "/articles/defining_actions#defining-action-help-information",
    
    "relUrl": "/articles/defining_actions#defining-action-help-information"
  },"7": {
    "doc": "Defining Actions",
    "title": "Access Policies",
    "content": "❗️Access control is experimental. Please share your feedback. Access policies may be used to control when actions can be invoked by agents. All actions may declare an access policy like the following example: . @action(access_policy=ACCESS_PERMITTED) def my_action(self): ... An access policy can currently be one of three values: . | ACCESS_PERMITTED - (Default) Permits any agent to use that action at any time. | ACCESS_DENIED - Prevents access to that action. | ACCESS_REQUESTED - Prompts the receiving agent for permission when access is attempted. Access will await approval or denial. | . If ACCESS_REQUESTED is used, the receiving agent will be prompted to approve the action via the request_permission() callback method. If any actions declare a policy of ACCESS_REQUESTED, you must implement the request_permission() method with the following signature in order to receive permission requests. def request_permission(self, proposed_message: dict) -&gt; bool: ... Your implementation should inspect proposed_message and return a boolean indicating whether or not to permit the action. You can use this approach to protect against dangerous actions being taken. For example if you allow terminal access, you may want to review commands before they are invoked. ",
    "url": "/articles/defining_actions#access-policies",
    
    "relUrl": "/articles/defining_actions#access-policies"
  },"8": {
    "doc": "Messaging",
    "title": "Messaging",
    "content": "The following details cover the message schema and other messaging behavior. ",
    "url": "/articles/messaging",
    
    "relUrl": "/articles/messaging"
  },"9": {
    "doc": "Messaging",
    "title": "Message Schema",
    "content": "All messages are validated upon sending and must conform to the message schema. Note that when sending, you normally do not supply the entire structure. The meta.id, meta.parent_id, and from fields are automatically populated for you. The full message schema is summarized by this example: . { \"meta\": { \"id\": \"a string to identify the message\", \"parent_id\": \"meta.id of the parent message, if any\", \"anything\": \"else here\", }, \"from\": \"TheSender\", # The following fields must be specified when sending \"to\": \"TheReceiver\", \"action\": { \"name\": \"the_action_name\", \"args\": { \"the\": \"args\", } } } . An example of calling Agent.send() with only the minimum fields would look like: . self.send({ \"to\": \"some_agent\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } }) . See agency/schema.py for the pydantic model definition used for validation. ",
    "url": "/articles/messaging#message-schema",
    
    "relUrl": "/articles/messaging#message-schema"
  },"10": {
    "doc": "Messaging",
    "title": "The to and from Fields",
    "content": "The to and from fields are used for addressing messages. All messages require the to field to be specified. The to field should be the id of an agent in the space (point-to-point) or the special id * for a broadcast (see below). The from field is automatically populated for you when sending. ",
    "url": "/articles/messaging#the-to-and-from-fields",
    
    "relUrl": "/articles/messaging#the-to-and-from-fields"
  },"11": {
    "doc": "Messaging",
    "title": "The action Field",
    "content": "The action field contains the body of the action invocation. It carries the action name and the arguments to pass as a dictionary object called args. ",
    "url": "/articles/messaging#the-action-field",
    
    "relUrl": "/articles/messaging#the-action-field"
  },"12": {
    "doc": "Messaging",
    "title": "The meta Field",
    "content": "The meta field may be used to store arbitrary key-value metadata about the message. It is optional to define, though the meta.id and meta.parent_id fields will be populated automatically by default. Example uses of the meta field include: . | Storing “thoughts” associated with an action. This is a common pattern used with LLM agents. For example, an LLM agent may send the following message: { \"meta\": { \"thoughts\": \"I should say hello to everyone\", }, \"to\": \"*\", \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello, world!\" } } } . | Storing timestamps associated with an action. For example: { \"meta\": { \"timestamp\": 12345, }, ... } . | . ",
    "url": "/articles/messaging#the-meta-field",
    
    "relUrl": "/articles/messaging#the-meta-field"
  },"13": {
    "doc": "Messaging",
    "title": "Broadcasting Messages",
    "content": "Sending a message to the special id * will broadcast the message to all agents in the space. By default, agents receive their own broadcasts, but you may change this behavior with the receive_own_broadcasts argument when creating the agent. For example: . my_agent = MyAgent(\"MyAgent\", receive_own_broadcasts=False) . ",
    "url": "/articles/messaging#broadcasting-messages",
    
    "relUrl": "/articles/messaging#broadcasting-messages"
  },"14": {
    "doc": "Messaging",
    "title": "Messaging to Non-Existent Agents or Actions",
    "content": "If you send a message to a non-existent agent id, it will silently fail. This is in line with the actor model. If you send a message to an existent agent, but specify a non-existent action, you will receive an error response which you may handle in the handle_action_error callback. If you send a broadcast that specifies a non-existent action on some agents, those agents will silently ignore the error. ",
    "url": "/articles/messaging#messaging-to-non-existent-agents-or-actions",
    
    "relUrl": "/articles/messaging#messaging-to-non-existent-agents-or-actions"
  },"15": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Responses and Synchronous Messaging",
    "content": "Messages sent using Agent.send() are sent asynchronously. This is in line with the expectations in an actor model. Often though, we’d like to send a message to an agent and receive an associated response. Agents have multiple options for doing this. ",
    "url": "/articles/responses",
    
    "relUrl": "/articles/responses"
  },"16": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Replying to Messages",
    "content": "The most basic response can be achieved simply using Agent.send() along with Agent.current_message(). For example: . class MyAgent(Agent): @action def say(self, content: str): ... self.send({ \"to\": self.current_message()[\"from\"], # reply to the sender \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello!\" } } }) . The above will send the say action back to the original sender. ",
    "url": "/articles/responses#replying-to-messages",
    
    "relUrl": "/articles/responses#replying-to-messages"
  },"17": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Using Agent.respond_with for Value Responses",
    "content": "Often it’s useful to send a value back to the sender of a message, similar to a return value from a function. In these cases, Agent.respond_with may be used. Take the following two simple agents as an example. class MyAgent(Agent): @action def ping(self): self.respond_with(\"pong\") class SenderAgent(Agent): ... def handle_action_value(self, value): print(value) . When an instance of SenderAgent sends a ping action to MyAgent, the handle_action_value callback on SenderAgent will be invoked with the value \"pong\". Note that respond_with() may be called multiple times in a single action. Each call will invoke the handle_action_value callback on the sender. ",
    "url": "/articles/responses#using-agentrespond_with-for-value-responses",
    
    "relUrl": "/articles/responses#using-agentrespond_with-for-value-responses"
  },"18": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Using Agent.raise_with for Error Responses",
    "content": "Similar to Agent.respond_with, Agent.raise_with may be used to send an exception back to the sender of a message. For example: . class MyAgent(Agent): @action def ping(self): self.raise_with(Exception(\"oops\")) class SenderAgent(Agent): ... def handle_action_error(self, error: ActionError): print(error.message) . In this example, an instance of SenderAgent sends a ping action to MyAgent. The handle_action_error callback on MyAgent will be invoked with the exception ActionError(\"Exception: oops\"). Similar to respond_with, raise_with may be called multiple times in a single action. Each call will invoke the handle_action_error callback on the sender. Note that when an action raises an exception, raise_with will be automatically invoked for you, sending the exception back to the sender. ",
    "url": "/articles/responses#using-agentraise_with-for-error-responses",
    
    "relUrl": "/articles/responses#using-agentraise_with-for-error-responses"
  },"19": {
    "doc": "Responses and Synchronous Messaging",
    "title": "Using Agent.request() for Synchronous Messaging",
    "content": "The Agent.request() method is a synchronous version of the send() method that allows you to call an action and receive its return value or exception synchronously without using the handle_action_* callbacks. If the action responds with an error, an ActionError will be raised containing the original error message. Here’s an example of how you might use request(): . try: return_value = self.request({ \"to\": \"ExampleAgent\", \"action\": { \"name\": \"example_action\", \"args\": { \"content\": \"hello\" } } }, timeout=5) except ActionError as e: print(e.message) . Note that request() may not be called within the after_add() and before_remove() callbacks, but may be used within actions or other callbacks. Also notice the timeout value. The default is 3 seconds. Make sure to increase this appropriately for longer running requests. ",
    "url": "/articles/responses#using-agentrequest-for-synchronous-messaging",
    
    "relUrl": "/articles/responses#using-agentrequest-for-synchronous-messaging"
  },"20": {
    "doc": "Example Application Walkthrough",
    "title": "Example Application Walkthrough",
    "content": "The following walkthrough will guide you through the basic concepts of Agency’s API, and how to use it to build a simple agent system. In this walkthrough, we’ll be using the LocalSpace class for connecting agents. Usage is exactly the same as with AMQPSpace. The Space type used determines the communication implementation used for the space. ",
    "url": "/articles/walkthrough",
    
    "relUrl": "/articles/walkthrough"
  },"21": {
    "doc": "Example Application Walkthrough",
    "title": "Creating a Space and adding Agents",
    "content": "The following snippet, adapted from the demo application, shows how to instantiate a space and add several agents to it. The application includes OpenAIFunctionAgent which uses the OpenAI API, a local LLM chat agent named ChattyAI, the Host agent which allows access to the host system, and a Gradio based chat application which allows its user to communicate within the space as an agent as well. # Create the space instance space = LocalSpace() # Add a Host agent to the space, exposing access to the host system space.add(Host, \"Host\") # Add a local chat agent to the space space.add(ChattyAI, \"Chatty\", model=\"EleutherAI/gpt-neo-125m\") # Add an OpenAI function API agent to the space space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the OpenAI chat API user_id=\"User\") # Connect the Gradio user to the space gradio_user = space.add_foreground(GradioUser, \"User\") # Launch the gradio UI allowing the user to communicate gradio_user.demo().launch() . Let’s break this example down step by step. ",
    "url": "/articles/walkthrough#creating-a-space-and-adding-agents",
    
    "relUrl": "/articles/walkthrough#creating-a-space-and-adding-agents"
  },"22": {
    "doc": "Example Application Walkthrough",
    "title": "Agent ids",
    "content": "Notice first that each agent is given a string id like \"Host\" or \"Chatty\". An agent’s id is used to uniquely identify the agent within the space. Other agents may send messages to Chatty or Host by using their id’s, as we’ll see later. ",
    "url": "/articles/walkthrough#agent-ids",
    
    "relUrl": "/articles/walkthrough#agent-ids"
  },"23": {
    "doc": "Example Application Walkthrough",
    "title": "Defining an Agent and its Actions",
    "content": "To define an Agent type like ChattyAI, simply extend the Agent class. For example: . class ChattyAI(Agent): ... Actions are publicly available methods that agents expose within a space, and may be invoked by other agents. To define actions, you simply define instance methods on the Agent class, and use the @action decorator. For example the following defines an action called say that takes a single string argument content. @action def say(self, content: str): \"\"\"Use this action to say something to Chatty\"\"\" ... Other agents may invoke this action by sending a message to Chatty as we’ll see below. ",
    "url": "/articles/walkthrough#defining-an-agent-and-its-actions",
    
    "relUrl": "/articles/walkthrough#defining-an-agent-and-its-actions"
  },"24": {
    "doc": "Example Application Walkthrough",
    "title": "Invoking Actions",
    "content": "When agents are added to a space, they may send messages to other agents to invoke their actions. An example of invoking an action can be seen here, taken from the ChattyAI.say() implementation... self.send({ \"to\": self.current_message()['from'], # reply to the sender \"action\": { \"name\": \"say\", \"args\": { \"content\": \"Hello from Chatty!\", } } }) . This demonstrates the basic idea of how to send a message to invoke an action on another agent. When an agent receives a message, it invokes the actions method, passing action.args as keyword arguments to the method. So here, Chatty is invoking the say action on the sender of the current message that they received. This simple approach allows the original sender and Chatty to have a conversation using only the say action. Note the use of current_message(). That method may be used during an action to inspect the entire message which invoked the current action. ",
    "url": "/articles/walkthrough#invoking-actions",
    
    "relUrl": "/articles/walkthrough#invoking-actions"
  },"25": {
    "doc": "Example Application Walkthrough",
    "title": "Discovering Agents and their Actions",
    "content": "At this point, we can demonstrate how agent and action discovery works from the perspective of an agent. All agents implement a help action, which returns a dictionary of their available actions for other agents to discover. To request help information, an agent may send something like the following: . self.send({ \"to\": \"Chatty\" \"action\": { \"name\": \"help\" } }) . \"Chatty\" will respond by returning a message with a dictionary of available actions. For example, if \"Chatty\" implements a single say action as shown above, it will respond with: . { \"say\": { \"description\": \"Use this action to say something to Chatty\", \"args\": { \"content\": { \"type\": \"string\", \"description\": \"What to say to Chatty\" }, }, } } . This is how agents may discover available actions on other agents. Broadcasting help . But how does an agent know which agents are present in the space? . To discover all agents in the space, an agent can broadcast a message using the special id *. For example: . self.send({ \"to\": \"*\", \"action\": { \"name\": \"help\", } }) . The above will broadcast the help message to all agents in the space, who will individually respond with their available actions. This way, an agent may discover all the agents in the space and their actions. To request help on a specific action, you may supply the action name as an argument: . self.send({ \"to\": \"*\", \"action\": { \"name\": \"help\", \"args\": { \"action_name\": \"say\" } } }) . The above will broadcast the help action, requesting help specifically on the say action. Note that broadcasts may be used for other messages as well. See the messaging article for more details. ",
    "url": "/articles/walkthrough#discovering-agents-and-their-actions",
    
    "relUrl": "/articles/walkthrough#discovering-agents-and-their-actions"
  },"26": {
    "doc": "Example Application Walkthrough",
    "title": "Adding an Intelligent Agent",
    "content": "Now that we understand how agents communicate and discover each other, let’s add an intelligent agent to the space which can use these abilities. To add the OpenAIFunctionAgent to the space: . space.add(OpenAIFunctionAgent, \"FunctionAI\", model=\"gpt-3.5-turbo-16k\", openai_api_key=os.getenv(\"OPENAI_API_KEY\"), # user_id determines the \"user\" role in the chat API user_id=\"User\") . If you inspect the implementation of OpenAIFunctionAgent, you’ll see that this agent uses the after_add callback to immediately request help information from the other agents in the space when added. It later uses that information to provide a list of functions to the OpenAI function calling API, allowing the LLM to see agent actions as functions it may invoke. In this way, the OpenAIFunctionAgent can discover other agents in the space and interact with them intelligently as needed. ",
    "url": "/articles/walkthrough#adding-an-intelligent-agent",
    
    "relUrl": "/articles/walkthrough#adding-an-intelligent-agent"
  },"27": {
    "doc": "Example Application Walkthrough",
    "title": "Adding a User Interface",
    "content": "There are two general approaches you might follow to implement a user-facing application which interacts with a space: . | You may represent the user-facing application as an individual agent, having it act as a “liason” between the user and the space. User intentions can be mapped to actions that the “liason” agent can invoke on behalf of the user. In this approach, users would not need to know the details of the underlying communication. | Individual human users may be represented as individual agents in a space. This approach allows your application to provide direct interaction with agents by users and has the benefit of allowing actions to be invoked directly, enabling more powerful interactive possibilities. This is the approach taken in the demo application. For example, the demo UI (currently implemented in Gradio) allows users to directly invoke actions via a “slash” syntax similar to the following: . /Chatty.say content:\"Hello\" . This allows the user to work hand-in-hand with intelligent agents, and is one of the driving visions behind Agency’s design. See the demo application for a full working example of this approach. | . ",
    "url": "/articles/walkthrough#adding-a-user-interface",
    
    "relUrl": "/articles/walkthrough#adding-a-user-interface"
  },"28": {
    "doc": "Example Application Walkthrough",
    "title": "Next Steps",
    "content": "This concludes the example walkthrough. To try out the working demo, please jump to the examples/demo directory. ",
    "url": "/articles/walkthrough#next-steps",
    
    "relUrl": "/articles/walkthrough#next-steps"
  },"29": {
    "doc": "agency",
    "title": "\nagency    ",
    "content": "View Source 1import multiprocessing 2 3multiprocessing.set_start_method(&#39;spawn&#39;, force=True) . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"30": {
    "doc": "agency",
    "title": "Submodules",
    "content": ". | agent | logger | processor | queue | resources | schema | space | spaces | . ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"31": {
    "doc": "agency",
    "title": "agency",
    "content": " ",
    "url": "/api_docs/agency.html",
    
    "relUrl": "/api_docs/agency.html"
  },"32": {
    "doc": "agency.agent",
    "title": "\nagency.agent    ",
    "content": "View Source 1import inspect 2import re 3import threading 4import uuid 5from typing import Dict, List, Union 6 7from docstring_parser import DocstringStyle, parse 8 9from agency.logger import log 10from agency.queue import Queue 11from agency.resources import ResourceManager 12from agency.schema import Message 13 14 15def _python_to_json_type_name(python_type_name: str) -&gt; str: 16 return { 17 &#39;str&#39;: &#39;string&#39;, 18 &#39;int&#39;: &#39;number&#39;, 19 &#39;float&#39;: &#39;number&#39;, 20 &#39;bool&#39;: &#39;boolean&#39;, 21 &#39;list&#39;: &#39;array&#39;, 22 &#39;dict&#39;: &#39;object&#39; 23 }[python_type_name] 24 25 26def _generate_help(method: callable) -&gt; dict: 27 &quot;&quot;&quot; 28 Generates a help object from a method&#39;s docstring and signature 29 30 Args: 31 method: the method 32 33 Returns: 34 A help object of the form: 35 36 { 37 &quot;description&quot;: &lt;description&gt;, 38 &quot;args&quot;: { 39 &quot;arg_name&quot;: { 40 &quot;type&quot;: &lt;type&gt;, 41 &quot;description&quot;: &lt;description&gt; 42 }, 43 } 44 &quot;returns&quot;: { 45 &quot;type&quot;: &lt;type&gt;, 46 &quot;description&quot;: &lt;description&gt; 47 } 48 } 49 &quot;&quot;&quot; 50 signature = inspect.signature(method) 51 parsed_docstring = parse(method.__doc__, DocstringStyle.GOOGLE) 52 53 help_object = {} 54 55 # description 56 if parsed_docstring.short_description is not None: 57 description = parsed_docstring.short_description 58 if parsed_docstring.long_description is not None: 59 description += &quot; &quot; + parsed_docstring.long_description 60 help_object[&quot;description&quot;] = re.sub(r&quot;\\s+&quot;, &quot; &quot;, description).strip() 61 62 # args 63 help_object[&quot;args&quot;] = {} 64 docstring_args = {arg.arg_name: arg for arg in parsed_docstring.params} 65 arg_names = list(signature.parameters.keys())[1:] # skip &#39;self&#39; argument 66 for arg_name in arg_names: 67 arg_object = {} 68 69 # type 70 sig_annotation = signature.parameters[arg_name].annotation 71 if sig_annotation is not None and sig_annotation.__name__ != &quot;_empty&quot;: 72 arg_object[&quot;type&quot;] = _python_to_json_type_name( 73 signature.parameters[arg_name].annotation.__name__) 74 elif arg_name in docstring_args and docstring_args[arg_name].type_name is not None: 75 arg_object[&quot;type&quot;] = _python_to_json_type_name( 76 docstring_args[arg_name].type_name) 77 78 # description 79 if arg_name in docstring_args and docstring_args[arg_name].description is not None: 80 arg_object[&quot;description&quot;] = docstring_args[arg_name].description.strip() 81 82 help_object[&quot;args&quot;][arg_name] = arg_object 83 84 # returns 85 if parsed_docstring.returns is not None: 86 help_object[&quot;returns&quot;] = {} 87 88 # type 89 if signature.return_annotation is not None: 90 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 91 signature.return_annotation.__name__) 92 elif parsed_docstring.returns.type_name is not None: 93 help_object[&quot;returns&quot;][&quot;type&quot;] = _python_to_json_type_name( 94 parsed_docstring.returns.type_name) 95 96 # description 97 if parsed_docstring.returns.description is not None: 98 help_object[&quot;returns&quot;][&quot;description&quot;] = parsed_docstring.returns.description.strip() 99 100 return help_object 101 102 103# Special action names 104_RESPONSE_ACTION_NAME = &quot;[response]&quot; 105_ERROR_ACTION_NAME = &quot;[error]&quot; 106 107 108# Access policies 109ACCESS_PERMITTED = &quot;ACCESS_PERMITTED&quot; 110ACCESS_DENIED = &quot;ACCESS_DENIED&quot; 111ACCESS_REQUESTED = &quot;ACCESS_REQUESTED&quot; 112 113 114def action(*args, **kwargs): 115 &quot;&quot;&quot; 116 Declares instance methods as actions making them accessible to other agents. 117 118 Keyword arguments: 119 name: The name of the action. Defaults to the name of the method. 120 help: The help object. Defaults to a generated object. 121 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 122 &quot;&quot;&quot; 123 def decorator(method): 124 action_name = kwargs.get(&quot;name&quot;, method.__name__) 125 if action_name == _RESPONSE_ACTION_NAME: 126 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 127 method.action_properties: dict = { 128 &quot;name&quot;: method.__name__, 129 &quot;help&quot;: _generate_help(method), 130 &quot;access_policy&quot;: ACCESS_PERMITTED, 131 **kwargs, 132 } 133 return method 134 135 if len(args) == 1 and callable(args[0]) and not kwargs: 136 return decorator(args[0]) # The decorator was used without parentheses 137 else: 138 return decorator # The decorator was used with parentheses 139 140 141class ActionError(Exception): 142 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; 143 144 145class Agent(): 146 &quot;&quot;&quot; 147 An Actor that may represent an AI agent, software interface, or human user 148 &quot;&quot;&quot; 149 150 def __init__(self, id: str, receive_own_broadcasts: bool = True): 151 &quot;&quot;&quot; 152 Initializes an Agent. 153 154 This constructor is not meant to be called directly. It is invoked by 155 the Space class when adding an agent. 156 157 Subclasses should call super().__init__() in their constructor. 158 159 Args: 160 id: The id of the agent 161 receive_own_broadcasts: 162 Whether the agent will receive its own broadcasts. Defaults to 163 True 164 &quot;&quot;&quot; 165 if len(id) &lt; 1 or len(id) &gt; 255: 166 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 167 if re.match(r&quot;^amq\\.&quot;, id): 168 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 169 if id == &quot;*&quot;: 170 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 171 self._id: str = id 172 self._receive_own_broadcasts: bool = receive_own_broadcasts 173 # --- non-constructor properties set by Space/Processor --- 174 self._outbound_queue: Queue = None 175 self._is_processing: bool = False 176 # --- non-constructor properties --- 177 self._message_log: List[Message] = [] 178 self._message_log_lock: threading.Lock = threading.Lock() 179 self._pending_requests: Dict[str, Union[threading.Event, Message]] = {} 180 self._pending_requests_lock: threading.Lock = threading.Lock() 181 self.__thread_local_current_message = threading.local() 182 self.__thread_local_current_message.value: Message = None 183 184 def id(self) -&gt; str: 185 return self._id 186 187 def send(self, message: dict) -&gt; str: 188 &quot;&quot;&quot; 189 Sends (out) a message from this agent. 190 191 Args: 192 message: The message 193 194 Returns: 195 The meta.id of the sent message 196 197 Raises: 198 TypeError: If the message is not a dict 199 ValueError: If the message is invalid 200 &quot;&quot;&quot; 201 if not isinstance(message, dict): 202 raise TypeError(&quot;message must be a dict&quot;) 203 if &quot;from&quot; in message and message[&quot;from&quot;] != self.id(): 204 raise ValueError( 205 f&quot;&#39;from&#39; field value &#39;{message[&#39;from&#39;]}&#39; does not match this agent&#39;s id.&quot;) 206 message[&quot;from&quot;] = self.id() 207 message[&quot;meta&quot;] = { 208 &quot;id&quot;: uuid.uuid4().__str__(), 209 **message.get(&quot;meta&quot;, {}), 210 } 211 message = Message(**message).dict(by_alias=True, exclude_unset=True) 212 with self._message_log_lock: 213 log(&quot;info&quot;, f&quot;{self._id}: sending&quot;, message) 214 self._message_log.append(message) 215 self._outbound_queue.put(message) 216 return message[&quot;meta&quot;][&quot;id&quot;] 217 218 def request(self, message: dict, timeout: float = 3) -&gt; object: 219 &quot;&quot;&quot; 220 Synchronously sends a message then waits for and returns the return 221 value of the invoked action. 222 223 This method allows you to call an action synchronously like a function 224 and receive its return value in python. If the action raises an 225 exception an ActionError will be raised containing the error message. 226 227 Args: 228 message: The message to send 229 timeout: 230 The timeout in seconds to wait for the returned value. 231 Defaults to 3 seconds. 232 233 Returns: 234 object: The return value of the action. 235 236 Raises: 237 TimeoutError: If the timeout is reached 238 ActionError: If the action raised an exception 239 RuntimeError: 240 If called before the agent is processing incoming messages 241 &quot;&quot;&quot; 242 if not self._is_processing: 243 raise RuntimeError( 244 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 245 246 # Send and mark the request as pending 247 with self._pending_requests_lock: 248 request_id = self.send(message) 249 self._pending_requests[request_id] = threading.Event() 250 251 # Wait for response 252 if not self._pending_requests[request_id].wait(timeout=timeout): 253 raise TimeoutError 254 255 with self._pending_requests_lock: 256 response_message = self._pending_requests.pop(request_id) 257 258 # Raise error or return value from response 259 if response_message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 260 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 261 262 if response_message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 263 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 264 265 raise RuntimeError(&quot;We should never get here&quot;) 266 267 def respond_with(self, value): 268 &quot;&quot;&quot; 269 Sends a response with the given value. 270 271 Parameters: 272 value (any): The value to be sent in the response message. 273 &quot;&quot;&quot; 274 self.send({ 275 &quot;meta&quot;: { 276 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;] 277 }, 278 &quot;to&quot;: self.current_message()[&#39;from&#39;], 279 &quot;action&quot;: { 280 &quot;name&quot;: _RESPONSE_ACTION_NAME, 281 &quot;args&quot;: { 282 &quot;value&quot;: value, 283 } 284 } 285 }) 286 287 def raise_with(self, error: Exception): 288 &quot;&quot;&quot; 289 Sends an error response. 290 291 Args: 292 error (Exception): The error to send. 293 &quot;&quot;&quot; 294 self.send({ 295 &quot;meta&quot;: { 296 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;], 297 }, 298 &quot;to&quot;: self.current_message()[&#39;from&#39;], 299 &quot;action&quot;: { 300 &quot;name&quot;: _ERROR_ACTION_NAME, 301 &quot;args&quot;: { 302 &quot;error&quot;: f&quot;{error.__class__.__name__}: {error}&quot; 303 } 304 } 305 }) 306 307 def _receive(self, message: dict): 308 &quot;&quot;&quot; 309 Receives and handles an incoming message. 310 311 Args: 312 message: The incoming message 313 &quot;&quot;&quot; 314 try: 315 # Ignore own broadcasts if _receive_own_broadcasts is false 316 if not self._receive_own_broadcasts \\ 317 and message[&#39;from&#39;] == self.id() \\ 318 and message[&#39;to&#39;] == &#39;*&#39;: 319 return 320 321 log(&quot;debug&quot;, f&quot;{self.id()}: received message&quot;, message) 322 323 # Record the received message before handling 324 with self._message_log_lock: 325 self._message_log.append(message) 326 327 # Handle incoming responses 328 # TODO: make serial/fan-out optional 329 if message[&quot;action&quot;][&quot;name&quot;] in [_RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME]: 330 parent_id = message[&quot;meta&quot;][&quot;parent_id&quot;] 331 if parent_id in self._pending_requests.keys(): 332 # This was a response to a request(). We use a little trick 333 # here and simply swap out the event that is waiting with 334 # the message, then set the event. The request() method will 335 # pick up the response message in the existing thread. 336 event = self._pending_requests[parent_id] 337 self._pending_requests[parent_id] = message 338 event.set() 339 else: 340 # This was a response to a send() 341 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 342 handler_callback = self.handle_action_value 343 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 344 elif message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 345 handler_callback = self.handle_action_error 346 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 347 else: 348 raise RuntimeError(&quot;Unknown action response&quot;) 349 350 # Spawn a thread to handle the response 351 def __process_response(arg, current_message): 352 threading.current_thread( 353 ).name = f&quot;{self.id()}: __process_response {current_message[&#39;meta&#39;][&#39;id&#39;]}&quot; 354 self.__thread_local_current_message.value = current_message 355 handler_callback(arg) 356 357 ResourceManager().thread_pool_executor.submit( 358 __process_response, 359 arg, 360 message, 361 ) 362 363 # Handle all other messages 364 else: 365 # Spawn a thread to process the message. This means that messages 366 # are processed concurrently, but may be processed out of order. 367 ResourceManager().thread_pool_executor.submit( 368 self.__process, 369 message, 370 ) 371 except Exception as e: 372 log(&quot;error&quot;, f&quot;{self.id()}: raised exception in _receive&quot;, e) 373 374 def __process(self, message: dict): 375 &quot;&quot;&quot; 376 Top level method within the action processing thread. 377 &quot;&quot;&quot; 378 threading.current_thread( 379 ).name = f&quot;{self.id()}: __process {message[&#39;meta&#39;][&#39;id&#39;]}&quot; 380 self.__thread_local_current_message.value = message 381 try: 382 log(&quot;debug&quot;, f&quot;{self.id()}: committing action&quot;, message) 383 self.__commit(message) 384 except Exception as e: 385 # Handle errors (including PermissionError) that occur while 386 # committing an action by reporting back to the sender. 387 log(&quot;warning&quot;, 388 f&quot;{self.id()}: raised exception while committing action &#39;{message[&#39;action&#39;][&#39;name&#39;]}&#39;&quot;, e) 389 self.raise_with(e) 390 391 def __commit(self, message: dict): 392 &quot;&quot;&quot; 393 Invokes the action method 394 395 Args: 396 message: The incoming message specifying the action 397 398 Raises: 399 AttributeError: If the action method is not found 400 PermissionError: If the action is not permitted 401 &quot;&quot;&quot; 402 try: 403 # Check if the action method exists 404 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 405 except KeyError: 406 # the action was not found 407 if message[&#39;to&#39;] == &#39;*&#39;: 408 return # broadcasts will not raise an error in this situation 409 else: 410 raise AttributeError( 411 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 412 413 # Check if the action is permitted 414 if not self.__permitted(message): 415 raise PermissionError( 416 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 417 418 self.before_action(message) 419 420 return_value = None 421 error = None 422 try: 423 # Invoke the action method 424 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 425 except Exception as e: 426 error = e 427 raise 428 finally: 429 self.after_action(message, return_value, error) 430 return return_value 431 432 def __permitted(self, message: dict) -&gt; bool: 433 &quot;&quot;&quot; 434 Checks whether the message&#39;s action is allowed 435 &quot;&quot;&quot; 436 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 437 policy = action_method.action_properties[&quot;access_policy&quot;] 438 if policy == ACCESS_PERMITTED: 439 return True 440 elif policy == ACCESS_DENIED: 441 return False 442 elif policy == ACCESS_REQUESTED: 443 return self.request_permission(message) 444 else: 445 raise Exception( 446 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 447 448 def __action_methods(self) -&gt; dict: 449 instance_methods = inspect.getmembers(self, inspect.ismethod) 450 action_methods = { 451 method_name: method 452 for method_name, method in instance_methods 453 if hasattr(method, &quot;action_properties&quot;) 454 } 455 return action_methods 456 457 def __action_method(self, action_name: str): 458 &quot;&quot;&quot; 459 Returns the method for the given action name. 460 &quot;&quot;&quot; 461 action_methods = self.__action_methods() 462 return action_methods[action_name] 463 464 def _find_message(self, message_id: str) -&gt; Message: 465 &quot;&quot;&quot; 466 Returns a message from the log with the given ID. 467 468 Args: 469 message_id: The ID of the message 470 471 Returns: 472 The message or None if not found 473 &quot;&quot;&quot; 474 for message in self._message_log: 475 if message[&quot;meta&quot;][&quot;id&quot;] == message_id: 476 return message 477 478 def current_message(self) -&gt; Message: 479 &quot;&quot;&quot; 480 Returns the full incoming message which invoked the current action. 481 482 This method may be called within an action or action related callback to 483 retrieve the current message, for example to determine the sender or 484 inspect other details. 485 486 Returns: 487 The current message 488 &quot;&quot;&quot; 489 return self.__thread_local_current_message.value 490 491 def parent_message(self, message: Message = None) -&gt; Message: 492 &quot;&quot;&quot; 493 Returns the message that the given message is responding to, if any. 494 495 This method may be used within the handle_action_value and 496 handle_action_error callbacks. 497 498 Args: 499 message: The message to get the parent message of. Defaults to the 500 current message. 501 502 Returns: 503 The parent message or None 504 &quot;&quot;&quot; 505 if message is None: 506 message = self.current_message() 507 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 508 if parent_id is not None: 509 return self._find_message(parent_id) 510 511 @action 512 def help(self, action_name: str = None) -&gt; dict: 513 &quot;&quot;&quot; 514 Returns a list of actions on this agent. 515 516 If action_name is passed, returns a list with only that action. 517 If no action_name is passed, returns all actions. 518 519 Args: 520 action_name: (Optional) The name of an action to request help for 521 522 Returns: 523 A dictionary of actions 524 &quot;&quot;&quot; 525 self.respond_with(self._help(action_name)) 526 527 def _help(self, action_name: str = None) -&gt; dict: 528 &quot;&quot;&quot; 529 Generates the help information returned by the help() action 530 &quot;&quot;&quot; 531 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME] 532 help_list = { 533 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 534 for method in self.__action_methods().values() 535 if action_name is None 536 and method.action_properties[&quot;name&quot;] not in special_actions 537 or method.action_properties[&quot;name&quot;] == action_name 538 } 539 return help_list 540 541 def handle_action_value(self, value): 542 &quot;&quot;&quot; 543 Receives a return value from a previous action. 544 545 This method receives return values from actions invoked by the send() 546 method. It is not called when using the request() method, which returns 547 the value directly. 548 549 To inspect the full response message carrying this value, use 550 current_message(). To inspect the message which returned the value, use 551 parent_message(). 552 553 Args: 554 value: 555 The return value 556 &quot;&quot;&quot; 557 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 558 self._issued_handle_action_value_warning = True 559 log(&quot;warning&quot;, 560 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 561 562 def handle_action_error(self, error: ActionError): 563 &quot;&quot;&quot; 564 Receives an error from a previous action. 565 566 This method receives errors from actions invoked by the send() method. 567 It is not called when using the request() method, which raises an error 568 directly. 569 570 To inspect the full response message carrying this error, use 571 current_message(). To inspect the message which caused the error, use 572 parent_message(). 573 574 Args: 575 error: The error 576 &quot;&quot;&quot; 577 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 578 self._issued_handle_action_error_warning = True 579 log(&quot;warning&quot;, 580 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 581 582 def after_add(self): 583 &quot;&quot;&quot; 584 Called after the agent is added to a space, but before it begins 585 processing incoming messages. 586 587 The agent may send messages during this callback using the send() 588 method, but may not use the request() method since it relies on 589 processing incoming messages. 590 &quot;&quot;&quot; 591 592 def before_remove(self): 593 &quot;&quot;&quot; 594 Called before the agent is removed from a space, after it has finished 595 processing incoming messages. 596 597 The agent may send final messages during this callback using the send() 598 method, but may not use the request() method since it relies on 599 processing incoming messages. 600 &quot;&quot;&quot; 601 602 def before_action(self, message: dict): 603 &quot;&quot;&quot; 604 Called before every action. 605 606 This method will only be called if the action exists and is permitted. 607 608 Args: 609 message: The received message that contains the action 610 &quot;&quot;&quot; 611 612 def after_action(self, message: dict, return_value: str, error: str): 613 &quot;&quot;&quot; 614 Called after every action, regardless of whether an error occurred. 615 616 Args: 617 message: The message which invoked the action 618 return_value: The return value from the action 619 error: The error from the action if any 620 &quot;&quot;&quot; 621 622 def request_permission(self, proposed_message: dict) -&gt; bool: 623 &quot;&quot;&quot; 624 Receives a proposed action message and presents it to the agent for 625 review. 626 627 Args: 628 proposed_message: The proposed action message 629 630 Returns: 631 True if access should be permitted 632 &quot;&quot;&quot; 633 raise NotImplementedError( 634 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . ACCESS_PERMITTED = &#39;ACCESS_PERMITTED&#39; ACCESS_DENIED = &#39;ACCESS_DENIED&#39; ACCESS_REQUESTED = &#39;ACCESS_REQUESTED&#39; def action(*args, **kwargs): View Source 115def action(*args, **kwargs): 116 &quot;&quot;&quot; 117 Declares instance methods as actions making them accessible to other agents. 118 119 Keyword arguments: 120 name: The name of the action. Defaults to the name of the method. 121 help: The help object. Defaults to a generated object. 122 access_policy: The access policy. Defaults to ACCESS_PERMITTED. 123 &quot;&quot;&quot; 124 def decorator(method): 125 action_name = kwargs.get(&quot;name&quot;, method.__name__) 126 if action_name == _RESPONSE_ACTION_NAME: 127 raise ValueError(f&quot;action name &#39;{action_name}&#39; is reserved&quot;) 128 method.action_properties: dict = { 129 &quot;name&quot;: method.__name__, 130 &quot;help&quot;: _generate_help(method), 131 &quot;access_policy&quot;: ACCESS_PERMITTED, 132 **kwargs, 133 } 134 return method 135 136 if len(args) == 1 and callable(args[0]) and not kwargs: 137 return decorator(args[0]) # The decorator was used without parentheses 138 else: 139 return decorator # The decorator was used with parentheses . Declares instance methods as actions making them accessible to other agents. Keyword arguments: . name: The name of the action. Defaults to the name of the method. help: The help object. Defaults to a generated object. access_policy: The access policy. Defaults to ACCESS_PERMITTED. class ActionError(builtins.Exception): View Source 142class ActionError(Exception): 143 &quot;&quot;&quot;Raised from the request() method if the action responds with an error&quot;&quot;&quot; . Raised from the request() method if the action responds with an error . Inherited Members . builtins.Exception Exception builtins.BaseException with_traceback args class Agent: View Source 146class Agent(): 147 &quot;&quot;&quot; 148 An Actor that may represent an AI agent, software interface, or human user 149 &quot;&quot;&quot; 150 151 def __init__(self, id: str, receive_own_broadcasts: bool = True): 152 &quot;&quot;&quot; 153 Initializes an Agent. 154 155 This constructor is not meant to be called directly. It is invoked by 156 the Space class when adding an agent. 157 158 Subclasses should call super().__init__() in their constructor. 159 160 Args: 161 id: The id of the agent 162 receive_own_broadcasts: 163 Whether the agent will receive its own broadcasts. Defaults to 164 True 165 &quot;&quot;&quot; 166 if len(id) &lt; 1 or len(id) &gt; 255: 167 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 168 if re.match(r&quot;^amq\\.&quot;, id): 169 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 170 if id == &quot;*&quot;: 171 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 172 self._id: str = id 173 self._receive_own_broadcasts: bool = receive_own_broadcasts 174 # --- non-constructor properties set by Space/Processor --- 175 self._outbound_queue: Queue = None 176 self._is_processing: bool = False 177 # --- non-constructor properties --- 178 self._message_log: List[Message] = [] 179 self._message_log_lock: threading.Lock = threading.Lock() 180 self._pending_requests: Dict[str, Union[threading.Event, Message]] = {} 181 self._pending_requests_lock: threading.Lock = threading.Lock() 182 self.__thread_local_current_message = threading.local() 183 self.__thread_local_current_message.value: Message = None 184 185 def id(self) -&gt; str: 186 return self._id 187 188 def send(self, message: dict) -&gt; str: 189 &quot;&quot;&quot; 190 Sends (out) a message from this agent. 191 192 Args: 193 message: The message 194 195 Returns: 196 The meta.id of the sent message 197 198 Raises: 199 TypeError: If the message is not a dict 200 ValueError: If the message is invalid 201 &quot;&quot;&quot; 202 if not isinstance(message, dict): 203 raise TypeError(&quot;message must be a dict&quot;) 204 if &quot;from&quot; in message and message[&quot;from&quot;] != self.id(): 205 raise ValueError( 206 f&quot;&#39;from&#39; field value &#39;{message[&#39;from&#39;]}&#39; does not match this agent&#39;s id.&quot;) 207 message[&quot;from&quot;] = self.id() 208 message[&quot;meta&quot;] = { 209 &quot;id&quot;: uuid.uuid4().__str__(), 210 **message.get(&quot;meta&quot;, {}), 211 } 212 message = Message(**message).dict(by_alias=True, exclude_unset=True) 213 with self._message_log_lock: 214 log(&quot;info&quot;, f&quot;{self._id}: sending&quot;, message) 215 self._message_log.append(message) 216 self._outbound_queue.put(message) 217 return message[&quot;meta&quot;][&quot;id&quot;] 218 219 def request(self, message: dict, timeout: float = 3) -&gt; object: 220 &quot;&quot;&quot; 221 Synchronously sends a message then waits for and returns the return 222 value of the invoked action. 223 224 This method allows you to call an action synchronously like a function 225 and receive its return value in python. If the action raises an 226 exception an ActionError will be raised containing the error message. 227 228 Args: 229 message: The message to send 230 timeout: 231 The timeout in seconds to wait for the returned value. 232 Defaults to 3 seconds. 233 234 Returns: 235 object: The return value of the action. 236 237 Raises: 238 TimeoutError: If the timeout is reached 239 ActionError: If the action raised an exception 240 RuntimeError: 241 If called before the agent is processing incoming messages 242 &quot;&quot;&quot; 243 if not self._is_processing: 244 raise RuntimeError( 245 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 246 247 # Send and mark the request as pending 248 with self._pending_requests_lock: 249 request_id = self.send(message) 250 self._pending_requests[request_id] = threading.Event() 251 252 # Wait for response 253 if not self._pending_requests[request_id].wait(timeout=timeout): 254 raise TimeoutError 255 256 with self._pending_requests_lock: 257 response_message = self._pending_requests.pop(request_id) 258 259 # Raise error or return value from response 260 if response_message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 261 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 262 263 if response_message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 264 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 265 266 raise RuntimeError(&quot;We should never get here&quot;) 267 268 def respond_with(self, value): 269 &quot;&quot;&quot; 270 Sends a response with the given value. 271 272 Parameters: 273 value (any): The value to be sent in the response message. 274 &quot;&quot;&quot; 275 self.send({ 276 &quot;meta&quot;: { 277 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;] 278 }, 279 &quot;to&quot;: self.current_message()[&#39;from&#39;], 280 &quot;action&quot;: { 281 &quot;name&quot;: _RESPONSE_ACTION_NAME, 282 &quot;args&quot;: { 283 &quot;value&quot;: value, 284 } 285 } 286 }) 287 288 def raise_with(self, error: Exception): 289 &quot;&quot;&quot; 290 Sends an error response. 291 292 Args: 293 error (Exception): The error to send. 294 &quot;&quot;&quot; 295 self.send({ 296 &quot;meta&quot;: { 297 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;], 298 }, 299 &quot;to&quot;: self.current_message()[&#39;from&#39;], 300 &quot;action&quot;: { 301 &quot;name&quot;: _ERROR_ACTION_NAME, 302 &quot;args&quot;: { 303 &quot;error&quot;: f&quot;{error.__class__.__name__}: {error}&quot; 304 } 305 } 306 }) 307 308 def _receive(self, message: dict): 309 &quot;&quot;&quot; 310 Receives and handles an incoming message. 311 312 Args: 313 message: The incoming message 314 &quot;&quot;&quot; 315 try: 316 # Ignore own broadcasts if _receive_own_broadcasts is false 317 if not self._receive_own_broadcasts \\ 318 and message[&#39;from&#39;] == self.id() \\ 319 and message[&#39;to&#39;] == &#39;*&#39;: 320 return 321 322 log(&quot;debug&quot;, f&quot;{self.id()}: received message&quot;, message) 323 324 # Record the received message before handling 325 with self._message_log_lock: 326 self._message_log.append(message) 327 328 # Handle incoming responses 329 # TODO: make serial/fan-out optional 330 if message[&quot;action&quot;][&quot;name&quot;] in [_RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME]: 331 parent_id = message[&quot;meta&quot;][&quot;parent_id&quot;] 332 if parent_id in self._pending_requests.keys(): 333 # This was a response to a request(). We use a little trick 334 # here and simply swap out the event that is waiting with 335 # the message, then set the event. The request() method will 336 # pick up the response message in the existing thread. 337 event = self._pending_requests[parent_id] 338 self._pending_requests[parent_id] = message 339 event.set() 340 else: 341 # This was a response to a send() 342 if message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 343 handler_callback = self.handle_action_value 344 arg = message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 345 elif message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 346 handler_callback = self.handle_action_error 347 arg = ActionError(message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 348 else: 349 raise RuntimeError(&quot;Unknown action response&quot;) 350 351 # Spawn a thread to handle the response 352 def __process_response(arg, current_message): 353 threading.current_thread( 354 ).name = f&quot;{self.id()}: __process_response {current_message[&#39;meta&#39;][&#39;id&#39;]}&quot; 355 self.__thread_local_current_message.value = current_message 356 handler_callback(arg) 357 358 ResourceManager().thread_pool_executor.submit( 359 __process_response, 360 arg, 361 message, 362 ) 363 364 # Handle all other messages 365 else: 366 # Spawn a thread to process the message. This means that messages 367 # are processed concurrently, but may be processed out of order. 368 ResourceManager().thread_pool_executor.submit( 369 self.__process, 370 message, 371 ) 372 except Exception as e: 373 log(&quot;error&quot;, f&quot;{self.id()}: raised exception in _receive&quot;, e) 374 375 def __process(self, message: dict): 376 &quot;&quot;&quot; 377 Top level method within the action processing thread. 378 &quot;&quot;&quot; 379 threading.current_thread( 380 ).name = f&quot;{self.id()}: __process {message[&#39;meta&#39;][&#39;id&#39;]}&quot; 381 self.__thread_local_current_message.value = message 382 try: 383 log(&quot;debug&quot;, f&quot;{self.id()}: committing action&quot;, message) 384 self.__commit(message) 385 except Exception as e: 386 # Handle errors (including PermissionError) that occur while 387 # committing an action by reporting back to the sender. 388 log(&quot;warning&quot;, 389 f&quot;{self.id()}: raised exception while committing action &#39;{message[&#39;action&#39;][&#39;name&#39;]}&#39;&quot;, e) 390 self.raise_with(e) 391 392 def __commit(self, message: dict): 393 &quot;&quot;&quot; 394 Invokes the action method 395 396 Args: 397 message: The incoming message specifying the action 398 399 Raises: 400 AttributeError: If the action method is not found 401 PermissionError: If the action is not permitted 402 &quot;&quot;&quot; 403 try: 404 # Check if the action method exists 405 action_method = self.__action_method(message[&quot;action&quot;][&quot;name&quot;]) 406 except KeyError: 407 # the action was not found 408 if message[&#39;to&#39;] == &#39;*&#39;: 409 return # broadcasts will not raise an error in this situation 410 else: 411 raise AttributeError( 412 f&quot;\\&quot;{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not found on \\&quot;{self.id()}\\&quot;&quot;) 413 414 # Check if the action is permitted 415 if not self.__permitted(message): 416 raise PermissionError( 417 f&quot;\\&quot;{self.id()}.{message[&#39;action&#39;][&#39;name&#39;]}\\&quot; not permitted&quot;) 418 419 self.before_action(message) 420 421 return_value = None 422 error = None 423 try: 424 # Invoke the action method 425 return_value = action_method(**message[&#39;action&#39;].get(&#39;args&#39;, {})) 426 except Exception as e: 427 error = e 428 raise 429 finally: 430 self.after_action(message, return_value, error) 431 return return_value 432 433 def __permitted(self, message: dict) -&gt; bool: 434 &quot;&quot;&quot; 435 Checks whether the message&#39;s action is allowed 436 &quot;&quot;&quot; 437 action_method = self.__action_method(message[&#39;action&#39;][&#39;name&#39;]) 438 policy = action_method.action_properties[&quot;access_policy&quot;] 439 if policy == ACCESS_PERMITTED: 440 return True 441 elif policy == ACCESS_DENIED: 442 return False 443 elif policy == ACCESS_REQUESTED: 444 return self.request_permission(message) 445 else: 446 raise Exception( 447 f&quot;Invalid access policy for method: {message[&#39;action&#39;]}, got &#39;{policy}&#39;&quot;) 448 449 def __action_methods(self) -&gt; dict: 450 instance_methods = inspect.getmembers(self, inspect.ismethod) 451 action_methods = { 452 method_name: method 453 for method_name, method in instance_methods 454 if hasattr(method, &quot;action_properties&quot;) 455 } 456 return action_methods 457 458 def __action_method(self, action_name: str): 459 &quot;&quot;&quot; 460 Returns the method for the given action name. 461 &quot;&quot;&quot; 462 action_methods = self.__action_methods() 463 return action_methods[action_name] 464 465 def _find_message(self, message_id: str) -&gt; Message: 466 &quot;&quot;&quot; 467 Returns a message from the log with the given ID. 468 469 Args: 470 message_id: The ID of the message 471 472 Returns: 473 The message or None if not found 474 &quot;&quot;&quot; 475 for message in self._message_log: 476 if message[&quot;meta&quot;][&quot;id&quot;] == message_id: 477 return message 478 479 def current_message(self) -&gt; Message: 480 &quot;&quot;&quot; 481 Returns the full incoming message which invoked the current action. 482 483 This method may be called within an action or action related callback to 484 retrieve the current message, for example to determine the sender or 485 inspect other details. 486 487 Returns: 488 The current message 489 &quot;&quot;&quot; 490 return self.__thread_local_current_message.value 491 492 def parent_message(self, message: Message = None) -&gt; Message: 493 &quot;&quot;&quot; 494 Returns the message that the given message is responding to, if any. 495 496 This method may be used within the handle_action_value and 497 handle_action_error callbacks. 498 499 Args: 500 message: The message to get the parent message of. Defaults to the 501 current message. 502 503 Returns: 504 The parent message or None 505 &quot;&quot;&quot; 506 if message is None: 507 message = self.current_message() 508 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 509 if parent_id is not None: 510 return self._find_message(parent_id) 511 512 @action 513 def help(self, action_name: str = None) -&gt; dict: 514 &quot;&quot;&quot; 515 Returns a list of actions on this agent. 516 517 If action_name is passed, returns a list with only that action. 518 If no action_name is passed, returns all actions. 519 520 Args: 521 action_name: (Optional) The name of an action to request help for 522 523 Returns: 524 A dictionary of actions 525 &quot;&quot;&quot; 526 self.respond_with(self._help(action_name)) 527 528 def _help(self, action_name: str = None) -&gt; dict: 529 &quot;&quot;&quot; 530 Generates the help information returned by the help() action 531 &quot;&quot;&quot; 532 special_actions = [&quot;help&quot;, _RESPONSE_ACTION_NAME, _ERROR_ACTION_NAME] 533 help_list = { 534 method.action_properties[&quot;name&quot;]: method.action_properties[&quot;help&quot;] 535 for method in self.__action_methods().values() 536 if action_name is None 537 and method.action_properties[&quot;name&quot;] not in special_actions 538 or method.action_properties[&quot;name&quot;] == action_name 539 } 540 return help_list 541 542 def handle_action_value(self, value): 543 &quot;&quot;&quot; 544 Receives a return value from a previous action. 545 546 This method receives return values from actions invoked by the send() 547 method. It is not called when using the request() method, which returns 548 the value directly. 549 550 To inspect the full response message carrying this value, use 551 current_message(). To inspect the message which returned the value, use 552 parent_message(). 553 554 Args: 555 value: 556 The return value 557 &quot;&quot;&quot; 558 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 559 self._issued_handle_action_value_warning = True 560 log(&quot;warning&quot;, 561 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) 562 563 def handle_action_error(self, error: ActionError): 564 &quot;&quot;&quot; 565 Receives an error from a previous action. 566 567 This method receives errors from actions invoked by the send() method. 568 It is not called when using the request() method, which raises an error 569 directly. 570 571 To inspect the full response message carrying this error, use 572 current_message(). To inspect the message which caused the error, use 573 parent_message(). 574 575 Args: 576 error: The error 577 &quot;&quot;&quot; 578 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 579 self._issued_handle_action_error_warning = True 580 log(&quot;warning&quot;, 581 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) 582 583 def after_add(self): 584 &quot;&quot;&quot; 585 Called after the agent is added to a space, but before it begins 586 processing incoming messages. 587 588 The agent may send messages during this callback using the send() 589 method, but may not use the request() method since it relies on 590 processing incoming messages. 591 &quot;&quot;&quot; 592 593 def before_remove(self): 594 &quot;&quot;&quot; 595 Called before the agent is removed from a space, after it has finished 596 processing incoming messages. 597 598 The agent may send final messages during this callback using the send() 599 method, but may not use the request() method since it relies on 600 processing incoming messages. 601 &quot;&quot;&quot; 602 603 def before_action(self, message: dict): 604 &quot;&quot;&quot; 605 Called before every action. 606 607 This method will only be called if the action exists and is permitted. 608 609 Args: 610 message: The received message that contains the action 611 &quot;&quot;&quot; 612 613 def after_action(self, message: dict, return_value: str, error: str): 614 &quot;&quot;&quot; 615 Called after every action, regardless of whether an error occurred. 616 617 Args: 618 message: The message which invoked the action 619 return_value: The return value from the action 620 error: The error from the action if any 621 &quot;&quot;&quot; 622 623 def request_permission(self, proposed_message: dict) -&gt; bool: 624 &quot;&quot;&quot; 625 Receives a proposed action message and presents it to the agent for 626 review. 627 628 Args: 629 proposed_message: The proposed action message 630 631 Returns: 632 True if access should be permitted 633 &quot;&quot;&quot; 634 raise NotImplementedError( 635 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . An Actor that may represent an AI agent, software interface, or human user . Agent(id: str, receive_own_broadcasts: bool = True) View Source 151 def __init__(self, id: str, receive_own_broadcasts: bool = True): 152 &quot;&quot;&quot; 153 Initializes an Agent. 154 155 This constructor is not meant to be called directly. It is invoked by 156 the Space class when adding an agent. 157 158 Subclasses should call super().__init__() in their constructor. 159 160 Args: 161 id: The id of the agent 162 receive_own_broadcasts: 163 Whether the agent will receive its own broadcasts. Defaults to 164 True 165 &quot;&quot;&quot; 166 if len(id) &lt; 1 or len(id) &gt; 255: 167 raise ValueError(&quot;id must be between 1 and 255 characters&quot;) 168 if re.match(r&quot;^amq\\.&quot;, id): 169 raise ValueError(&quot;id cannot start with \\&quot;amq.\\&quot;&quot;) 170 if id == &quot;*&quot;: 171 raise ValueError(&quot;id cannot be \\&quot;*\\&quot;&quot;) 172 self._id: str = id 173 self._receive_own_broadcasts: bool = receive_own_broadcasts 174 # --- non-constructor properties set by Space/Processor --- 175 self._outbound_queue: Queue = None 176 self._is_processing: bool = False 177 # --- non-constructor properties --- 178 self._message_log: List[Message] = [] 179 self._message_log_lock: threading.Lock = threading.Lock() 180 self._pending_requests: Dict[str, Union[threading.Event, Message]] = {} 181 self._pending_requests_lock: threading.Lock = threading.Lock() 182 self.__thread_local_current_message = threading.local() 183 self.__thread_local_current_message.value: Message = None . Initializes an Agent. This constructor is not meant to be called directly. It is invoked by the Space class when adding an agent. Subclasses should call super().__init__() in their constructor. Arguments: . | id: The id of the agent | receive_own_broadcasts: Whether the agent will receive its own broadcasts. Defaults to True | . def id(self) -> str: View Source 185 def id(self) -&gt; str: 186 return self._id . def send(self, message: dict) -> str: View Source 188 def send(self, message: dict) -&gt; str: 189 &quot;&quot;&quot; 190 Sends (out) a message from this agent. 191 192 Args: 193 message: The message 194 195 Returns: 196 The meta.id of the sent message 197 198 Raises: 199 TypeError: If the message is not a dict 200 ValueError: If the message is invalid 201 &quot;&quot;&quot; 202 if not isinstance(message, dict): 203 raise TypeError(&quot;message must be a dict&quot;) 204 if &quot;from&quot; in message and message[&quot;from&quot;] != self.id(): 205 raise ValueError( 206 f&quot;&#39;from&#39; field value &#39;{message[&#39;from&#39;]}&#39; does not match this agent&#39;s id.&quot;) 207 message[&quot;from&quot;] = self.id() 208 message[&quot;meta&quot;] = { 209 &quot;id&quot;: uuid.uuid4().__str__(), 210 **message.get(&quot;meta&quot;, {}), 211 } 212 message = Message(**message).dict(by_alias=True, exclude_unset=True) 213 with self._message_log_lock: 214 log(&quot;info&quot;, f&quot;{self._id}: sending&quot;, message) 215 self._message_log.append(message) 216 self._outbound_queue.put(message) 217 return message[&quot;meta&quot;][&quot;id&quot;] . Sends (out) a message from this agent. Arguments: . | message: The message | . Returns: . The meta.id of the sent message . Raises: . | TypeError: If the message is not a dict | ValueError: If the message is invalid | . def request(self, message: dict, timeout: float = 3) -> object: View Source 219 def request(self, message: dict, timeout: float = 3) -&gt; object: 220 &quot;&quot;&quot; 221 Synchronously sends a message then waits for and returns the return 222 value of the invoked action. 223 224 This method allows you to call an action synchronously like a function 225 and receive its return value in python. If the action raises an 226 exception an ActionError will be raised containing the error message. 227 228 Args: 229 message: The message to send 230 timeout: 231 The timeout in seconds to wait for the returned value. 232 Defaults to 3 seconds. 233 234 Returns: 235 object: The return value of the action. 236 237 Raises: 238 TimeoutError: If the timeout is reached 239 ActionError: If the action raised an exception 240 RuntimeError: 241 If called before the agent is processing incoming messages 242 &quot;&quot;&quot; 243 if not self._is_processing: 244 raise RuntimeError( 245 &quot;request() called while agent is not processing incoming messages. Use send() instead.&quot;) 246 247 # Send and mark the request as pending 248 with self._pending_requests_lock: 249 request_id = self.send(message) 250 self._pending_requests[request_id] = threading.Event() 251 252 # Wait for response 253 if not self._pending_requests[request_id].wait(timeout=timeout): 254 raise TimeoutError 255 256 with self._pending_requests_lock: 257 response_message = self._pending_requests.pop(request_id) 258 259 # Raise error or return value from response 260 if response_message[&quot;action&quot;][&quot;name&quot;] == _ERROR_ACTION_NAME: 261 raise ActionError(response_message[&quot;action&quot;][&quot;args&quot;][&quot;error&quot;]) 262 263 if response_message[&quot;action&quot;][&quot;name&quot;] == _RESPONSE_ACTION_NAME: 264 return response_message[&quot;action&quot;][&quot;args&quot;][&quot;value&quot;] 265 266 raise RuntimeError(&quot;We should never get here&quot;) . Synchronously sends a message then waits for and returns the return value of the invoked action. This method allows you to call an action synchronously like a function and receive its return value in python. If the action raises an exception an ActionError will be raised containing the error message. Arguments: . | message: The message to send | timeout: The timeout in seconds to wait for the returned value. Defaults to 3 seconds. | . Returns: . object: The return value of the action. Raises: . | TimeoutError: If the timeout is reached | ActionError: If the action raised an exception | RuntimeError: If called before the agent is processing incoming messages | . def respond_with(self, value): View Source 268 def respond_with(self, value): 269 &quot;&quot;&quot; 270 Sends a response with the given value. 271 272 Parameters: 273 value (any): The value to be sent in the response message. 274 &quot;&quot;&quot; 275 self.send({ 276 &quot;meta&quot;: { 277 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;] 278 }, 279 &quot;to&quot;: self.current_message()[&#39;from&#39;], 280 &quot;action&quot;: { 281 &quot;name&quot;: _RESPONSE_ACTION_NAME, 282 &quot;args&quot;: { 283 &quot;value&quot;: value, 284 } 285 } 286 }) . Sends a response with the given value. Arguments: . | value (any): The value to be sent in the response message. | . def raise_with(self, error: Exception): View Source 288 def raise_with(self, error: Exception): 289 &quot;&quot;&quot; 290 Sends an error response. 291 292 Args: 293 error (Exception): The error to send. 294 &quot;&quot;&quot; 295 self.send({ 296 &quot;meta&quot;: { 297 &quot;parent_id&quot;: self.current_message()[&quot;meta&quot;][&quot;id&quot;], 298 }, 299 &quot;to&quot;: self.current_message()[&#39;from&#39;], 300 &quot;action&quot;: { 301 &quot;name&quot;: _ERROR_ACTION_NAME, 302 &quot;args&quot;: { 303 &quot;error&quot;: f&quot;{error.__class__.__name__}: {error}&quot; 304 } 305 } 306 }) . Sends an error response. Arguments: . | error (Exception): The error to send. | . def current_message(self) -> agency.schema.Message: View Source 479 def current_message(self) -&gt; Message: 480 &quot;&quot;&quot; 481 Returns the full incoming message which invoked the current action. 482 483 This method may be called within an action or action related callback to 484 retrieve the current message, for example to determine the sender or 485 inspect other details. 486 487 Returns: 488 The current message 489 &quot;&quot;&quot; 490 return self.__thread_local_current_message.value . Returns the full incoming message which invoked the current action. This method may be called within an action or action related callback to retrieve the current message, for example to determine the sender or inspect other details. Returns: . The current message . def parent_message(self, message: agency.schema.Message = None) -> agency.schema.Message: View Source 492 def parent_message(self, message: Message = None) -&gt; Message: 493 &quot;&quot;&quot; 494 Returns the message that the given message is responding to, if any. 495 496 This method may be used within the handle_action_value and 497 handle_action_error callbacks. 498 499 Args: 500 message: The message to get the parent message of. Defaults to the 501 current message. 502 503 Returns: 504 The parent message or None 505 &quot;&quot;&quot; 506 if message is None: 507 message = self.current_message() 508 parent_id = message[&quot;meta&quot;].get(&quot;parent_id&quot;, None) 509 if parent_id is not None: 510 return self._find_message(parent_id) . Returns the message that the given message is responding to, if any. This method may be used within the handle_action_value and handle_action_error callbacks. Arguments: . | message: The message to get the parent message of. Defaults to the | current message. | . Returns: . The parent message or None . @action def help(self, action_name: str = None) -> dict: View Source 512 @action 513 def help(self, action_name: str = None) -&gt; dict: 514 &quot;&quot;&quot; 515 Returns a list of actions on this agent. 516 517 If action_name is passed, returns a list with only that action. 518 If no action_name is passed, returns all actions. 519 520 Args: 521 action_name: (Optional) The name of an action to request help for 522 523 Returns: 524 A dictionary of actions 525 &quot;&quot;&quot; 526 self.respond_with(self._help(action_name)) . Returns a list of actions on this agent. If action_name is passed, returns a list with only that action. If no action_name is passed, returns all actions. Arguments: . | action_name: (Optional) The name of an action to request help for | . Returns: . A dictionary of actions . def handle_action_value(self, value): View Source 542 def handle_action_value(self, value): 543 &quot;&quot;&quot; 544 Receives a return value from a previous action. 545 546 This method receives return values from actions invoked by the send() 547 method. It is not called when using the request() method, which returns 548 the value directly. 549 550 To inspect the full response message carrying this value, use 551 current_message(). To inspect the message which returned the value, use 552 parent_message(). 553 554 Args: 555 value: 556 The return value 557 &quot;&quot;&quot; 558 if not hasattr(self, &quot;_issued_handle_action_value_warning&quot;): 559 self._issued_handle_action_value_warning = True 560 log(&quot;warning&quot;, 561 f&quot;A value was returned from an action. Implement {self.__class__.__name__}.handle_action_value() to handle it.&quot;) . Receives a return value from a previous action. This method receives return values from actions invoked by the send() method. It is not called when using the request() method, which returns the value directly. To inspect the full response message carrying this value, use current_message(). To inspect the message which returned the value, use parent_message(). Arguments: . | value: The return value | . def handle_action_error(self, error: ActionError): View Source 563 def handle_action_error(self, error: ActionError): 564 &quot;&quot;&quot; 565 Receives an error from a previous action. 566 567 This method receives errors from actions invoked by the send() method. 568 It is not called when using the request() method, which raises an error 569 directly. 570 571 To inspect the full response message carrying this error, use 572 current_message(). To inspect the message which caused the error, use 573 parent_message(). 574 575 Args: 576 error: The error 577 &quot;&quot;&quot; 578 if not hasattr(self, &quot;_issued_handle_action_error_warning&quot;): 579 self._issued_handle_action_error_warning = True 580 log(&quot;warning&quot;, 581 f&quot;An error was raised from an action. Implement {self.__class__.__name__}.handle_action_error() to handle it.&quot;) . Receives an error from a previous action. This method receives errors from actions invoked by the send() method. It is not called when using the request() method, which raises an error directly. To inspect the full response message carrying this error, use current_message(). To inspect the message which caused the error, use parent_message(). Arguments: . | error: The error | . def after_add(self): View Source 583 def after_add(self): 584 &quot;&quot;&quot; 585 Called after the agent is added to a space, but before it begins 586 processing incoming messages. 587 588 The agent may send messages during this callback using the send() 589 method, but may not use the request() method since it relies on 590 processing incoming messages. 591 &quot;&quot;&quot; . Called after the agent is added to a space, but before it begins processing incoming messages. The agent may send messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_remove(self): View Source 593 def before_remove(self): 594 &quot;&quot;&quot; 595 Called before the agent is removed from a space, after it has finished 596 processing incoming messages. 597 598 The agent may send final messages during this callback using the send() 599 method, but may not use the request() method since it relies on 600 processing incoming messages. 601 &quot;&quot;&quot; . Called before the agent is removed from a space, after it has finished processing incoming messages. The agent may send final messages during this callback using the send() method, but may not use the request() method since it relies on processing incoming messages. def before_action(self, message: dict): View Source 603 def before_action(self, message: dict): 604 &quot;&quot;&quot; 605 Called before every action. 606 607 This method will only be called if the action exists and is permitted. 608 609 Args: 610 message: The received message that contains the action 611 &quot;&quot;&quot; . Called before every action. This method will only be called if the action exists and is permitted. Arguments: . | message: The received message that contains the action | . def after_action(self, message: dict, return_value: str, error: str): View Source 613 def after_action(self, message: dict, return_value: str, error: str): 614 &quot;&quot;&quot; 615 Called after every action, regardless of whether an error occurred. 616 617 Args: 618 message: The message which invoked the action 619 return_value: The return value from the action 620 error: The error from the action if any 621 &quot;&quot;&quot; . Called after every action, regardless of whether an error occurred. Arguments: . | message: The message which invoked the action | return_value: The return value from the action | error: The error from the action if any | . def request_permission(self, proposed_message: dict) -> bool: View Source 623 def request_permission(self, proposed_message: dict) -&gt; bool: 624 &quot;&quot;&quot; 625 Receives a proposed action message and presents it to the agent for 626 review. 627 628 Args: 629 proposed_message: The proposed action message 630 631 Returns: 632 True if access should be permitted 633 &quot;&quot;&quot; 634 raise NotImplementedError( 635 f&quot;You must implement {self.__class__.__name__}.request_permission() to use ACCESS_REQUESTED&quot;) . Receives a proposed action message and presents it to the agent for review. Arguments: . | proposed_message: The proposed action message | . Returns: . True if access should be permitted . ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"33": {
    "doc": "agency.agent",
    "title": "agency.agent",
    "content": " ",
    "url": "/api_docs/agency/agent.html",
    
    "relUrl": "/api_docs/agency/agent.html"
  },"34": {
    "doc": "agency.logger",
    "title": "\nagency.logger    ",
    "content": "View Source 1import json 2import logging 3import os 4import traceback 5 6import colorlog 7from colorlog.escape_codes import escape_codes 8from pygments import highlight 9from pygments.formatters import Terminal256Formatter 10from pygments.lexers import get_lexer_by_name 11 12_LOGLEVELS = { 13 &#39;CRITICAL&#39;: 50, 14 &#39;ERROR&#39;: 40, 15 &#39;WARNING&#39;: 30, 16 &#39;INFO&#39;: 20, 17 &#39;DEBUG&#39;: 10, 18 &#39;NOTSET&#39;: 0 19} 20 21_env_loglevel = os.environ.get(&#39;LOGLEVEL&#39;, &#39;WARNING&#39;).upper() 22_LOGLEVEL = _LOGLEVELS[_env_loglevel] 23_LOGFORMAT = &#39;%(asctime_color)s%(asctime)s%(reset_color)s - %(levelname_color)s%(levelname)s%(reset_color)s - %(message_color)s%(message)s%(reset_color)s%(object_color)s%(object)s%(reset_color)s&#39; 24_LOG_PYGMENTS_STYLE = os.environ.get(&#39;LOG_PYGMENTS_STYLE&#39;, &#39;monokai&#39;) 25 26 27class CustomColoredFormatter(colorlog.ColoredFormatter): 28 def format(self, record): 29 record.reset_color = escape_codes[&#39;reset&#39;] 30 record.asctime_color = escape_codes[&#39;light_black&#39;] 31 record.levelname_color = escape_codes[self.log_colors[record.levelname]] 32 record.message_color = escape_codes[&#39;reset&#39;] 33 record.object_color = escape_codes[&#39;reset&#39;] 34 35 return super().format(record) 36 37 38_logger = logging.getLogger(&quot;agency&quot;) 39_logger.setLevel(_LOGLEVEL) 40_handler = logging.StreamHandler() 41_handler.setLevel(_LOGLEVEL) 42 43_formatter = CustomColoredFormatter( 44 _LOGFORMAT, 45 log_colors={ 46 &#39;CRITICAL&#39;: &#39;bold_red&#39;, 47 &#39;ERROR&#39;: &#39;red&#39;, 48 &#39;WARNING&#39;: &#39;yellow&#39;, 49 &#39;INFO&#39;: &#39;green&#39;, 50 &#39;DEBUG&#39;: &#39;cyan&#39;, 51 } 52) 53 54_handler.setFormatter(_formatter) 55_logger.addHandler(_handler) 56 57 58class _CustomEncoder(json.JSONEncoder): 59 def default(self, obj): 60 try: 61 return super().default(obj) 62 except TypeError: 63 return str(obj) 64 65 66def log(level: str, message: str, object=None): 67 pretty_object: str = &quot;&quot; 68 if object != None: 69 try: 70 if isinstance(object, Exception): 71 pretty_object = &quot;\\n&quot; + &quot;&quot;.join(traceback.format_exception( 72 etype=type(object), value=object, tb=object.__traceback__)) 73 else: 74 json_str = json.dumps(object, indent=2, cls=_CustomEncoder) 75 pretty_object = &quot;\\n&quot; + \\ 76 highlight(json_str, get_lexer_by_name(&#39;json&#39;), 77 Terminal256Formatter(style=_LOG_PYGMENTS_STYLE)) 78 except: 79 pass 80 81 numeric_level = _LOGLEVELS.get(level.upper()) 82 if numeric_level is not None: 83 _logger.log(numeric_level, message, extra={&#39;object&#39;: pretty_object}) 84 else: 85 raise ValueError(f&quot;Invalid log level: {level}&quot;) . class CustomColoredFormatter(colorlog.formatter.ColoredFormatter): View Source 28class CustomColoredFormatter(colorlog.ColoredFormatter): 29 def format(self, record): 30 record.reset_color = escape_codes[&#39;reset&#39;] 31 record.asctime_color = escape_codes[&#39;light_black&#39;] 32 record.levelname_color = escape_codes[self.log_colors[record.levelname]] 33 record.message_color = escape_codes[&#39;reset&#39;] 34 record.object_color = escape_codes[&#39;reset&#39;] 35 36 return super().format(record) . A formatter that allows colors to be placed in the format string. Intended to help in creating more readable logging output. def format(self, record): View Source 29 def format(self, record): 30 record.reset_color = escape_codes[&#39;reset&#39;] 31 record.asctime_color = escape_codes[&#39;light_black&#39;] 32 record.levelname_color = escape_codes[self.log_colors[record.levelname]] 33 record.message_color = escape_codes[&#39;reset&#39;] 34 record.object_color = escape_codes[&#39;reset&#39;] 35 36 return super().format(record) . Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Inherited Members . colorlog.formatter.ColoredFormatter ColoredFormatter log_colors secondary_log_colors reset stream no_color force_color formatMessage logging.Formatter converter datefmt default_time_format default_msec_format formatTime formatException usesTime formatStack def log(level: str, message: str, object=None): View Source 67def log(level: str, message: str, object=None): 68 pretty_object: str = &quot;&quot; 69 if object != None: 70 try: 71 if isinstance(object, Exception): 72 pretty_object = &quot;\\n&quot; + &quot;&quot;.join(traceback.format_exception( 73 etype=type(object), value=object, tb=object.__traceback__)) 74 else: 75 json_str = json.dumps(object, indent=2, cls=_CustomEncoder) 76 pretty_object = &quot;\\n&quot; + \\ 77 highlight(json_str, get_lexer_by_name(&#39;json&#39;), 78 Terminal256Formatter(style=_LOG_PYGMENTS_STYLE)) 79 except: 80 pass 81 82 numeric_level = _LOGLEVELS.get(level.upper()) 83 if numeric_level is not None: 84 _logger.log(numeric_level, message, extra={&#39;object&#39;: pretty_object}) 85 else: 86 raise ValueError(f&quot;Invalid log level: {level}&quot;) . ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"35": {
    "doc": "agency.logger",
    "title": "agency.logger",
    "content": " ",
    "url": "/api_docs/agency/logger.html",
    
    "relUrl": "/api_docs/agency/logger.html"
  },"36": {
    "doc": "agency.processor",
    "title": "\nagency.processor    ",
    "content": "View Source 1import multiprocessing 2import queue 3import threading 4from abc import ABC, ABCMeta 5from concurrent.futures import (Executor, Future) 6from typing import Dict, List, Protocol, Type 7 8from agency.agent import Agent 9from agency.logger import log 10from agency.queue import Queue 11 12 13class _EventProtocol(Protocol): 14 def set(self) -&gt; None: 15 pass 16 17 def clear(self) -&gt; None: 18 pass 19 20 def is_set(self) -&gt; bool: 21 pass 22 23 def wait(self, timeout: float = None) -&gt; bool: 24 pass 25 26 27class Processor(ABC, metaclass=ABCMeta): 28 &quot;&quot;&quot; 29 Encapsulates a running Agent instance 30 &quot;&quot;&quot; 31 def __init__(self, 32 agent_type: Type[Agent], 33 agent_id: str, 34 agent_args: List, 35 agent_kwargs: Dict, 36 inbound_queue: Queue, 37 outbound_queue: Queue, 38 started: _EventProtocol, 39 stopping: _EventProtocol, 40 new_message_event: _EventProtocol, 41 executor: Executor): 42 self.agent_type: Type[Agent] = agent_type 43 self.agent_id: str = agent_id 44 self.agent_args: List = agent_args 45 self.agent_kwargs: Dict = agent_kwargs 46 self.inbound_queue: Queue = inbound_queue 47 self.outbound_queue: Queue = outbound_queue 48 self.started: _EventProtocol = started 49 self.stopping: _EventProtocol = stopping 50 self.new_message_event: _EventProtocol = new_message_event 51 self.executor: Executor = executor 52 # --- non-constructor properties --- 53 self._future: Future = None 54 self._agent: Agent = None # Accessible if in foreground 55 56 def start(self) -&gt; Agent: 57 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor starting ...&quot;) 58 59 agent_ref: List = [] 60 self._future = self.executor.submit( 61 _process_loop, 62 self.agent_type, 63 self.agent_id, 64 self.agent_args, 65 self.agent_kwargs, 66 self.inbound_queue, 67 self.outbound_queue, 68 self.started, 69 self.stopping, 70 self.new_message_event, 71 agent_ref, 72 ) 73 74 if not self.started.wait(timeout=5): 75 # it couldn&#39;t start, force stop it and raise an exception 76 self.stop() 77 error = self._future.exception() 78 if error is not None: 79 raise error 80 else: 81 raise Exception(&quot;Processor could not be started.&quot;) 82 83 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor started&quot;) 84 85 # return the agent if present. only works in foreground 86 if agent_ref: 87 return agent_ref[0] 88 89 def stop(self): 90 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopping ...&quot;) 91 self.stopping.set() 92 if self._future is not None: 93 self._future.result() 94 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopped&quot;) 95 96 97# Placed at the top-level to play nice with the multiprocessing module 98def _process_loop(agent_type: Type[Agent], 99 agent_id: str, 100 agent_args: List, 101 agent_kwargs: Dict, 102 inbound_queue: Queue, 103 outbound_queue: Queue, 104 started: _EventProtocol, 105 stopping: _EventProtocol, 106 new_message_event: _EventProtocol, 107 agent_ref: List): 108 &quot;&quot;&quot; 109 The main agent processing loop 110 &quot;&quot;&quot; 111 # Set process or thread name 112 if isinstance(started, threading.Event): 113 threading.current_thread( 114 ).name = f&quot;{agent_id}: processor loop thread&quot; 115 else: 116 multiprocessing.current_process( 117 ).name = f&quot;{agent_id}: processor loop process&quot; 118 119 try: 120 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop starting&quot;) 121 agent: Agent = agent_type(agent_id, *agent_args, **agent_kwargs) 122 agent_ref.append(agent) # set the agent reference 123 inbound_queue.connect() 124 outbound_queue.connect() 125 agent._outbound_queue = outbound_queue 126 agent.after_add() 127 agent._is_processing = True 128 started.set() 129 stopping.clear() 130 new_message_event.clear() 131 while not stopping.is_set(): 132 new_message_event.wait(timeout=0.1) # TODO make configurable 133 if stopping.is_set(): 134 log(&quot;debug&quot;, 135 f&quot;{agent_id}: processor loop stopping&quot;) 136 break 137 while True: # drain inbound_queue 138 try: 139 message = inbound_queue.get(block=False) 140 log(&quot;debug&quot;, 141 f&quot;{agent_id}: processor loop got message&quot;, message) 142 agent._receive(message) 143 except queue.Empty: 144 break 145 new_message_event.clear() 146 except KeyboardInterrupt: 147 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop interrupted&quot;) 148 pass 149 except Exception as e: 150 log(&quot;error&quot;, f&quot;{agent_id}: processor loop failed&quot;, e) 151 raise 152 finally: 153 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop cleaning up&quot;) 154 agent._is_processing = False 155 agent.before_remove() 156 inbound_queue.disconnect() 157 outbound_queue.disconnect() 158 log(&quot;debug&quot;, f&quot;{agent_id}: processor loop stopped&quot;) . class Processor(abc.ABC): View Source 28class Processor(ABC, metaclass=ABCMeta): 29 &quot;&quot;&quot; 30 Encapsulates a running Agent instance 31 &quot;&quot;&quot; 32 def __init__(self, 33 agent_type: Type[Agent], 34 agent_id: str, 35 agent_args: List, 36 agent_kwargs: Dict, 37 inbound_queue: Queue, 38 outbound_queue: Queue, 39 started: _EventProtocol, 40 stopping: _EventProtocol, 41 new_message_event: _EventProtocol, 42 executor: Executor): 43 self.agent_type: Type[Agent] = agent_type 44 self.agent_id: str = agent_id 45 self.agent_args: List = agent_args 46 self.agent_kwargs: Dict = agent_kwargs 47 self.inbound_queue: Queue = inbound_queue 48 self.outbound_queue: Queue = outbound_queue 49 self.started: _EventProtocol = started 50 self.stopping: _EventProtocol = stopping 51 self.new_message_event: _EventProtocol = new_message_event 52 self.executor: Executor = executor 53 # --- non-constructor properties --- 54 self._future: Future = None 55 self._agent: Agent = None # Accessible if in foreground 56 57 def start(self) -&gt; Agent: 58 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor starting ...&quot;) 59 60 agent_ref: List = [] 61 self._future = self.executor.submit( 62 _process_loop, 63 self.agent_type, 64 self.agent_id, 65 self.agent_args, 66 self.agent_kwargs, 67 self.inbound_queue, 68 self.outbound_queue, 69 self.started, 70 self.stopping, 71 self.new_message_event, 72 agent_ref, 73 ) 74 75 if not self.started.wait(timeout=5): 76 # it couldn&#39;t start, force stop it and raise an exception 77 self.stop() 78 error = self._future.exception() 79 if error is not None: 80 raise error 81 else: 82 raise Exception(&quot;Processor could not be started.&quot;) 83 84 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor started&quot;) 85 86 # return the agent if present. only works in foreground 87 if agent_ref: 88 return agent_ref[0] 89 90 def stop(self): 91 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopping ...&quot;) 92 self.stopping.set() 93 if self._future is not None: 94 self._future.result() 95 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopped&quot;) . Encapsulates a running Agent instance . Processor( agent_type: Type[agency.agent.Agent], agent_id: str, agent_args: List, agent_kwargs: Dict, inbound_queue: agency.queue.Queue, outbound_queue: agency.queue.Queue, started: agency.processor._EventProtocol, stopping: agency.processor._EventProtocol, new_message_event: agency.processor._EventProtocol, executor: concurrent.futures._base.Executor) View Source 32 def __init__(self, 33 agent_type: Type[Agent], 34 agent_id: str, 35 agent_args: List, 36 agent_kwargs: Dict, 37 inbound_queue: Queue, 38 outbound_queue: Queue, 39 started: _EventProtocol, 40 stopping: _EventProtocol, 41 new_message_event: _EventProtocol, 42 executor: Executor): 43 self.agent_type: Type[Agent] = agent_type 44 self.agent_id: str = agent_id 45 self.agent_args: List = agent_args 46 self.agent_kwargs: Dict = agent_kwargs 47 self.inbound_queue: Queue = inbound_queue 48 self.outbound_queue: Queue = outbound_queue 49 self.started: _EventProtocol = started 50 self.stopping: _EventProtocol = stopping 51 self.new_message_event: _EventProtocol = new_message_event 52 self.executor: Executor = executor 53 # --- non-constructor properties --- 54 self._future: Future = None 55 self._agent: Agent = None # Accessible if in foreground . agent_type: Type[agency.agent.Agent] agent_id: str agent_args: List agent_kwargs: Dict inbound_queue: agency.queue.Queue outbound_queue: agency.queue.Queue started: agency.processor._EventProtocol stopping: agency.processor._EventProtocol new_message_event: agency.processor._EventProtocol executor: concurrent.futures._base.Executor def start(self) -> agency.agent.Agent: View Source 57 def start(self) -&gt; Agent: 58 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor starting ...&quot;) 59 60 agent_ref: List = [] 61 self._future = self.executor.submit( 62 _process_loop, 63 self.agent_type, 64 self.agent_id, 65 self.agent_args, 66 self.agent_kwargs, 67 self.inbound_queue, 68 self.outbound_queue, 69 self.started, 70 self.stopping, 71 self.new_message_event, 72 agent_ref, 73 ) 74 75 if not self.started.wait(timeout=5): 76 # it couldn&#39;t start, force stop it and raise an exception 77 self.stop() 78 error = self._future.exception() 79 if error is not None: 80 raise error 81 else: 82 raise Exception(&quot;Processor could not be started.&quot;) 83 84 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor started&quot;) 85 86 # return the agent if present. only works in foreground 87 if agent_ref: 88 return agent_ref[0] . def stop(self): View Source 90 def stop(self): 91 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopping ...&quot;) 92 self.stopping.set() 93 if self._future is not None: 94 self._future.result() 95 log(&quot;debug&quot;, f&quot;{self.agent_id}: processor stopped&quot;) . ",
    "url": "/api_docs/agency/processor.html",
    
    "relUrl": "/api_docs/agency/processor.html"
  },"37": {
    "doc": "agency.processor",
    "title": "agency.processor",
    "content": " ",
    "url": "/api_docs/agency/processor.html",
    
    "relUrl": "/api_docs/agency/processor.html"
  },"38": {
    "doc": "agency.queue",
    "title": "\nagency.queue    ",
    "content": "View Source 1from abc import ABC, ABCMeta, abstractmethod 2 3from agency.schema import Message 4 5 6class Queue(ABC, metaclass=ABCMeta): 7 &quot;&quot;&quot; 8 Encapsulates a queue intended to be used for communication 9 &quot;&quot;&quot; 10 11 def connect(self) -&gt; None: 12 &quot;&quot;&quot; 13 Connects to the queue 14 15 This method is called before the queue is first accessed and establishes 16 a connection if necessary. 17 &quot;&quot;&quot; 18 19 def disconnect(self) -&gt; None: 20 &quot;&quot;&quot; 21 Disconnects from the queue 22 23 This method is called after the queue will no longer be accessed and 24 closes a connection if necessary. 25 &quot;&quot;&quot; 26 27 @abstractmethod 28 def put(self, message: Message): 29 &quot;&quot;&quot; 30 Put a message onto the queue for sending 31 32 Args: 33 message: The message 34 &quot;&quot;&quot; 35 36 @abstractmethod 37 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 38 &quot;&quot;&quot; 39 Get the next message from the queue 40 41 Args: 42 block: Whether to block 43 timeout: The timeout 44 45 Returns: 46 The next message 47 48 Raises: 49 queue.Empty: If there are no messages 50 &quot;&quot;&quot; . class Queue(abc.ABC): View Source 7class Queue(ABC, metaclass=ABCMeta): 8 &quot;&quot;&quot; 9 Encapsulates a queue intended to be used for communication 10 &quot;&quot;&quot; 11 12 def connect(self) -&gt; None: 13 &quot;&quot;&quot; 14 Connects to the queue 15 16 This method is called before the queue is first accessed and establishes 17 a connection if necessary. 18 &quot;&quot;&quot; 19 20 def disconnect(self) -&gt; None: 21 &quot;&quot;&quot; 22 Disconnects from the queue 23 24 This method is called after the queue will no longer be accessed and 25 closes a connection if necessary. 26 &quot;&quot;&quot; 27 28 @abstractmethod 29 def put(self, message: Message): 30 &quot;&quot;&quot; 31 Put a message onto the queue for sending 32 33 Args: 34 message: The message 35 &quot;&quot;&quot; 36 37 @abstractmethod 38 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 39 &quot;&quot;&quot; 40 Get the next message from the queue 41 42 Args: 43 block: Whether to block 44 timeout: The timeout 45 46 Returns: 47 The next message 48 49 Raises: 50 queue.Empty: If there are no messages 51 &quot;&quot;&quot; . Encapsulates a queue intended to be used for communication . def connect(self) -> None: View Source 12 def connect(self) -&gt; None: 13 &quot;&quot;&quot; 14 Connects to the queue 15 16 This method is called before the queue is first accessed and establishes 17 a connection if necessary. 18 &quot;&quot;&quot; . Connects to the queue . This method is called before the queue is first accessed and establishes a connection if necessary. def disconnect(self) -> None: View Source 20 def disconnect(self) -&gt; None: 21 &quot;&quot;&quot; 22 Disconnects from the queue 23 24 This method is called after the queue will no longer be accessed and 25 closes a connection if necessary. 26 &quot;&quot;&quot; . Disconnects from the queue . This method is called after the queue will no longer be accessed and closes a connection if necessary. @abstractmethod def put(self, message: agency.schema.Message): View Source 28 @abstractmethod 29 def put(self, message: Message): 30 &quot;&quot;&quot; 31 Put a message onto the queue for sending 32 33 Args: 34 message: The message 35 &quot;&quot;&quot; . Put a message onto the queue for sending . Arguments: . | message: The message | . @abstractmethod def get(self, block: bool = True, timeout: float = None) -> agency.schema.Message: View Source 37 @abstractmethod 38 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 39 &quot;&quot;&quot; 40 Get the next message from the queue 41 42 Args: 43 block: Whether to block 44 timeout: The timeout 45 46 Returns: 47 The next message 48 49 Raises: 50 queue.Empty: If there are no messages 51 &quot;&quot;&quot; . Get the next message from the queue . Arguments: . | block: Whether to block | timeout: The timeout | . Returns: . The next message . Raises: . | queue.Empty: If there are no messages | . ",
    "url": "/api_docs/agency/queue.html",
    
    "relUrl": "/api_docs/agency/queue.html"
  },"39": {
    "doc": "agency.queue",
    "title": "agency.queue",
    "content": " ",
    "url": "/api_docs/agency/queue.html",
    
    "relUrl": "/api_docs/agency/queue.html"
  },"40": {
    "doc": "agency.resources",
    "title": "\nagency.resources    ",
    "content": "View Source 1import multiprocessing 2from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor 3 4 5class ResourceManager: 6 &quot;&quot;&quot; 7 Singleton for globally managing concurrency primitives 8 &quot;&quot;&quot; 9 _instance = None 10 _initialized = False 11 12 def __new__(cls, *args, **kwargs): 13 if cls._instance is None: 14 cls._instance = super(ResourceManager, cls).__new__(cls) 15 return cls._instance 16 17 def __init__(self, max_workers=None): 18 if not self._initialized: 19 self._max_workers = max_workers 20 self.thread_pool_executor = ThreadPoolExecutor(self._max_workers) 21 self.process_pool_executor = ProcessPoolExecutor(self._max_workers) 22 self.multiprocessing_manager = multiprocessing.Manager() 23 self._initialized = True . class ResourceManager: View Source 6class ResourceManager: 7 &quot;&quot;&quot; 8 Singleton for globally managing concurrency primitives 9 &quot;&quot;&quot; 10 _instance = None 11 _initialized = False 12 13 def __new__(cls, *args, **kwargs): 14 if cls._instance is None: 15 cls._instance = super(ResourceManager, cls).__new__(cls) 16 return cls._instance 17 18 def __init__(self, max_workers=None): 19 if not self._initialized: 20 self._max_workers = max_workers 21 self.thread_pool_executor = ThreadPoolExecutor(self._max_workers) 22 self.process_pool_executor = ProcessPoolExecutor(self._max_workers) 23 self.multiprocessing_manager = multiprocessing.Manager() 24 self._initialized = True . Singleton for globally managing concurrency primitives . ResourceManager(max_workers=None) View Source 18 def __init__(self, max_workers=None): 19 if not self._initialized: 20 self._max_workers = max_workers 21 self.thread_pool_executor = ThreadPoolExecutor(self._max_workers) 22 self.process_pool_executor = ProcessPoolExecutor(self._max_workers) 23 self.multiprocessing_manager = multiprocessing.Manager() 24 self._initialized = True . ",
    "url": "/api_docs/agency/resources.html",
    
    "relUrl": "/api_docs/agency/resources.html"
  },"41": {
    "doc": "agency.resources",
    "title": "agency.resources",
    "content": " ",
    "url": "/api_docs/agency/resources.html",
    
    "relUrl": "/api_docs/agency/resources.html"
  },"42": {
    "doc": "agency.schema",
    "title": "\nagency.schema    ",
    "content": "View Source 1from typing import Dict, Optional 2 3from pydantic import BaseModel, Field 4 5 6class Meta(BaseModel): 7 &quot;&quot;&quot;A dictionary field for storing metadata about the message&quot;&quot;&quot; 8 9 class Config: 10 extra = &quot;allow&quot; 11 validate_assignment = True 12 13 id: str = Field( 14 ..., 15 description=&quot;The id of the message.&quot; 16 ) 17 18 parent_id: Optional[str] = Field( 19 None, 20 description=&quot;The id of the previous message that generated this message.&quot; 21 ) 22 23 24class Action(BaseModel): 25 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 26 27 class Config: 28 extra = &quot;forbid&quot; 29 validate_assignment = True 30 31 name: str = Field( 32 ..., 33 description=&quot;The name of the action.&quot; 34 ) 35 36 args: Optional[Dict] = Field( 37 None, 38 description=&quot;The arguments for the action.&quot; 39 ) 40 41 42class Message(BaseModel): 43 &quot;&quot;&quot;The full message schema used for communication&quot;&quot;&quot; 44 45 class Config: 46 extra = &quot;forbid&quot; 47 validate_assignment = True 48 49 meta: Meta 50 51 from_: str = Field( 52 ..., 53 alias=&quot;from&quot;, 54 description=&quot;The id of the sender.&quot; 55 ) 56 57 to: str = Field( 58 ..., 59 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 60 ) 61 62 action: Action . class Meta(pydantic.main.BaseModel): View Source 7class Meta(BaseModel): 8 &quot;&quot;&quot;A dictionary field for storing metadata about the message&quot;&quot;&quot; 9 10 class Config: 11 extra = &quot;allow&quot; 12 validate_assignment = True 13 14 id: str = Field( 15 ..., 16 description=&quot;The id of the message.&quot; 17 ) 18 19 parent_id: Optional[str] = Field( 20 None, 21 description=&quot;The id of the previous message that generated this message.&quot; 22 ) . A dictionary field for storing metadata about the message . id: str parent_id: Optional[str] model_config = {&#39;extra&#39;: &#39;allow&#39;, &#39;validate_assignment&#39;: True} model_fields = {&#39;id&#39;: FieldInfo(annotation=str, required=True, description=&#39;The id of the message.&#39;), &#39;parent_id&#39;: FieldInfo(annotation=Union[str, NoneType], required=False, description=&#39;The id of the previous message that generated this message.&#39;)} Inherited Members . pydantic.main.BaseModel BaseModel model_computed_fields model_extra model_fields_set model_construct model_copy model_dump model_dump_json model_json_schema model_parametrized_name model_post_init model_rebuild model_validate model_validate_json model_validate_strings dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Meta.Config: View Source 10 class Config: 11 extra = &quot;allow&quot; 12 validate_assignment = True . extra = &#39;allow&#39; validate_assignment = True class Action(pydantic.main.BaseModel): View Source 25class Action(BaseModel): 26 &quot;&quot;&quot;Schema for an action&quot;&quot;&quot; 27 28 class Config: 29 extra = &quot;forbid&quot; 30 validate_assignment = True 31 32 name: str = Field( 33 ..., 34 description=&quot;The name of the action.&quot; 35 ) 36 37 args: Optional[Dict] = Field( 38 None, 39 description=&quot;The arguments for the action.&quot; 40 ) . Schema for an action . name: str args: Optional[Dict] model_config = {&#39;extra&#39;: &#39;forbid&#39;, &#39;validate_assignment&#39;: True} model_fields = {&#39;name&#39;: FieldInfo(annotation=str, required=True, description=&#39;The name of the action.&#39;), &#39;args&#39;: FieldInfo(annotation=Union[Dict, NoneType], required=False, description=&#39;The arguments for the action.&#39;)} Inherited Members . pydantic.main.BaseModel BaseModel model_computed_fields model_extra model_fields_set model_construct model_copy model_dump model_dump_json model_json_schema model_parametrized_name model_post_init model_rebuild model_validate model_validate_json model_validate_strings dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Action.Config: View Source 28 class Config: 29 extra = &quot;forbid&quot; 30 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True class Message(pydantic.main.BaseModel): View Source 43class Message(BaseModel): 44 &quot;&quot;&quot;The full message schema used for communication&quot;&quot;&quot; 45 46 class Config: 47 extra = &quot;forbid&quot; 48 validate_assignment = True 49 50 meta: Meta 51 52 from_: str = Field( 53 ..., 54 alias=&quot;from&quot;, 55 description=&quot;The id of the sender.&quot; 56 ) 57 58 to: str = Field( 59 ..., 60 description=&quot;The intended recipient of the message. If set to `*`, the message is broadcast.&quot; 61 ) 62 63 action: Action . The full message schema used for communication . meta: Meta from_: str to: str action: Action model_config = {&#39;extra&#39;: &#39;forbid&#39;, &#39;validate_assignment&#39;: True} model_fields = {&#39;meta&#39;: FieldInfo(annotation=Meta, required=True), &#39;from_&#39;: FieldInfo(annotation=str, required=True, alias=&#39;from&#39;, alias_priority=2, description=&#39;The id of the sender.&#39;), &#39;to&#39;: FieldInfo(annotation=str, required=True, description=&#39;The intended recipient of the message. If set to `*`, the message is broadcast.&#39;), &#39;action&#39;: FieldInfo(annotation=Action, required=True)} Inherited Members . pydantic.main.BaseModel BaseModel model_computed_fields model_extra model_fields_set model_construct model_copy model_dump model_dump_json model_json_schema model_parametrized_name model_post_init model_rebuild model_validate model_validate_json model_validate_strings dict json parse_obj parse_raw parse_file from_orm construct copy schema schema_json validate update_forward_refs class Message.Config: View Source 46 class Config: 47 extra = &quot;forbid&quot; 48 validate_assignment = True . extra = &#39;forbid&#39; validate_assignment = True ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"43": {
    "doc": "agency.schema",
    "title": "agency.schema",
    "content": " ",
    "url": "/api_docs/agency/schema.html",
    
    "relUrl": "/api_docs/agency/schema.html"
  },"44": {
    "doc": "agency.space",
    "title": "\nagency.space    ",
    "content": "View Source 1import threading 2from abc import ABC, ABCMeta, abstractmethod 3from concurrent.futures import Executor 4from typing import Dict, List, Type 5 6from agency.agent import Agent 7from agency.logger import log 8from agency.processor import Processor, _EventProtocol 9from agency.queue import Queue 10from agency.resources import ResourceManager 11 12 13class Space(ABC, metaclass=ABCMeta): 14 &quot;&quot;&quot; 15 A Space is where Agents communicate. 16 &quot;&quot;&quot; 17 18 def __init__(self): 19 self.processors: Dict[str, Processor] = {} 20 self._processors_lock: threading.Lock = threading.Lock() 21 22 def __enter__(self): 23 log(&quot;debug&quot;, &quot;Entering Space context&quot;) 24 return self 25 26 def __exit__(self, exc_type, exc_val, exc_tb): 27 if exc_type is not None: 28 log(&quot;debug&quot;, &quot;Exiting Space context with exception&quot;, { 29 &quot;exc_type&quot;: exc_type, 30 &quot;exc_val&quot;: exc_val, 31 &quot;exc_tb&quot;: exc_tb, 32 }) 33 self.destroy() 34 35 def add(self, 36 agent_type: Type[Agent], 37 agent_id: str, 38 *agent_args, 39 **agent_kwargs): 40 &quot;&quot;&quot; 41 Adds an agent to the space allowing it to communicate. 42 43 This method adds the agent in a subprocess. The agent may not be 44 directly accessed from the main thread. 45 46 Args: 47 agent_type: The type of agent to add 48 agent_id: The id of the agent to add 49 50 All other arguments are passed to the Agent constructor 51 52 Raises: 53 ValueError: If the agent ID is already in use 54 &quot;&quot;&quot; 55 self._add(foreground=False, 56 agent_type=agent_type, 57 agent_id=agent_id, 58 *agent_args, 59 **agent_kwargs) 60 61 def add_foreground(self, 62 agent_type: Type[Agent], 63 agent_id: str, 64 *agent_args, 65 **agent_kwargs) -&gt; Agent: 66 &quot;&quot;&quot; 67 Adds an agent to the space and returns it in the current thread. 68 69 This method adds an agent using threading. The agent instance is 70 returned allowing direct access. 71 72 It is recommended to use the `add` method instead of this method in most 73 cases. Agents added this way may block other agents or threads in the 74 main process. Use this method when direct access to the agent instance 75 is desired. 76 77 Args: 78 agent_type: The type of agent to add 79 agent_id: The id of the agent to add 80 81 All other arguments are passed to the Agent constructor 82 83 Returns: 84 The agent 85 86 Raises: 87 ValueError: If the agent ID is already in use 88 &quot;&quot;&quot; 89 agent = self._add(foreground=True, 90 agent_type=agent_type, 91 agent_id=agent_id, 92 *agent_args, 93 **agent_kwargs) 94 return agent 95 96 def remove(self, agent_id: str): 97 &quot;&quot;&quot; 98 Removes an agent from the space by id. 99 100 This method cannot remove an agent added from a different instance. In 101 other words, a Space instance cannot remove an agent that it did not 102 add. 103 104 Args: 105 agent_id: The id of the agent to remove 106 107 Raises: 108 ValueError: If the agent is not present in the space 109 &quot;&quot;&quot; 110 self._stop_processor(agent_id) 111 log(&quot;info&quot;, f&quot;{agent_id}: removed from space&quot;) 112 113 def destroy(self): 114 &quot;&quot;&quot; 115 Cleans up resources used by this space. 116 117 Subclasses should call super().destroy() when overriding. 118 &quot;&quot;&quot; 119 self._stop_all_processors() 120 121 def _add(self, 122 foreground: bool, 123 agent_type: Type[Agent], 124 agent_id: str, 125 *agent_args, 126 **agent_kwargs) -&gt; Agent: 127 128 try: 129 agent = self._start_processor( 130 foreground=foreground, 131 agent_type=agent_type, 132 agent_id=agent_id, 133 agent_args=agent_args, 134 agent_kwargs=agent_kwargs, 135 ) 136 log(&quot;info&quot;, f&quot;{agent_id}: added to space&quot;) 137 return agent 138 except: 139 # clean up if an error occurs 140 self.remove(agent_id) 141 raise 142 143 def _start_processor(self, 144 foreground: bool, 145 agent_type: Type[Agent], 146 agent_id: str, 147 agent_args: List, 148 agent_kwargs: Dict): 149 with self._processors_lock: 150 # Early existence check. Processor.start() will also check. This is 151 # because Spaces may be distributed. 152 if agent_id in self.processors.keys(): 153 raise ValueError(f&quot;Agent &#39;{agent_id}&#39; already exists&quot;) 154 155 self.processors[agent_id] = Processor( 156 agent_type=agent_type, 157 agent_id=agent_id, 158 agent_args=agent_args, 159 agent_kwargs=agent_kwargs, 160 inbound_queue=self._create_inbound_queue(agent_id), 161 outbound_queue=self._create_outbound_queue(agent_id), 162 started=self._define_event(foreground=foreground), 163 stopping=self._define_event(foreground=foreground), 164 new_message_event=self._define_event(foreground=foreground), 165 executor=self._get_executor(foreground=foreground), 166 ) 167 return self.processors[agent_id].start() 168 169 def _stop_processor_unsafe(self, agent_id: str): 170 self.processors[agent_id].stop() 171 self.processors.pop(agent_id) 172 173 def _stop_processor(self, agent_id: str): 174 with self._processors_lock: 175 self._stop_processor_unsafe(agent_id) 176 177 def _stop_all_processors(self): 178 for agent_id in list(self.processors.keys()): 179 try: 180 with self._processors_lock: 181 self._stop_processor_unsafe(agent_id) 182 except Exception as e: 183 log(&quot;error&quot;, 184 f&quot;{agent_id}: processor failed to stop&quot;, e) 185 186 def _get_executor(self, foreground: bool = False) -&gt; Executor: 187 if foreground: 188 return ResourceManager().thread_pool_executor 189 else: 190 return ResourceManager().process_pool_executor 191 192 def _define_event(self, foreground: bool = False) -&gt; _EventProtocol: 193 if foreground: 194 return threading.Event() 195 else: 196 return ResourceManager().multiprocessing_manager.Event() 197 198 @abstractmethod 199 def _create_inbound_queue(self, agent_id) -&gt; Queue: 200 &quot;&quot;&quot; 201 Returns a Queue suitable for receiving messages 202 &quot;&quot;&quot; 203 raise NotImplementedError 204 205 @abstractmethod 206 def _create_outbound_queue(self, agent_id) -&gt; Queue: 207 &quot;&quot;&quot; 208 Returns a Queue suitable for sending messages 209 &quot;&quot;&quot; 210 raise NotImplementedError . class Space(abc.ABC): View Source 14class Space(ABC, metaclass=ABCMeta): 15 &quot;&quot;&quot; 16 A Space is where Agents communicate. 17 &quot;&quot;&quot; 18 19 def __init__(self): 20 self.processors: Dict[str, Processor] = {} 21 self._processors_lock: threading.Lock = threading.Lock() 22 23 def __enter__(self): 24 log(&quot;debug&quot;, &quot;Entering Space context&quot;) 25 return self 26 27 def __exit__(self, exc_type, exc_val, exc_tb): 28 if exc_type is not None: 29 log(&quot;debug&quot;, &quot;Exiting Space context with exception&quot;, { 30 &quot;exc_type&quot;: exc_type, 31 &quot;exc_val&quot;: exc_val, 32 &quot;exc_tb&quot;: exc_tb, 33 }) 34 self.destroy() 35 36 def add(self, 37 agent_type: Type[Agent], 38 agent_id: str, 39 *agent_args, 40 **agent_kwargs): 41 &quot;&quot;&quot; 42 Adds an agent to the space allowing it to communicate. 43 44 This method adds the agent in a subprocess. The agent may not be 45 directly accessed from the main thread. 46 47 Args: 48 agent_type: The type of agent to add 49 agent_id: The id of the agent to add 50 51 All other arguments are passed to the Agent constructor 52 53 Raises: 54 ValueError: If the agent ID is already in use 55 &quot;&quot;&quot; 56 self._add(foreground=False, 57 agent_type=agent_type, 58 agent_id=agent_id, 59 *agent_args, 60 **agent_kwargs) 61 62 def add_foreground(self, 63 agent_type: Type[Agent], 64 agent_id: str, 65 *agent_args, 66 **agent_kwargs) -&gt; Agent: 67 &quot;&quot;&quot; 68 Adds an agent to the space and returns it in the current thread. 69 70 This method adds an agent using threading. The agent instance is 71 returned allowing direct access. 72 73 It is recommended to use the `add` method instead of this method in most 74 cases. Agents added this way may block other agents or threads in the 75 main process. Use this method when direct access to the agent instance 76 is desired. 77 78 Args: 79 agent_type: The type of agent to add 80 agent_id: The id of the agent to add 81 82 All other arguments are passed to the Agent constructor 83 84 Returns: 85 The agent 86 87 Raises: 88 ValueError: If the agent ID is already in use 89 &quot;&quot;&quot; 90 agent = self._add(foreground=True, 91 agent_type=agent_type, 92 agent_id=agent_id, 93 *agent_args, 94 **agent_kwargs) 95 return agent 96 97 def remove(self, agent_id: str): 98 &quot;&quot;&quot; 99 Removes an agent from the space by id. 100 101 This method cannot remove an agent added from a different instance. In 102 other words, a Space instance cannot remove an agent that it did not 103 add. 104 105 Args: 106 agent_id: The id of the agent to remove 107 108 Raises: 109 ValueError: If the agent is not present in the space 110 &quot;&quot;&quot; 111 self._stop_processor(agent_id) 112 log(&quot;info&quot;, f&quot;{agent_id}: removed from space&quot;) 113 114 def destroy(self): 115 &quot;&quot;&quot; 116 Cleans up resources used by this space. 117 118 Subclasses should call super().destroy() when overriding. 119 &quot;&quot;&quot; 120 self._stop_all_processors() 121 122 def _add(self, 123 foreground: bool, 124 agent_type: Type[Agent], 125 agent_id: str, 126 *agent_args, 127 **agent_kwargs) -&gt; Agent: 128 129 try: 130 agent = self._start_processor( 131 foreground=foreground, 132 agent_type=agent_type, 133 agent_id=agent_id, 134 agent_args=agent_args, 135 agent_kwargs=agent_kwargs, 136 ) 137 log(&quot;info&quot;, f&quot;{agent_id}: added to space&quot;) 138 return agent 139 except: 140 # clean up if an error occurs 141 self.remove(agent_id) 142 raise 143 144 def _start_processor(self, 145 foreground: bool, 146 agent_type: Type[Agent], 147 agent_id: str, 148 agent_args: List, 149 agent_kwargs: Dict): 150 with self._processors_lock: 151 # Early existence check. Processor.start() will also check. This is 152 # because Spaces may be distributed. 153 if agent_id in self.processors.keys(): 154 raise ValueError(f&quot;Agent &#39;{agent_id}&#39; already exists&quot;) 155 156 self.processors[agent_id] = Processor( 157 agent_type=agent_type, 158 agent_id=agent_id, 159 agent_args=agent_args, 160 agent_kwargs=agent_kwargs, 161 inbound_queue=self._create_inbound_queue(agent_id), 162 outbound_queue=self._create_outbound_queue(agent_id), 163 started=self._define_event(foreground=foreground), 164 stopping=self._define_event(foreground=foreground), 165 new_message_event=self._define_event(foreground=foreground), 166 executor=self._get_executor(foreground=foreground), 167 ) 168 return self.processors[agent_id].start() 169 170 def _stop_processor_unsafe(self, agent_id: str): 171 self.processors[agent_id].stop() 172 self.processors.pop(agent_id) 173 174 def _stop_processor(self, agent_id: str): 175 with self._processors_lock: 176 self._stop_processor_unsafe(agent_id) 177 178 def _stop_all_processors(self): 179 for agent_id in list(self.processors.keys()): 180 try: 181 with self._processors_lock: 182 self._stop_processor_unsafe(agent_id) 183 except Exception as e: 184 log(&quot;error&quot;, 185 f&quot;{agent_id}: processor failed to stop&quot;, e) 186 187 def _get_executor(self, foreground: bool = False) -&gt; Executor: 188 if foreground: 189 return ResourceManager().thread_pool_executor 190 else: 191 return ResourceManager().process_pool_executor 192 193 def _define_event(self, foreground: bool = False) -&gt; _EventProtocol: 194 if foreground: 195 return threading.Event() 196 else: 197 return ResourceManager().multiprocessing_manager.Event() 198 199 @abstractmethod 200 def _create_inbound_queue(self, agent_id) -&gt; Queue: 201 &quot;&quot;&quot; 202 Returns a Queue suitable for receiving messages 203 &quot;&quot;&quot; 204 raise NotImplementedError 205 206 @abstractmethod 207 def _create_outbound_queue(self, agent_id) -&gt; Queue: 208 &quot;&quot;&quot; 209 Returns a Queue suitable for sending messages 210 &quot;&quot;&quot; 211 raise NotImplementedError . A Space is where Agents communicate. processors: Dict[str, agency.processor.Processor] def add( self, agent_type: Type[agency.agent.Agent], agent_id: str, *agent_args, **agent_kwargs): View Source 36 def add(self, 37 agent_type: Type[Agent], 38 agent_id: str, 39 *agent_args, 40 **agent_kwargs): 41 &quot;&quot;&quot; 42 Adds an agent to the space allowing it to communicate. 43 44 This method adds the agent in a subprocess. The agent may not be 45 directly accessed from the main thread. 46 47 Args: 48 agent_type: The type of agent to add 49 agent_id: The id of the agent to add 50 51 All other arguments are passed to the Agent constructor 52 53 Raises: 54 ValueError: If the agent ID is already in use 55 &quot;&quot;&quot; 56 self._add(foreground=False, 57 agent_type=agent_type, 58 agent_id=agent_id, 59 *agent_args, 60 **agent_kwargs) . Adds an agent to the space allowing it to communicate. This method adds the agent in a subprocess. The agent may not be directly accessed from the main thread. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | All other arguments are passed to the Agent constructor | . Raises: . | ValueError: If the agent ID is already in use | . def add_foreground( self, agent_type: Type[agency.agent.Agent], agent_id: str, *agent_args, **agent_kwargs) -> agency.agent.Agent: View Source 62 def add_foreground(self, 63 agent_type: Type[Agent], 64 agent_id: str, 65 *agent_args, 66 **agent_kwargs) -&gt; Agent: 67 &quot;&quot;&quot; 68 Adds an agent to the space and returns it in the current thread. 69 70 This method adds an agent using threading. The agent instance is 71 returned allowing direct access. 72 73 It is recommended to use the `add` method instead of this method in most 74 cases. Agents added this way may block other agents or threads in the 75 main process. Use this method when direct access to the agent instance 76 is desired. 77 78 Args: 79 agent_type: The type of agent to add 80 agent_id: The id of the agent to add 81 82 All other arguments are passed to the Agent constructor 83 84 Returns: 85 The agent 86 87 Raises: 88 ValueError: If the agent ID is already in use 89 &quot;&quot;&quot; 90 agent = self._add(foreground=True, 91 agent_type=agent_type, 92 agent_id=agent_id, 93 *agent_args, 94 **agent_kwargs) 95 return agent . Adds an agent to the space and returns it in the current thread. This method adds an agent using threading. The agent instance is returned allowing direct access. It is recommended to use the add method instead of this method in most cases. Agents added this way may block other agents or threads in the main process. Use this method when direct access to the agent instance is desired. Arguments: . | agent_type: The type of agent to add | agent_id: The id of the agent to add | All other arguments are passed to the Agent constructor | . Returns: . The agent . Raises: . | ValueError: If the agent ID is already in use | . def remove(self, agent_id: str): View Source 97 def remove(self, agent_id: str): 98 &quot;&quot;&quot; 99 Removes an agent from the space by id. 100 101 This method cannot remove an agent added from a different instance. In 102 other words, a Space instance cannot remove an agent that it did not 103 add. 104 105 Args: 106 agent_id: The id of the agent to remove 107 108 Raises: 109 ValueError: If the agent is not present in the space 110 &quot;&quot;&quot; 111 self._stop_processor(agent_id) 112 log(&quot;info&quot;, f&quot;{agent_id}: removed from space&quot;) . Removes an agent from the space by id. This method cannot remove an agent added from a different instance. In other words, a Space instance cannot remove an agent that it did not add. Arguments: . | agent_id: The id of the agent to remove | . Raises: . | ValueError: If the agent is not present in the space | . def destroy(self): View Source 114 def destroy(self): 115 &quot;&quot;&quot; 116 Cleans up resources used by this space. 117 118 Subclasses should call super().destroy() when overriding. 119 &quot;&quot;&quot; 120 self._stop_all_processors() . Cleans up resources used by this space. Subclasses should call super().destroy() when overriding. ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"45": {
    "doc": "agency.space",
    "title": "agency.space",
    "content": " ",
    "url": "/api_docs/agency/space.html",
    
    "relUrl": "/api_docs/agency/space.html"
  },"46": {
    "doc": "agency.spaces",
    "title": "\nagency.spaces    ",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"47": {
    "doc": "agency.spaces",
    "title": "Submodules",
    "content": ". | amqp_space | local_space | . ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"48": {
    "doc": "agency.spaces",
    "title": "agency.spaces",
    "content": " ",
    "url": "/api_docs/agency/spaces.html",
    
    "relUrl": "/api_docs/agency/spaces.html"
  },"49": {
    "doc": "agency.spaces.amqp_space",
    "title": "\nagency.spaces.amqp_space    ",
    "content": "View Source 1import json 2import os 3import queue 4import socket 5import threading 6import time 7from concurrent.futures import Future 8from dataclasses import dataclass 9 10import amqp 11import kombu 12 13from agency.logger import log 14from agency.queue import Queue 15from agency.resources import ResourceManager 16from agency.schema import Message 17from agency.space import Space 18 19_BROADCAST_KEY = &quot;__broadcast__&quot; 20 21@dataclass 22class AMQPOptions: 23 &quot;&quot;&quot;A class that defines AMQP connection options&quot;&quot;&quot; 24 hostname: str = &#39;localhost&#39; 25 port: int = &#39;5672&#39; 26 username: str = &#39;guest&#39; 27 password: str = &#39;guest&#39; 28 virtual_host: str = &#39;/&#39; 29 use_ssl: bool = False 30 heartbeat: float = 60 31 32 33class _AMQPQueue(Queue): 34 &quot;&quot;&quot;An AMQP based Queue using the kombu library&quot;&quot;&quot; 35 36 def __init__(self, amqp_options: AMQPOptions, exchange_name: str, routing_key: str): 37 self.kombu_connection_options = { 38 &#39;hostname&#39;: amqp_options.hostname, 39 &#39;port&#39;: amqp_options.port, 40 &#39;userid&#39;: amqp_options.username, 41 &#39;password&#39;: amqp_options.password, 42 &#39;virtual_host&#39;: amqp_options.virtual_host, 43 &#39;ssl&#39;: amqp_options.use_ssl, 44 &#39;heartbeat&#39;: amqp_options.heartbeat, 45 } 46 self.exchange_name: str = exchange_name 47 self.routing_key: str = routing_key 48 49 50class _AMQPInboundQueue(_AMQPQueue): 51 52 def __init__(self, amqp_options: AMQPOptions, exchange_name: str, routing_key: str): 53 super().__init__(amqp_options, exchange_name, routing_key) 54 self._connection: kombu.Connection = None 55 self._exchange: kombu.Exchange = None 56 self._direct_queue: kombu.Queue = None 57 self._broadcast_queue: kombu.Queue = None 58 self._heartbeat_future: Future = None 59 self._received_queue: queue.Queue = None 60 self._disconnecting: threading.Event = None 61 62 def connect(self): 63 log(&quot;debug&quot;, f&quot;{self.routing_key}: connecting&quot;) 64 65 self._received_queue = queue.Queue() 66 67 def _callback(body, amqp_message): 68 amqp_message.ack() 69 self._received_queue.put(json.loads(body)) 70 71 try: 72 self._connection = kombu.Connection( 73 **self.kombu_connection_options) 74 self._connection.connect() 75 self._exchange = kombu.Exchange( 76 self.exchange_name, &#39;topic&#39;, durable=True) 77 self._direct_queue = kombu.Queue( 78 self.routing_key, 79 exchange=self._exchange, 80 routing_key=self.routing_key, 81 exclusive=True) 82 self._broadcast_queue = kombu.Queue( 83 f&quot;{self.routing_key}-broadcast&quot;, 84 exchange=self._exchange, 85 routing_key=_BROADCAST_KEY, 86 exclusive=True) 87 self._consumer = kombu.Consumer( 88 self._connection, 89 [self._direct_queue, self._broadcast_queue], 90 callbacks=[_callback]) 91 self._consumer.consume() 92 except amqp.exceptions.ResourceLocked: 93 raise ValueError(f&quot;Agent &#39;{self.routing_key}&#39; already exists&quot;) 94 95 # start heartbeat thread 96 def _heartbeat_thread(disconnecting): 97 log(&quot;debug&quot;, f&quot;{self.routing_key}: heartbeat thread starting&quot;) 98 try: 99 while not disconnecting.is_set(): 100 try: 101 self._connection.heartbeat_check() 102 self._connection.drain_events(timeout=0.2) 103 time.sleep(0.1) 104 except socket.timeout: 105 pass 106 except amqp.exceptions.ConnectionForced: 107 log(&quot;warning&quot;, 108 f&quot;{self.routing_key}: heartbeat connection force closed&quot;) 109 log(&quot;debug&quot;, f&quot;{self.routing_key}: heartbeat thread stopped&quot;) 110 self._disconnecting = threading.Event() 111 self._disconnecting.clear() 112 self._heartbeat_future = ResourceManager( 113 ).thread_pool_executor.submit(_heartbeat_thread, self._disconnecting) 114 115 log(&quot;debug&quot;, f&quot;{self.routing_key}: connected&quot;) 116 117 def disconnect(self): 118 log(&quot;debug&quot;, f&quot;{self.routing_key}: disconnecting&quot;) 119 if self._disconnecting: 120 self._disconnecting.set() 121 try: 122 if self._heartbeat_future is not None: 123 self._heartbeat_future.result(timeout=5) 124 finally: 125 if self._connection: 126 self._connection.close() 127 log(&quot;debug&quot;, f&quot;{self.routing_key}: disconnected&quot;) 128 129 def put(self, message: Message): 130 raise NotImplementedError(&quot;AMQPInboundQueue does not support put&quot;) 131 132 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 133 message = self._received_queue.get(block=block, timeout=timeout) 134 return message 135 136 137class _AMQPOutboundQueue(_AMQPQueue): 138 139 def __init__(self, amqp_options: AMQPOptions, exchange_name: str, routing_key: str): 140 super().__init__(amqp_options, exchange_name, routing_key) 141 self._exchange: kombu.Exchange = None 142 143 def connect(self): 144 self._exchange = kombu.Exchange( 145 self.exchange_name, &#39;topic&#39;, durable=True) 146 147 def put(self, message: Message): 148 with kombu.Connection(**self.kombu_connection_options) as connection: 149 with connection.Producer() as producer: 150 if message[&#39;to&#39;] == &#39;*&#39;: 151 producer.publish( 152 json.dumps(message), 153 exchange=self._exchange, 154 routing_key=_BROADCAST_KEY, 155 ) 156 else: 157 producer.publish( 158 json.dumps(message), 159 exchange=self._exchange, 160 routing_key=message[&#39;to&#39;], 161 ) 162 163 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 164 raise NotImplementedError(&quot;AMQPOutboundQueue does not support get&quot;) 165 166 167class AMQPSpace(Space): 168 &quot;&quot;&quot; 169 A Space that uses AMQP for message delivery. 170 171 This Space type is useful for distributing agents across multiple hosts. 172 &quot;&quot;&quot; 173 174 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 175 super().__init__() 176 if amqp_options is None: 177 amqp_options = self.__default_amqp_options() 178 self.amqp_options = amqp_options 179 self.exchange_name = exchange_name 180 181 def __default_amqp_options(self) -&gt; AMQPOptions: 182 &quot;&quot;&quot; 183 Returns a default AMQPOptions object configurable from environment 184 variables. 185 &quot;&quot;&quot; 186 # TODO add support for AMQP_URL 187 return AMQPOptions( 188 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 189 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 190 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 191 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 192 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 193 use_ssl=False, 194 heartbeat=60, 195 ) 196 197 def _create_inbound_queue(self, agent_id) -&gt; Queue: 198 return _AMQPInboundQueue( 199 amqp_options=self.amqp_options, 200 exchange_name=self.exchange_name, 201 routing_key=agent_id, 202 ) 203 204 def _create_outbound_queue(self, agent_id) -&gt; Queue: 205 return _AMQPOutboundQueue( 206 amqp_options=self.amqp_options, 207 exchange_name=self.exchange_name, 208 routing_key=agent_id, 209 ) . @dataclass class AMQPOptions: View Source 22@dataclass 23class AMQPOptions: 24 &quot;&quot;&quot;A class that defines AMQP connection options&quot;&quot;&quot; 25 hostname: str = &#39;localhost&#39; 26 port: int = &#39;5672&#39; 27 username: str = &#39;guest&#39; 28 password: str = &#39;guest&#39; 29 virtual_host: str = &#39;/&#39; 30 use_ssl: bool = False 31 heartbeat: float = 60 . A class that defines AMQP connection options . AMQPOptions( hostname: str = &#39;localhost&#39;, port: int = &#39;5672&#39;, username: str = &#39;guest&#39;, password: str = &#39;guest&#39;, virtual_host: str = &#39;/&#39;, use_ssl: bool = False, heartbeat: float = 60) hostname: str = &#39;localhost&#39; port: int = &#39;5672&#39; username: str = &#39;guest&#39; password: str = &#39;guest&#39; virtual_host: str = &#39;/&#39; use_ssl: bool = False heartbeat: float = 60 class AMQPSpace(agency.space.Space): View Source 168class AMQPSpace(Space): 169 &quot;&quot;&quot; 170 A Space that uses AMQP for message delivery. 171 172 This Space type is useful for distributing agents across multiple hosts. 173 &quot;&quot;&quot; 174 175 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 176 super().__init__() 177 if amqp_options is None: 178 amqp_options = self.__default_amqp_options() 179 self.amqp_options = amqp_options 180 self.exchange_name = exchange_name 181 182 def __default_amqp_options(self) -&gt; AMQPOptions: 183 &quot;&quot;&quot; 184 Returns a default AMQPOptions object configurable from environment 185 variables. 186 &quot;&quot;&quot; 187 # TODO add support for AMQP_URL 188 return AMQPOptions( 189 hostname=os.environ.get(&#39;AMQP_HOST&#39;, &#39;localhost&#39;), 190 port=int(os.environ.get(&#39;AMQP_PORT&#39;, 5672)), 191 username=os.environ.get(&#39;AMQP_USERNAME&#39;, &#39;guest&#39;), 192 password=os.environ.get(&#39;AMQP_PASSWORD&#39;, &#39;guest&#39;), 193 virtual_host=os.environ.get(&#39;AMQP_VHOST&#39;, &#39;/&#39;), 194 use_ssl=False, 195 heartbeat=60, 196 ) 197 198 def _create_inbound_queue(self, agent_id) -&gt; Queue: 199 return _AMQPInboundQueue( 200 amqp_options=self.amqp_options, 201 exchange_name=self.exchange_name, 202 routing_key=agent_id, 203 ) 204 205 def _create_outbound_queue(self, agent_id) -&gt; Queue: 206 return _AMQPOutboundQueue( 207 amqp_options=self.amqp_options, 208 exchange_name=self.exchange_name, 209 routing_key=agent_id, 210 ) . A Space that uses AMQP for message delivery. This Space type is useful for distributing agents across multiple hosts. AMQPSpace( amqp_options: AMQPOptions = None, exchange_name: str = &#39;agency&#39;) View Source 175 def __init__(self, amqp_options: AMQPOptions = None, exchange_name: str = &quot;agency&quot;): 176 super().__init__() 177 if amqp_options is None: 178 amqp_options = self.__default_amqp_options() 179 self.amqp_options = amqp_options 180 self.exchange_name = exchange_name . amqp_options exchange_name Inherited Members . agency.space.Space processors add add_foreground remove destroy ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"50": {
    "doc": "agency.spaces.amqp_space",
    "title": "agency.spaces.amqp_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/amqp_space.html",
    
    "relUrl": "/api_docs/agency/spaces/amqp_space.html"
  },"51": {
    "doc": "agency.spaces.local_space",
    "title": "\nagency.spaces.local_space    ",
    "content": "View Source 1import multiprocessing 2import queue 3import threading 4from concurrent.futures import Future 5 6from agency.logger import log 7from agency.queue import Queue 8from agency.resources import ResourceManager 9from agency.schema import Message 10from agency.space import Space 11 12 13class _LocalQueue(Queue): 14 &quot;&quot;&quot;A multiprocessing based implementation of Queue&quot;&quot;&quot; 15 16 def __init__(self, outbound_message_event: multiprocessing.Event = None): 17 self.outbound_message_event = outbound_message_event 18 self._queue = ResourceManager().multiprocessing_manager.Queue() 19 20 def put(self, message: Message): 21 self._queue.put(message) 22 if self.outbound_message_event is not None: 23 self.outbound_message_event.set() 24 25 def get(self, block: bool = True, timeout: float = None) -&gt; Message: 26 return self._queue.get(block=block, timeout=timeout) 27 28 29class LocalSpace(Space): 30 &quot;&quot;&quot; 31 A LocalSpace allows Agents to communicate within the python application 32 &quot;&quot;&quot; 33 34 def __init__(self, max_workers=None): 35 super().__init__() 36 self._stop_router_event: threading.Event = threading.Event() 37 self._outbound_message_event: multiprocessing.Event = ResourceManager(max_workers 38 ).multiprocessing_manager.Event() 39 self._router_future: Future = self._start_router_thread() 40 41 def destroy(self): 42 self._stop_router_thread() 43 super().destroy() 44 45 def _start_router_thread(self): 46 def _router_thread(): 47 &quot;&quot;&quot;Routes outbound messages&quot;&quot;&quot; 48 log(&quot;debug&quot;, &quot;LocalSpace: router thread starting&quot;) 49 while not self._stop_router_event.is_set(): 50 self._outbound_message_event.wait(timeout=0.1) 51 if self._stop_router_event.is_set(): 52 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopping&quot;) 53 break 54 self._outbound_message_event.clear() 55 # drain each outbound queue 56 processors = list(self.processors.values()) 57 for processor in processors: 58 outbound_queue = processor.outbound_queue 59 while True: 60 try: 61 message = outbound_queue.get(block=False) 62 log(&quot;debug&quot;, f&quot;LocalSpace: routing message&quot;, message) 63 recipient_processors = [ 64 processor for processor in processors 65 if message[&quot;to&quot;] == processor.agent_id or message[&quot;to&quot;] == &quot;*&quot; 66 ] 67 for recipient_processor in recipient_processors: 68 recipient_processor.inbound_queue.put(message) 69 except queue.Empty: 70 break 71 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopped&quot;) 72 73 return ResourceManager().thread_pool_executor.submit(_router_thread) 74 75 def _stop_router_thread(self): 76 self._stop_router_event.set() 77 self._router_future.result() 78 79 def _create_inbound_queue(self, agent_id) -&gt; Queue: 80 return _LocalQueue() 81 82 def _create_outbound_queue(self, agent_id) -&gt; Queue: 83 return _LocalQueue(outbound_message_event=self._outbound_message_event) . class LocalSpace(agency.space.Space): View Source 30class LocalSpace(Space): 31 &quot;&quot;&quot; 32 A LocalSpace allows Agents to communicate within the python application 33 &quot;&quot;&quot; 34 35 def __init__(self, max_workers=None): 36 super().__init__() 37 self._stop_router_event: threading.Event = threading.Event() 38 self._outbound_message_event: multiprocessing.Event = ResourceManager(max_workers 39 ).multiprocessing_manager.Event() 40 self._router_future: Future = self._start_router_thread() 41 42 def destroy(self): 43 self._stop_router_thread() 44 super().destroy() 45 46 def _start_router_thread(self): 47 def _router_thread(): 48 &quot;&quot;&quot;Routes outbound messages&quot;&quot;&quot; 49 log(&quot;debug&quot;, &quot;LocalSpace: router thread starting&quot;) 50 while not self._stop_router_event.is_set(): 51 self._outbound_message_event.wait(timeout=0.1) 52 if self._stop_router_event.is_set(): 53 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopping&quot;) 54 break 55 self._outbound_message_event.clear() 56 # drain each outbound queue 57 processors = list(self.processors.values()) 58 for processor in processors: 59 outbound_queue = processor.outbound_queue 60 while True: 61 try: 62 message = outbound_queue.get(block=False) 63 log(&quot;debug&quot;, f&quot;LocalSpace: routing message&quot;, message) 64 recipient_processors = [ 65 processor for processor in processors 66 if message[&quot;to&quot;] == processor.agent_id or message[&quot;to&quot;] == &quot;*&quot; 67 ] 68 for recipient_processor in recipient_processors: 69 recipient_processor.inbound_queue.put(message) 70 except queue.Empty: 71 break 72 log(&quot;debug&quot;, &quot;LocalSpace: router thread stopped&quot;) 73 74 return ResourceManager().thread_pool_executor.submit(_router_thread) 75 76 def _stop_router_thread(self): 77 self._stop_router_event.set() 78 self._router_future.result() 79 80 def _create_inbound_queue(self, agent_id) -&gt; Queue: 81 return _LocalQueue() 82 83 def _create_outbound_queue(self, agent_id) -&gt; Queue: 84 return _LocalQueue(outbound_message_event=self._outbound_message_event) . A LocalSpace allows Agents to communicate within the python application . LocalSpace(max_workers=None) View Source 35 def __init__(self, max_workers=None): 36 super().__init__() 37 self._stop_router_event: threading.Event = threading.Event() 38 self._outbound_message_event: multiprocessing.Event = ResourceManager(max_workers 39 ).multiprocessing_manager.Event() 40 self._router_future: Future = self._start_router_thread() . def destroy(self): View Source 42 def destroy(self): 43 self._stop_router_thread() 44 super().destroy() . Cleans up resources used by this space. Subclasses should call super().destroy() when overriding. Inherited Members . agency.space.Space processors add add_foreground remove ",
    "url": "/api_docs/agency/spaces/local_space.html",
    
    "relUrl": "/api_docs/agency/spaces/local_space.html"
  },"52": {
    "doc": "agency.spaces.local_space",
    "title": "agency.spaces.local_space",
    "content": " ",
    "url": "/api_docs/agency/spaces/local_space.html",
    
    "relUrl": "/api_docs/agency/spaces/local_space.html"
  }
}
